{"version":3,"file":"kingly.es.js","sources":["../src/types.js","../src/properties.js","../node_modules/fp-rosetree/index.js","../src/helpers.js","../src/contracts.js","../src/synchronous_fsm.js","../src/converter.js","../src/index.js"],"sourcesContent":["/**\r\n * @typedef {Object} FSM_Def\r\n * @property {FSM_States} states Object whose every key is a control state admitted by the\r\n * specified state machine. The value associated to that key is unused in the present version of the library. The\r\n * hierarchy of the states correspond to property nesting in the `states` object\r\n * @property {Array<EventLabel>} events A list of event monikers the machine is configured to react to\r\n * @property {Array<Transition>} transitions An array of transitions the machine is allowed to take\r\n * @property {*} initialExtendedState The initial value for the machine's extended state\r\n * @property {{updateState :: Function(ExtendedState, ExtendedStateUpdate) : ExtendedState}} updateState function\r\n * which update the extended state of the state machine\r\n */\r\n/**\r\n * @typedef {Object.<ControlState, *>} FSM_States\r\n */\r\n/**\r\n * @typedef {InconditionalTransition | ConditionalTransition} Transition\r\n */\r\n/**\r\n * @typedef {{from: ControlState, to: ControlState|HistoryState, event: EventLabel, action: ActionFactory}} InconditionalTransition\r\n *   Inconditional_Transition encodes transition with no guards attached. Every time the specified event occurs, and\r\n *   the machine is in the specified state, it will transition to the target control state, and invoke the action\r\n *   returned by the action factory\r\n */\r\n/**\r\n * @typedef {{from: ControlState, event: EventLabel, guards: Array<Condition>}} ConditionalTransition Transition for the\r\n * specified state is contingent to some guards being passed. Those guards are defined as an array.\r\n */\r\n/**\r\n * @typedef {{predicate: FSM_Predicate, to: ControlState|HistoryState, action: ActionFactory}} Condition On satisfying the\r\n * specified predicate, the received event data will trigger the transition to the specified target control state\r\n * and invoke the action created by the specified action factory, leading to an update of the internal state of the\r\n * extended state machine and possibly an output to the state machine client.\r\n */\r\n/**\r\n * @typedef {function(ExtendedState, EventData, FSM_Settings) : Actions} ActionFactory\r\n */\r\n/**\r\n * @typedef {{updates: ExtendedStateUpdate, outputs: Array<MachineOutput>}} Actions The actions\r\n * to be performed by the state machine in response to a transition. `updates` represents the state update for\r\n * the variables of the extended state machine. `output` represents the output of the state machine passed to the\r\n * API caller.\r\n */\r\n/** @typedef {function (ExtendedState, EventData) : Boolean} FSM_Predicate */\r\n/** @typedef {{debug, devTool: {tracer}, displayName: String}} FSM_Settings\r\n * Miscellaneous settings including how to update the machine's state and debug\r\n * configuration\r\n * */\r\n/** @typedef {{merge: MergeObsFn, from: FromObsFn, filter: FilterObsFn, map: MapObsFn, share:ShareObsFn, ...}} FSM$_Settings */\r\n/**\r\n * @typedef {function (Array<Observable>) : Observable} MergeObsFn Similar to Rxjs v4's `Rx.Observable.merge`. Takes\r\n * an array of observables and return an observable which passes on all outputs emitted by the observables in the array.\r\n */\r\n/**\r\n * @typedef {function (value) : Observable} FromObsFn Similar to Rxjs v4's `Rx.Observable.from`. Takes\r\n * a value and lift it into an observable which completes immediately after emitting that value.\r\n */\r\n/**\r\n * @typedef {function (value) : Observable} FilterObsFn Similar to Rxjs v4's `Rx.Observable.filter`. Takes\r\n * a value and lift it into an observable which completes immediately after emitting that value.\r\n */\r\n/**\r\n * @typedef {function (value) : Observable} MapObsFn Similar to Rxjs v4's `Rx.Observable.map`. Takes\r\n * a value and lift it into an observable which completes immediately after emitting that value.\r\n */\r\n/**\r\n * @typedef {function (value) : Observable} ShareObsFn Similar to Rxjs v4's `Rx.Observable.share`. Takes\r\n * a value and lift it into an observable which completes immediately after emitting that value.\r\n */\r\n/**\r\n * @typedef {Object.<EventLabel, EventData>} LabelledEvent extended state for a given state machine\r\n */\r\n/**\r\n * @typedef {Object} FsmTraceData\r\n * @property {ControlState} controlState\r\n * @property {{EventLabel, EventData}} eventLabel\r\n * @property {ControlState} targetControlState\r\n * @property {FSM_Predicate} predicate\r\n * @property {ExtendedStateUpdate} updates\r\n * @property {ExtendedState} extendedState\r\n * @property {ActionFactory} actionFactory\r\n * @property {Number} guardIndex\r\n * @property {Number} transitionIndex\r\n */\r\n/**\r\n * @typedef {function(historyType: HistoryType, controlState: ControlState): HistoryState} HistoryStateFactory\r\n */\r\n/**\r\n * @typedef {{type:{}, [HistoryType]: ControlState}} HistoryState\r\n */\r\n/**\r\n * @typedef {Object.<HistoryType, HistoryDict>} History history object containing deeep and shallow history states\r\n * for all relevant control states\r\n */\r\n/**\r\n * @typedef {Object.<ControlState, ControlState>} HistoryDict Maps a compound control state to its history state\r\n */\r\n/**\r\n * @typedef {DEEP | SHALLOW} HistoryType\r\n */\r\n/** @typedef {String} ControlState Name of the control state */\r\n/** @typedef {String} EventLabel */\r\n/**\r\n * @typedef {*} EventData\r\n */\r\n/**\r\n * @typedef {*} ExtendedState extended state for a given state machine\r\n */\r\n/**\r\n * @typedef {*} ExtendedStateUpdate\r\n */\r\n/** @typedef {* | NO_OUTPUT} MachineOutput well it is preferrable that that be an object instead of a primitive */\r\n\r\n\r\n// Contract types\r\n/**\r\n * @typedef {Object} ContractsDef\r\n * @property {String} description name for the series of contracts\r\n * @property {function(FSM_Def):Object} injected a function of the machine definition which returns an object to be\r\n * injected to the contracts predicates\r\n * @property {Array<ContractDef>} contracts array of contract definitions\r\n */\r\n/**\r\n * @typedef {Object} ContractDef\r\n * @property {String} name name for the contract\r\n * @property {Boolean} shouldThrow whether the contract should thrown an exception or alternatively return one\r\n * @property {function(FSM_Def, injected):ContractCheck} predicate array of contract definitions\r\n */\r\n/**\r\n * @typedef {Object} ContractCheck\r\n * @property {Boolean} isFulfilled whether the contract is fulfilled\r\n * @property {{message:String, info:*}} blame information about the cause for the contract failure. The\r\n * `message` property is destined to the developer (for instnce can be printed in the console). Info aims\r\n * at providing additional data helping to track the error cause\r\n * @property {function(FSM_Def, injected):ContractCheck} predicate array of contract definitions\r\n */\r\n\r\n// Component types\r\n/**\r\n * @typedef {String} CommandName\r\n */\r\n/**\r\n * @typedef {function(SubjectEmitter, CommandParams, EffectHandlers, Element, Subject): ()} CommandHandler\r\n * A command handler performs effect, possibly relying on effects implementation included in the effect handlers\r\n * parameter. A command handler also receives parameters for its execution and two subjects, one for receiving\r\n * events, another one for emitting them. Lastly, a command handler may receive an Element which is generally used\r\n * for rendering purposes\r\n */\r\n/**\r\n * @typedef {function(): Subject} SubjectFactory\r\n */\r\n","export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INIT_STATE = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_STATE_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = [];\r\nexport const ACTION_IDENTITY = function ACTION_IDENTITY(){\r\n  return {\r\n    outputs : NO_OUTPUT,\r\n    updates : NO_STATE_UPDATE\r\n  }\r\n}\r\nexport const history_symbol = {};\r\nexport const SHALLOW = 'shallow';\r\nexport const DEEP = 'deep';\r\n\r\nexport const WRONG_EVENT_FORMAT_ERROR = `The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.`\r\nexport const FUNCTION_THREW_ERROR = (fnName, type) => `Exception thrown when executing ${type} ${fnName||\"\"}`\r\nexport const INVALID_ACTION_FACTORY_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not an action.`\r\nexport const INVALID_PREDICATE_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not a boolean.`\r\nexport const ACTION_FACTORY_DESC = `action factory`\r\nexport const ENTRY_ACTION_FACTORY_DESC = `(decorating) entry action`\r\nexport const UPDATE_STATE_FN_DESC = `update state function`\r\nexport const PREDICATE_DESC = `predicate`\r\n\r\nexport const COMMAND_RENDER = 'render'\r\n\r\nexport const CONTRACTS_EVAL = \"CONTRACTS_EVAL\";\r\n\r\nexport const OUTPUTS_MSG = \"OUTPUTS_MSG\";\r\nexport const INPUT_MSG = \"INPUT_MSG\";\r\nexport const WARN_MSG = 'WARN_MSG';\r\nexport const MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';\r\nexport const ERROR_MSG = 'ERROR_MSG';\r\nexport const INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';\r\nexport const INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';\r\nexport const DEBUG_MSG = 'DEBUG_MSG';\r\nexport const INIT_INPUT_MSG = 'INIT_INPUT_MSG';\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","// Ramda fns\r\nimport {\r\n  ACTION_FACTORY_DESC, DEEP, ENTRY_ACTION_FACTORY_DESC, FUNCTION_THREW_ERROR, HISTORY_PREFIX, HISTORY_STATE_NAME,\r\n  INIT_EVENT, INIT_STATE, INVALID_ACTION_FACTORY_EXECUTED, INVALID_PREDICATE_EXECUTED, NO_OUTPUT,\r\n  PREDICATE_DESC,\r\n  SHALLOW, WRONG_EVENT_FORMAT_ERROR\r\n} from \"./properties\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\n\r\nexport const noop = () => {\r\n};\r\nexport const emptyConsole = {log: noop, warn: noop, info: noop, debug: noop, error: noop, trace: noop};\r\nexport const emptyTracer = noop;\r\n\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\nexport function isFunction(x) {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport function isControlState(x) {\r\n  return x && typeof x === 'string' || isHistoryControlState(x)\r\n}\r\n\r\nexport function isEvent(x) {\r\n  return typeof x === 'undefined' || typeof x === 'string'\r\n}\r\n\r\nexport function isActionFactory(x) {\r\n  return x && typeof x === 'function'\r\n}\r\n\r\nexport function make_states(stateList) {\r\n  return stateList.reduce((acc, state) => {\r\n    acc[state] = \"\";\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function make_events(eventList) {\r\n  return eventList\r\n}\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) {\r\n  return ['-', str, '-'].join(\"\");\r\n}\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\nexport function always(x) {\r\n  return x\r\n}\r\n\r\nexport function keys(obj) {\r\n  return Object.keys(obj)\r\n}\r\n\r\nexport function merge(a, b) {\r\n  return Object.assign({}, a, b)\r\n}\r\n\r\n// Contracts\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({from, to}) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const {from, event, guards} = transition;\r\n\r\n  return guards\r\n    ? guards.map(({predicate, to, action}) => ({from, event, predicate, to, action}))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function getDisplayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n/**\r\n * This function MERGES extended state updates. That means that given two state updates, the resulting state update\r\n * will be the concatenation of the two, in the order in which they are passed\r\n * @param {function[]}  arrayUpdateActions\r\n * @returns {function(*=, *=, *=): {updates: *}}\r\n */\r\nexport function mergeModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    return {\r\n      updates: arrayUpdateActions.reduce((acc, updateAction) => {\r\n        const update = updateAction(extendedState, eventData, settings).updates;\r\n        if (update) {\r\n          return acc.concat(update)\r\n        }\r\n        else {\r\n          return acc\r\n        }\r\n      }, []),\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function CHAINS extended state updates, in the order in which they are passed. It is thus similar to a pipe.\r\n * The second update function receives the state updated by the first update function.\r\n * @param {function[]}  arrayUpdateActions\r\n */\r\nexport function chainModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    const {updateState} = settings;\r\n    return {\r\n      updates: arrayUpdateActions\r\n        .reduce((acc, updateAction) => {\r\n          const {extendedState, updates} = acc;\r\n          const update = updateAction(extendedState, eventData, settings).updates;\r\n          const updatedState = updateState(extendedState, updates)\r\n\r\n          return {extendedState: updatedState, updates: update}\r\n        }, {extendedState, updates: []})\r\n        .updates || [],\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {function (Array<Array<MachineOutput>>) : Array<MachineOutput>} mergeOutputFn\r\n * @param {Array<ActionFactory>} arrayActionFactory\r\n * @returns {function(*=, *=, *=): {updates: *[], outputs: *|null}}\r\n */\r\nexport function mergeActionFactories(mergeOutputFn, arrayActionFactory) {\r\n  return function (extendedState, eventData, settings) {\r\n    const arrayActions = arrayActionFactory.map(factory => factory(extendedState, eventData, settings));\r\n    const arrayStateUpdates = arrayActions.map(x => x.updates || []);\r\n    const arrayOutputs = arrayActions.map(x => x.outputs || {});\r\n\r\n    return {\r\n      updates: [].concat(...arrayStateUpdates),\r\n      // for instance, mergeFn = R.mergeAll or some variations around R.mergeDeepLeft\r\n      outputs: mergeOutputFn(arrayOutputs)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type ActionFactory*/\r\nexport function identity(extendedState, eventData, settings) {\r\n  return {\r\n    updates: [],\r\n    outputs: NO_OUTPUT\r\n  }\r\n}\r\n\r\nexport function lastOf(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction formatActionName(action, from, event, to, predicate) {\r\n  const predicateName = predicate ? predicate.name : \"\";\r\n  const formattedPredicate = predicateName ? `[${predicateName}]` : \"\";\r\n  const actionName = action ? action.name : \"identity\";\r\n  const formattedAction = actionName ? actionName : \"unnamed action\";\r\n  return `${formattedAction}:${from}-${event}->${to} ${formattedPredicate}`;\r\n}\r\n\r\nexport function getFsmStateList(states) {\r\n  const {getLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (accStateList, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      accStateList[controlState] = \"\";\r\n\r\n      return accStateList;\r\n    }\r\n  };\r\n  const stateHashMap = traverseObj(traverse, states);\r\n\r\n  return stateHashMap\r\n}\r\n\r\nexport function getStatesType(statesTree) {\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      // true iff control state is a compound state\r\n      return isLeafLabel(treeLabel)\r\n        ? (acc[controlState] = false, acc)\r\n        : (acc[controlState] = true, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesPath(statesTree) {\r\n  const {getLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const pathStr = traversalState.get(tree).path.join('.');\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      return (acc[controlState] = pathStr, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesTransitionsMap(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = transition;\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getStateEventTransitionsMaps(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getEventTransitionsMaps(transitions) {\r\n  // Map an event to the origin control states of the transitions it triggers\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[event] = acc[event] || {};\r\n      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getHistoryStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {from, event, to, action, predicate, gen} = flatTransition;\r\n      if (isHistoryControlState(from)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(from);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n      else if (isHistoryControlState(to)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(to);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getTargetStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {to} = flatTransition;\r\n      map.set(to, (map.get(to) || []).concat([flatTransition]));\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getAncestorMap(statesTree) {\r\n  const {getLabel, getChildren} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = getChildren(tree)\r\n      const childrenControlStates = children.map(tree => Object.keys(getLabel(tree))[0]);\r\n\r\n      childrenControlStates.forEach(state => {\r\n        acc[state] = acc[state] || [];\r\n        acc[state] = acc[state].concat(controlState);\r\n      });\r\n\r\n      return acc\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function computeHistoryMaps(control_states) {\r\n  if (Object.keys(control_states).length === 0) {\r\n    throw `computeHistoryMaps : passed empty control states parameter?`\r\n  }\r\n\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {stateList: [], stateAncestors: {}},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      acc.stateList = acc.stateList.concat(controlState);\r\n\r\n      // NOTE : we don't have to worry about path having only one element\r\n      // that case correspond to the root of the tree which is excluded from visiting\r\n      const {path} = traversalState.get(tree);\r\n      traversalState.set(JSON.stringify(path), controlState);\r\n      const parentPath = path.slice(0, -1);\r\n      if (parentPath.length === 1) {\r\n        // That's the root\r\n        traversalState.set(JSON.stringify(parentPath), INIT_STATE);\r\n      }\r\n      else {\r\n        const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n        acc.stateAncestors[controlState] = [parentControlState];\r\n\r\n        const {ancestors} = path.reduce((acc, _) => {\r\n          const parentPath = acc.path.slice(0, -1);\r\n          acc.path = parentPath;\r\n          if (parentPath.length > 1) {\r\n            const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n            acc.ancestors = acc.ancestors.concat(parentControlState);\r\n          }\r\n\r\n          return acc\r\n        }, {ancestors: [], path});\r\n        acc.stateAncestors[controlState] = ancestors;\r\n      }\r\n\r\n      return acc\r\n    }\r\n  };\r\n  const {stateList, stateAncestors} = traverseObj(traverse, control_states);\r\n\r\n  return {stateList, stateAncestors}\r\n}\r\n\r\nexport function mapOverTransitionsActions(mapFn, transitions) {\r\n  return reduceTransitions(function (acc, transition, guardIndex, transitionIndex) {\r\n    const {from, event, to, action, predicate} = transition;\r\n    const mappedAction = mapFn(action, transition, guardIndex, transitionIndex);\r\n    mappedAction.displayName = mappedAction.displayName || (action && (action.name || action.displayName || formatActionName(action, from, event, to, predicate)));\r\n\r\n    if (typeof(predicate) === 'undefined') {\r\n      acc.push({from, event, to, action: mappedAction})\r\n    }\r\n    else {\r\n      if (guardIndex === 0) {\r\n        acc.push({from, event, guards: [{to, predicate, action: mappedAction}]})\r\n      }\r\n      else {\r\n        acc[acc.length - 1].guards.push({to, predicate, action: mappedAction})\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, [], transitions)\r\n}\r\n\r\nexport function reduceTransitions(reduceFn, seed, transitions) {\r\n  const result = transitions.reduce((acc, transitionStruct, transitionIndex) => {\r\n    let {from, event, to, gen, action, guards} = transitionStruct;\r\n    // Edge case when no guards are defined\r\n    if (!guards) {\r\n      guards = gen ? [{to, action, gen, predicate: undefined}] : [{to, action, predicate: undefined}]\r\n    }\r\n    return guards.reduce((acc, guard, guardIndex) => {\r\n      const {to, action, gen, predicate} = guard;\r\n      return gen\r\n        ? reduceFn(acc, {from, event, to, action, predicate, gen}, guardIndex, transitionIndex)\r\n        : reduceFn(acc, {from, event, to, action, predicate}, guardIndex, transitionIndex)\r\n    }, acc);\r\n  }, seed);\r\n\r\n  return result\r\n}\r\n\r\nexport function everyTransition(pred, transition) {\r\n  return reduceTransitions((acc, flatTransition) => {\r\n    return acc && pred(flatTransition)\r\n  }, true, [transition])\r\n}\r\n\r\nexport function computeTimesCircledOn(edgePath, edge) {\r\n  return edgePath.reduce((acc, edgeInEdgePath) => edgeInEdgePath === edge ? acc + 1 : acc, 0);\r\n}\r\n\r\nexport function isInitState(s) {\r\n  return s === INIT_STATE\r\n}\r\n\r\nexport function isInitEvent(e) {\r\n  return e === INIT_EVENT\r\n}\r\n\r\nexport function isEventless(e) {\r\n  return typeof e === 'undefined'\r\n}\r\n\r\nexport function arrayizeOutput(output) {\r\n  return output === NO_OUTPUT\r\n    ? NO_OUTPUT\r\n    : Array.isArray(output)\r\n      ? output\r\n      : [output]\r\n}\r\n\r\nexport function isHistoryControlState(to) {\r\n  return typeof to === 'object' && (DEEP in to || SHALLOW in to)\r\n}\r\n\r\nexport function getHistoryParentState(to) {\r\n  return to[SHALLOW] || to[DEEP]\r\n}\r\n\r\nexport function isShallowHistory(to) {\r\n  return to[SHALLOW]\r\n}\r\n\r\nexport function isDeepHistory(to) {\r\n  return to[DEEP]\r\n}\r\n\r\nexport function getHistoryType(history) {\r\n  return history[DEEP] ? DEEP : SHALLOW\r\n}\r\n\r\nexport function getHistoryUnderlyingState(history) {\r\n  return history[getHistoryType(history)]\r\n}\r\n\r\nexport function isHistoryStateEdge(edge) {\r\n  return typeof edge.history !== 'undefined'\r\n}\r\n\r\n/**\r\n * Creates a history object from a state list. The created history object represents the history states when no\r\n * control states have been entered or exited.\r\n * @param stateList\r\n * @returns {History}\r\n */\r\nexport function initHistoryDataStructure(stateList) {\r\n  // NOTE : we update history in place, so we need two different objects here, even\r\n  // when they start with the same value\r\n  const initHistory = () => stateList.reduce((acc, state) => (acc[state] = '', acc), {});\r\n  return {[DEEP]: initHistory(), [SHALLOW]: initHistory()};\r\n}\r\n\r\nexport function isCompoundState(analyzedStates, controlState) {\r\n  const {statesAdjacencyList} = analyzedStates;\r\n  return statesAdjacencyList[controlState] && statesAdjacencyList[controlState].length !== 0\r\n}\r\n\r\nexport function isAtomicState(analyzedStates, controlState) {\r\n  return !isCompoundState(analyzedStates, controlState)\r\n}\r\n\r\n/**\r\n * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the\r\n * `stateAncestors` which are the ancestors for the exited state.\r\n * @param {History} history Contains deep history and shallow history for all\r\n * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function\r\n * `updateHistory` allows to update the history as transitions occur in the state machine.\r\n * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors\r\n * @returns {History}\r\n * @modifies history\r\n */\r\nexport function updateHistory(history, stateAncestors, state_from_name) {\r\n  // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)\r\n\r\n  if (state_from_name === INIT_STATE) {\r\n    return history\r\n  }\r\n  else {\r\n      // ancestors for the state which is exited\r\n      const ancestors = stateAncestors[state_from_name] || [];\r\n      ancestors.reduce((oldAncestor, newAncestor) => {\r\n        // set the exited state in the history of all ancestors\r\n        history[DEEP][newAncestor] = state_from_name;\r\n        history[SHALLOW][newAncestor] = oldAncestor;\r\n\r\n        return newAncestor\r\n      }, state_from_name);\r\n\r\n    return history\r\n  }\r\n}\r\n\r\n/**\r\n * for all parentState, computes history(parentState), understood as the last control state descending from the\r\n * parent state. Last can be understood two ways : DEEP and SHALLOW. Deep history state refer to the last atomic\r\n * control state which is a children of the parent state and was exited. Shallow history states refer to the last\r\n * control state which is a direct child of the parent state and was exited.\r\n * @param {FSM_States} states\r\n * @param {Array<ControlState>} controlStateSequence Sequence of control states which has been entered and exited,\r\n * and from which the history must be injected\r\n * @param {DEEP | SHALLOW} historyType\r\n * @param {ControlState} historyParentState\r\n * @returns {Object.<DEEP|SHALLOW, Object.<ControlState, ControlState>>}\r\n */\r\nexport function computeHistoryState(states, controlStateSequence, historyType, historyParentState) {\r\n  // NOTE : we compute the whole story every time. This is inefficient, but for now sufficient\r\n  const {stateList, stateAncestors} = computeHistoryMaps(states);\r\n  let history = initHistoryDataStructure(stateList);\r\n  history = controlStateSequence.reduce(\r\n    (history, controlState) => updateHistory(history, stateAncestors, controlState),\r\n    history\r\n  );\r\n\r\n  return history[historyType][historyParentState]\r\n}\r\n\r\nexport function findInitTransition(transitions) {\r\n  return transitions.find(transition => {\r\n    return transition.from === INIT_STATE && transition.event === INIT_EVENT\r\n  })\r\n}\r\n\r\nexport function tryCatch(fn, errCb) {\r\n  return function tryCatch(...args) {\r\n    try {\r\n      return fn.apply(fn, args);\r\n    }\r\n    catch (e) {\r\n      return errCb(e, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport function tryCatchMachineFn(fnType, fn, argsDesc = []) {\r\n  return tryCatch(fn, (e, args) => {\r\n    const err = new Error(e);\r\n    const fnName = getFunctionName(fn);\r\n    // NOTE : we concatenate causes but not `info`\r\n    const probableCause = FUNCTION_THREW_ERROR(fnName, fnType);\r\n    err.probableCause = e.probableCause ? [e.probableCause, probableCause].join('\\n') : probableCause;\r\n\r\n    const info = {\r\n      fnName,\r\n      params: argsDesc.reduce((acc, argDesc, index) => {\r\n        return acc[argDesc] = args[index], acc\r\n      }, {})\r\n    };\r\n    err.info = e.info ? [].concat([e.info]).concat([info]) : info;\r\n\r\n    return err\r\n  })\r\n}\r\n\r\nexport function getFunctionName(actionFactory) {\r\n  return actionFactory.name || actionFactory.displayName || 'anonymous'\r\n}\r\n\r\n/**\r\n *\r\n * @param {function: true | Error} contract Contract returns either true (fulfilled contract) or an Error with an\r\n * optional info properties to give more details about the cause of the error\r\n * @param {Array} arrayParams Parameters to be passed to the conract\r\n * @returns {undefined|{when, location, info, message, ...}} if the contract is fulfilled\r\n * @throws if the contract fails\r\n */\r\nexport function assert(contract, arrayParams) {\r\n  const contractName = contract.name ||contract.name.displayName || \"\";\r\n  const isFulfilledOrError = contract.apply(null, arrayParams);\r\n  if (isFulfilledOrError === true) return void 0\r\n  else {\r\n    return {\r\n      ...isFulfilledOrError,\r\n      when: `Checking contract`,\r\n      message: [isFulfilledOrError.message, `failed contract ${contractName}`].join(\"\\n\"),\r\n      info: isFulfilledOrError.info,\r\n    }\r\n  }\r\n}\r\n\r\nexport function notifyThrows(console, error) {\r\n  console.error(error);\r\n  error.probableCause && console.error(`Probable cause: ${error.probableCause}`);\r\n  error.info && console.error(`ERROR: additional info`, error.info);\r\n}\r\n\r\n/**\r\n * false iff no errors or invalid actions\r\n * if not throws an exception\r\n * @param {{debug, console}} notify\r\n * @param {*} execInfo Information about the call - should include the function, and the parameters for the function\r\n * call\r\n * @param {Actions | Error} actionResultOrError\r\n * @param {function} throwFn handles when the action factory throws during its execution\r\n * @param {function} invalidResultFn handles when the action factory returns invalid actions\r\n * @returns {boolean}\r\n * @param postCondition\r\n */\r\nexport function handleFnExecError(notify, execInfo, actionResultOrError, postCondition, throwFn, invalidResultFn) {\r\n  const {debug, console} = notify;\r\n\r\n  if (debug && actionResultOrError instanceof Error) {\r\n    throwFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else if (debug && !postCondition(actionResultOrError)) {\r\n    invalidResultFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else return false\r\n}\r\n\r\nexport function notifyAndRethrow({debug, console}, actionResultOrError) {\r\n  notifyThrows(console, actionResultOrError)\r\n  throw actionResultOrError\r\n}\r\n\r\nexport function throwIfInvalidActionResult({debug, console}, actionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: actionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidGuardResult({debug, console}, resultOrError, exec) {\r\n  const predName = getFunctionName(exec.predicate);\r\n  const error = new Error(INVALID_PREDICATE_EXECUTED(predName, PREDICATE_DESC));\r\n  error.info = {\r\n    predicateName: predName,\r\n    params: exec,\r\n    returned: resultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidEntryActionResult({debug, console}, exitActionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ENTRY_ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: exitActionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function isActions(obj) {\r\n  return obj && `updates` in obj && `outputs` in obj\r\n    && Array.isArray(obj.outputs)\r\n  // && Array.isArray(obj.updates)\r\n  // !! does not have to be arrays. HAs to be anything that is accepted by updateState\r\n}\r\n\r\n/**\r\n * That is a Either contract, not a Boolean contract!\r\n * @param obj\r\n * @returns {boolean|Error}\r\n */\r\nexport function isEventStruct(obj) {\r\n  let trueOrError;\r\n  if (!obj || typeof obj !== 'object') {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `not an object!`}\r\n  }\r\n  else if (Object.keys(obj).length > 1) {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `Event objects must have only one key which is the event name!`}\r\n  }\r\n  else trueOrError = true;\r\n\r\n  return trueOrError\r\n}\r\n\r\nexport function isError(obj) {\r\n  return obj instanceof Error\r\n}\r\n\r\nexport function destructureEvent(obj) {\r\n  const eventName = Object.keys(obj)[0];\r\n  const eventData = obj[eventName];\r\n\r\n  return {eventName, eventData}\r\n}\r\n\r\nexport function formatUndefinedInJSON(obj){\r\n  return JSON.stringify(obj, (key,value)=> {if (value === undefined) return \"undefined\"; else return value})\r\n}\r\n\r\nexport class KinglyError extends Error {\r\n  constructor(m, console, tracer) {\r\n    super(m && m.message || \"\");\r\n    this.name = `KinglyError`;\r\n    this.stack = m && m.stack || this.stack;\r\n    this.errors = m;\r\n    const { when, location, info, message } = m || {};\r\n    const fm = `At ${location}: ${when} => ${message}`;\r\n    const infoMsg = info ? `See extra info in console` : \"\";\r\n    const fullMsg = [fm, infoMsg].join(\"\\n\");\r\n    // this.message = fullMsg;\r\n    console && console.error(fullMsg);\r\n    info && console && console.info(info);\r\n  }\r\n}\r\n","import {\r\n    emptyConsole,\r\n    findInitTransition,\r\n    getAncestorMap,\r\n    getEventTransitionsMaps,\r\n    getHistoryStatesMap,\r\n    getHistoryUnderlyingState,\r\n    getStatesPath,\r\n    getStatesTransitionsMap,\r\n    getStateEventTransitionsMaps,\r\n    getStatesType,\r\n    getTargetStatesMap,\r\n    isActionFactory,\r\n    isControlState,\r\n    isEvent,\r\n    isFunction,\r\n    isHistoryControlState,\r\n    noop\r\n} from \"./helpers\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\nimport {CONTRACTS_EVAL, INIT_EVENT, INIT_STATE} from \"./properties\"\r\n\r\n// Contracts\r\n\r\n// S2. State names must be unique\r\nexport const noDuplicatedStates = {\r\n    name: 'noDuplicatedStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {getLabel} = objectTreeLenses;\r\n        const traverse = {\r\n            strategy: PRE_ORDER,\r\n            seed: {duplicatedStates: [], statesHashMap: {}},\r\n            visit: (acc, traversalState, tree) => {\r\n                const {duplicatedStates, statesHashMap} = acc;\r\n                const treeLabel = getLabel(tree);\r\n                const controlState = Object.keys(treeLabel)[0];\r\n                if (controlState in statesHashMap) {\r\n                    return {\r\n                        duplicatedStates: duplicatedStates.concat(controlState),\r\n                        statesHashMap\r\n                    }\r\n                }\r\n                else {\r\n                    return {\r\n                        duplicatedStates,\r\n                        statesHashMap: (statesHashMap[controlState] = \"\", statesHashMap)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const {duplicatedStates} = traverseObj(traverse, fsmDef.states);\r\n\r\n        const isFulfilled = duplicatedStates.length === 0;\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `State names must be unique! Found duplicated state names. Cf. log`,\r\n                info: {duplicatedStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S1. State name cannot be a reserved state name (for now only INIT_STATE)\r\nexport const noReservedStates = {\r\n    name: 'noReservedStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesType}) => {\r\n        return {\r\n            isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,\r\n            blame: {\r\n                message: `You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log`,\r\n                info: {reservedStates: [INIT_STATE], statesType}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S4. At least one control state (other than the initial state) muat be declared\r\nexport const atLeastOneState = {\r\n    name: 'atLeastOneState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesType}) => {\r\n        return {\r\n            isFulfilled: Object.keys(statesType).length > 0,\r\n            blame: {\r\n                message: `Machine configuration must define at least one control state! Cf. log`,\r\n                info: {statesType}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S5. check initial control state is a defined state in states\r\nexport const isInitialControlStateDeclared = {\r\n    name: 'isInitialControlStateDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition, statesType}) => {\r\n        const {initialControlState, transitions} = fsmDef;\r\n        const stateList = Object.keys(statesType);\r\n        if (initialControlState) {\r\n            return {\r\n                isFulfilled: stateList.indexOf(initialControlState) > -1,\r\n                blame: {\r\n                    message: `Configured initial control state must be a declared state. Cf. log`,\r\n                    info: {initialControlState, declaredStates: stateList}\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n\r\n    },\r\n};\r\n\r\n// E0. `fsmDef.events` msut be an array of strings\r\nexport const eventsAreStrings = {\r\n    name: 'eventsAreStrings',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        return {\r\n            isFulfilled: fsmDef.events.every(x => typeof x === 'string'),\r\n            blame: {\r\n                message: `Events must be an array of strings!`,\r\n                info: {events: fsmDef.events}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const validInitialConfig = {\r\n    name: 'validInitialConfig',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition}) => {\r\n        const {initialControlState} = fsmDef;\r\n\r\n        if (initTransition && initialControlState) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!`,\r\n                    info: {initialControlState, initTransition}\r\n                }\r\n            }\r\n        }\r\n        else if (!initTransition && !initialControlState) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?`,\r\n                    info: {initialControlState, initTransition}\r\n                }\r\n            }\r\n        }\r\n        else return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n    },\r\n};\r\n\r\n// T1. There must be configured at least one transition away from the initial state\r\n// T2. A transition away from the initial state can only be triggered by the initial event\r\n// T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history\r\n// state as target\r\n// T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We\r\n// can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and\r\n// debugging!. So enforce ACTIONS to be identity\r\nexport const validInitialTransition = {\r\n    name: 'validInitialTransition',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition}) => {\r\n        const {initialControlState, transitions} = fsmDef;\r\n        const initTransitions = transitions.reduce((acc, transition) => {\r\n            transition.from === INIT_STATE && acc.push(transition);\r\n            return acc\r\n        }, []);\r\n        // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!\r\n        // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't\r\n        // enforce the part of the contract which require to have no actions for initial transitions...\r\n        const isFulfilled =\r\n            (initialControlState && !initTransition) ||\r\n            (!initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT\r\n                && (\r\n                    isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY\r\n                    || areCconditionalTransitions(initTransition)\r\n                    // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)\r\n                )\r\n            );\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Invalid configuration for initial transition! Cf. log`,\r\n                info: {initTransition, initTransitions, initialControlState}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound\r\n// state or A is the initial state\r\nexport const initEventOnlyInCompoundStates = {\r\n    name: 'initEventOnlyInCompoundStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const atomicStates = Object.keys(statesType).filter(controlState => !statesType[controlState]);\r\n        const atomicInitTransitions = atomicStates.map(\r\n            atomicState => ({\r\n                [atomicState]: statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]\r\n            })\r\n        ).filter(obj => Object.values(obj)[0]);\r\n\r\n        const hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0\r\n\r\n        return {\r\n            isFulfilled: hasInitEventOnlyInCompoundStates,\r\n            blame: {\r\n                message: `Found at least one atomic state with an entry transition! That is forbidden! Cf. log`,\r\n                info: {initTransitions: atomicInitTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined\r\n// T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have a history state as target\r\n// NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop\r\n// T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have the history state as target and has a target control state that is one of its substates (no\r\n// out-of-hierarchy INIT transitions)\r\nexport const validInitialTransitionForCompoundState = {\r\n    name: 'validInitialTransitionForCompoundState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const compoundStates = Object.keys(statesType).filter(controlState => statesType[controlState]);\r\n        const compoundStatesInitTransitions = compoundStates.map(\r\n            compoundState => statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT]);\r\n\r\n        const allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);\r\n\r\n        if (!allHaveInitTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state without an entry transition! Cf. log`,\r\n                    info: {\r\n                        hasEntryTransitions: compoundStates.map(\r\n                            state => ({[state]: !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT])}))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const allHaveValidInitTransitions = allHaveInitTransitions &&\r\n            compoundStatesInitTransitions.every(initTransition => {\r\n                const {guards, to} = initTransition;\r\n                if (!guards) {\r\n                    //  T7a\r\n                    return typeof to === 'string'\r\n                }\r\n                else {\r\n                    const targetStates = guards.map(guard => guard.to);\r\n                    return targetStates.every(targetState => typeof targetState === 'string')\r\n                }\r\n            });\r\n        if (!allHaveValidInitTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log`,\r\n                    info: {entryTransitions: compoundStatesInitTransitions}\r\n                }\r\n            }\r\n        }\r\n        ;\r\n\r\n        const allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions &&\r\n            compoundStatesInitTransitions.every(initTransition => {\r\n                const {from, guards, to} = initTransition;\r\n\r\n                // Don't forget to also eliminate the case when from = to\r\n                // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the\r\n                // other from declared states\r\n                if (!guards){\r\n                    return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n                }\r\n                else {\r\n                    const targetStates = guards.map(guard => guard.to);\r\n                    return targetStates.every(to => {\r\n                        return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n                    })\r\n                }\r\n            });\r\n        if (!allHaveTargetStatesWithinHierarchy) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! `,\r\n                    info: {states: fsmDef.states, statesPath, entryTransitions: compoundStatesInitTransitions}\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            isFulfilled: true,\r\n            blame: void 0\r\n        }\r\n    },\r\n};\r\n\r\n// T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X\r\n// T24. Check that we have this implicitly : Compound states must not have eventless transitions\r\n// defined on them (would introduce ambiguity with the INIT transition).\r\nexport const validEventLessTransitions = {\r\n    name: 'validEventLessTransitions',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const stateList = Object.keys(statesType);\r\n        const failingOriginControlStates = stateList.map(state => {\r\n            return {\r\n                [state]: statesTransitionsMap[state] &&\r\n                `${void 0}` in statesTransitionsMap[state] &&\r\n                Object.keys(statesTransitionsMap[state]).length !== 1\r\n            }\r\n        }).filter(obj => Object.values(obj)[0] !== void 0 && Object.values(obj)[0]);\r\n\r\n        const isFulfilled = failingOriginControlStates.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found at least one control state without both an eventless transition and a competing transition! Cf. log`,\r\n                info: {failingOriginControlStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together\r\n// in a single array and there cannot be two transition rows showcasing A -ev-> * transitions\r\nexport const allStateTransitionsOnOneSingleRow = {\r\n    name: 'allStateTransitionsOnOneSingleRow',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const statesTransitionsInfo = originStateList.reduce((acc, state) => {\r\n            const events = Object.keys(stateEventTransitionsMaps[state]);\r\n            const wrongEventConfig = events.filter(event => stateEventTransitionsMaps[state][event].length > 1);\r\n            if (wrongEventConfig.length > 0) {\r\n                acc[state] = wrongEventConfig;\r\n            }\r\n\r\n            return acc\r\n        }, {});\r\n\r\n        const isFulfilled = Object.keys(statesTransitionsInfo).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log`,\r\n                info: {statesTransitionsInfo}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A\r\n// with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.\r\n// The event `ev` could trigger a transition towards either B or C\r\nexport const noConflictingTransitionsWithAncestorState = {\r\n    name: 'noConflictingTransitionsWithAncestorState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, eventTransitionsMaps, ancestorMap}) => {\r\n        const eventList = Object.keys(eventTransitionsMaps).filter(ev => ev !== INIT_EVENT && ev !== void 0);\r\n        const eventTransitionsInfo = eventList.reduce((acc, event) => {\r\n            const states = Object.keys(eventTransitionsMaps[event]);\r\n            // The wrongly configured states are those which have an ancestor also in the transition map for the same event\r\n            const wrongStateConfig = states\r\n                .filter(state => state !== INIT_STATE)\r\n                .map(state => ancestorMap[state] && {\r\n                    [state]: ancestorMap[state].find(\r\n                        ancestorState => states.indexOf(ancestorState) > -1\r\n                    )\r\n                })\r\n                // removing cases : undefined and {[state]: undefined}\r\n                .filter(obj => {\r\n                    return obj && Object.values(obj).filter(Boolean).length > 0\r\n                });\r\n\r\n            if (wrongStateConfig.length > 0) {\r\n                acc[event] = wrongStateConfig;\r\n            }\r\n\r\n            return acc\r\n        }, {});\r\n\r\n        const isFulfilled = Object.keys(eventTransitionsInfo).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log`,\r\n                info: {eventTransitionsInfo}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T16.a History states must be target states\r\nexport const isHistoryStatesTargetStates = {\r\n    name: 'isHistoryStatesTargetStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {}) => {\r\n        const wrongHistoryStates = fsmDef.transitions.reduce((acc, transition) => {\r\n            return isHistoryControlState(transition.from)\r\n                ? acc.concat(transition)\r\n                : acc\r\n        }, []);\r\n\r\n        const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log`,\r\n                info: {wrongHistoryStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T16.b History states must be compound states\r\nexport const isHistoryStatesCompoundStates = {\r\n    name: 'isHistoryStatesCompoundStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, statesType}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const wrongHistoryStates = originStateList.map(originState => {\r\n            if (originState === INIT_STATE) return []\r\n\r\n            const events = Object.keys(stateEventTransitionsMaps[originState]);\r\n\r\n            return events.reduce((acc, event) => {\r\n                // I should only ever have one transition, that is checked in another contract\r\n                // !! if there are several transitions, we may have a false positive, but that is ok\r\n                // When the other contract will fail and the issue will be solved, and app will be rerun,\r\n                // this will be recomputed correctly\r\n                const transition = stateEventTransitionsMaps[originState][event][0];\r\n                const {guards, to} = transition;\r\n                if (!guards) {\r\n                    // Reminder: statesType[controlState] === true iff controlState is compound state\r\n                    return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n                        ? acc.concat(transition)\r\n                        : acc\r\n                }\r\n                else {\r\n                    return guards.reduce((acc, guard) => {\r\n                        const {to} = guard;\r\n\r\n                        return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n                            ? acc.concat(transition)\r\n                            : acc\r\n                    }, acc)\r\n                }\r\n            }, [])\r\n        })\r\n            .reduce((acc, x) => acc.concat(x), []);\r\n\r\n        const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log`,\r\n                info: {wrongHistoryStates, states: fsmDef.states}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T17 An history state must refer to an existing state\r\nexport const isHistoryStatesExisting = {\r\n    name: 'isHistoryStatesExisting',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {historyStatesMap, statesType}) => {\r\n        const invalidTransitions = Array.from(historyStatesMap.entries())\r\n            .map(([historyState, flatTransitions]) => {\r\n                return !(historyState in statesType) && {historyState, flatTransitions}\r\n            })\r\n            .filter(Boolean);\r\n\r\n        const howMany = Object.keys(invalidTransitions).length;\r\n        const isFulfilled = howMany === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found ${howMany} history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition.`,\r\n                info: {invalidTransitions, states: fsmDef.states}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport function isInconditionalTransition(transition) {\r\n    const {from, event, guards, to, action} = transition;\r\n\r\n    return typeof guards === `${void 0}` && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action)\r\n}\r\n\r\nexport function isValidGuard(guard) {\r\n    const {to, predicate, action} = guard;\r\n\r\n    return to && isControlState(to) && isFunction(predicate) && isActionFactory(action)\r\n}\r\n\r\nexport function areCconditionalTransitions(transition) {\r\n    const {from, event, guards, to} = transition;\r\n\r\n    return guards && Array.isArray(guards) && guards.length > 0\r\n        && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard)\r\n}\r\n\r\nexport const isValidFsmDef = {\r\n    name: 'isValidFsmDef',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {transitions, states, events, initialExtendedState} = fsmDef;\r\n        const isValidTransitions = transitions && Array.isArray(transitions);\r\n        const isValidStates = states && typeof(states) === 'object';\r\n        const isValidEvents = events && Array.isArray(events);\r\n        if (!isValidTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The transitions property for a machine definition must be an array!`,\r\n                    info: {transitions}\r\n                }\r\n            }\r\n        }\r\n        else if (!isValidStates) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The states property for a machine definition must be an object!`,\r\n                    info: {states}\r\n                }\r\n            }\r\n        }\r\n        else if (!isValidEvents) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The events property for a machine definition must be an array!`,\r\n                    info: {events}\r\n                }\r\n            }\r\n        }\r\n        // NOTE : we do not deal with initialExtendedState, initialControlState and settings\r\n        // this is done in other contracts\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n    },\r\n}\r\n\r\n// T18. Transitions have a valid format, and are either inconditional (no guards) or conditional\r\n// events are strings\r\n// guards are functions\r\n// action factories are functions\r\nexport const haveTransitionsValidTypes = {\r\n    name: 'haveTransitionsValidTypes',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {transitions} = fsmDef;\r\n        const wrongTransitions = transitions\r\n            .map((transition, transitionIndex) => {\r\n                return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {\r\n                    transition,\r\n                    index: transitionIndex\r\n                }\r\n            })\r\n            .filter(Boolean)\r\n\r\n        const howMany = Object.keys(wrongTransitions).length;\r\n        const isFulfilled = howMany === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found ${howMany} transitions with invalid format! Check logs for more details.`,\r\n                info: {wrongTransitions, transitions}\r\n            }\r\n        }\r\n    },\r\n}\r\n\r\nexport const areEventsDeclared = {\r\n    name: 'areEventsDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {eventTransitionsMaps}) => {\r\n        const eventList = Object.keys(eventTransitionsMaps);\r\n        const declaredEventList = fsmDef.events;\r\n        const eventsDeclaredButNotTriggeringTransitions = declaredEventList\r\n            .map(declaredEvent => eventList.indexOf(declaredEvent) === -1 && declaredEvent)\r\n            .filter(Boolean);\r\n        const eventsNotDeclaredButTriggeringTransitions = eventList\r\n            .map(triggeringEvent => declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent)\r\n            .filter(Boolean)\r\n            // Filtering out init events which must not be declared, being reserved events\r\n            // Filtering out undefined events linked to eventless transitions\r\n            .filter(ev => ev !== INIT_EVENT && ev !== 'undefined')\r\n\r\n        const isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0\r\n            && eventsNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `All declared events must be used in transitions. All events used in transition must be declared! Cf. log`,\r\n                info: {eventsDeclaredButNotTriggeringTransitions, eventsNotDeclaredButTriggeringTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const areStatesDeclared = {\r\n    name: 'areStatesDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, targetStatesMap, statesType}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const targetStateList = Array.from(targetStatesMap.keys()).filter(x => typeof x !== 'object');\r\n        const stateList = Object.keys([originStateList, targetStateList].reduce((acc, stateList) => {\r\n            stateList.forEach(state => acc[state] = true)\r\n            return acc\r\n        }, {}));\r\n        const declaredStateList = Object.keys(statesType);\r\n        const statesDeclaredButNotTriggeringTransitions = declaredStateList\r\n            .map(declaredState => stateList.indexOf(declaredState) === -1 && declaredState)\r\n            .filter(Boolean);\r\n        const statesNotDeclaredButTriggeringTransitions = stateList\r\n            .map(stateInTransition =>\r\n                stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition)\r\n            .filter(Boolean);\r\n\r\n        const isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0\r\n            && statesNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `All declared states must be used in transitions. All states used in transition must be declared! Cf. log`,\r\n                info: {statesDeclaredButNotTriggeringTransitions, statesNotDeclaredButTriggeringTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T25. SS1 - as of v0.13 settings is no longer mandatory\r\nexport const isValidSettings = {\r\n    name: 'isValidSettings',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef) => {\r\n        return {\r\n            isFulfilled: true,\r\n            blame: void 0\r\n        }\r\n    },\r\n};\r\n\r\n// T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not\r\nexport const isInitialStateOriginState = {\r\n    name: 'isInitialStateOriginState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {targetStatesMap}) => {\r\n\r\n        if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one transition with the initial state as target state! CF. log`,\r\n                    info: {targetStates: Array.from(targetStatesMap.keys()), transitions: fsmDef.transitions}\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of\r\n// little practical value, though being a possible source of ambiguity or infinite loops)\r\n// A -_> A impossible on compound states because there is A -INIT-> X\r\n// so only possibility is A -_> A with A atomic state\r\nexport const isValidSelfTransition = {\r\n    name: 'isValidSelfTransition',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {targetStatesMap, statesType}) => {\r\n        const targetStates = Array.from(targetStatesMap.keys());\r\n        const wrongSelfTransitions = targetStates\r\n            .map(targetState => {\r\n                const flatTransitions = targetStatesMap.get(targetState);\r\n                return flatTransitions\r\n                    .map(flatTransition => {\r\n                        const {from, event} = flatTransition;\r\n                        if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {\r\n                            return {state: targetState, flatTransition}\r\n                        }\r\n                    })\r\n                    .filter(Boolean)\r\n            })\r\n            .filter(x => x.length > 0);\r\n\r\n        return {\r\n            isFulfilled: wrongSelfTransitions.length === 0,\r\n            blame: {\r\n                message: `Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log`,\r\n                info: {wrongSelfTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const fsmContracts = {\r\n    injected: (fsmDef, settings) => {\r\n        return {\r\n            statesType: getStatesType(fsmDef.states),\r\n            initTransition: findInitTransition(fsmDef.transitions),\r\n            statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),\r\n            stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),\r\n            eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),\r\n            ancestorMap: getAncestorMap(fsmDef.states),\r\n            statesPath: getStatesPath(fsmDef.states),\r\n            historyStatesMap: getHistoryStatesMap(fsmDef.transitions),\r\n            targetStatesMap: getTargetStatesMap(fsmDef.transitions)\r\n        }\r\n    },\r\n    description: 'FSM structure',\r\n    contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates],\r\n};\r\n\r\n/**\r\n * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may\r\n * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing\r\n * contract data structure include relevant information about the failing contract, in particular the contract name,\r\n * the associated error message and additional info expliciting the error message.\r\n * @param contractsDef\r\n * @param settings\r\n * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}\r\n */\r\nfunction makeContractHandler(contractsDef, settings) {\r\n    const console = settings && settings.debug && settings.debug.console || emptyConsole;\r\n    const trace = settings && settings.debug && settings.debug.trace || noop;\r\n    const contractsDescription = contractsDef.description;\r\n\r\n    return function checkContracts(...args) {\r\n        const failingContracts = [];\r\n        const computedArgs = contractsDef.injected.apply(null, args);\r\n        const isFulfilled = contractsDef.contracts.reduce((acc, contract) => {\r\n            const {name: contractName, predicate, shouldThrow} = contract;\r\n            const fullArgs = args.concat(computedArgs);\r\n            const {isFulfilled, blame} = predicate.apply(null, fullArgs);\r\n            const blameMessageHeader = `${contractsDescription} FAILS ${contractName}!`;\r\n            const {message, info} = blame || {};\r\n\r\n            if (isFulfilled) return acc\r\n            else {\r\n                failingContracts.push({name: contractName, message, info});\r\n                console.error(blameMessageHeader);\r\n                console.error([contractName, message].join(': '));\r\n                console.debug('Supporting error data:', info);\r\n\r\n                if (shouldThrow) throw new Error([blameMessageHeader, `check console for information!`].join('\\n'))\r\n                else {\r\n                    return false\r\n                }\r\n            }\r\n        }, true)\r\n\r\n        const contractsEval = {isFulfilled, failingContracts};\r\n        trace({[CONTRACTS_EVAL]: contractsEval})\r\n\r\n        return contractsEval\r\n    }\r\n}\r\n\r\nexport const fsmContractChecker = (fsmDef, settings, fsmContracts) => makeContractHandler(fsmContracts, settings)(fsmDef, settings);\r\n\r\n// Terminology\r\n// . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`\r\n// For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,\r\n// guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition\r\n// uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be\r\n// referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.\r\n// . We write A < B if A is a substate of B, with the implication that B is hence a compound state\r\n// . We write A !< B if A is a direct substate of B\r\n// . We write A. !< B if A is a substate of B, and A is also an atomic state\r\n// . We write A -ev-> B to denote a transition from A to B triggered by `ev`\r\n\r\n// Behaviour\r\n// B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly\r\n// returning to the same state)\r\n// ENFORCED by T13, T4, T10, necessary for generative testing\r\n// B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress\r\n// the state machine.\r\n// NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird\r\n// ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice\r\n// B8. It is possible to reach any states\r\n// NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal\r\n","import {\r\n  ACTION_IDENTITY,\r\n  AUTO_EVENT, DEBUG_MSG,\r\n  DEEP,\r\n  ERROR_MSG,\r\n  history_symbol,\r\n  INIT_EVENT, INIT_INPUT_MSG,\r\n  INIT_STATE, INPUT_MSG, INTERNAL_INPUT_MSG, INTERNAL_OUTPUTS_MSG, MACHINE_CREATION_ERROR_MSG,\r\n  OUTPUTS_MSG,\r\n  SHALLOW,\r\n  STATE_PROTOTYPE_NAME,\r\n  WARN_MSG\r\n} from \"./properties\";\r\nimport {\r\n  arrayizeOutput,\r\n  assert,\r\n  computeHistoryMaps,\r\n  destructureEvent,\r\n  emptyConsole,\r\n  emptyTracer,\r\n  findInitTransition,\r\n  get_fn_name,\r\n  getFsmStateList,\r\n  initHistoryDataStructure,\r\n  isActions,\r\n  isEventStruct,\r\n  isHistoryControlState,\r\n  keys, KinglyError,\r\n  updateHistory,\r\n  wrap\r\n} from \"./helpers\";\r\nimport {fsmContractChecker} from \"./contracts\"\r\n\r\nfunction alwaysTrue() {\r\n  return true\r\n};\r\n\r\n/**\r\n * Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state` : {Object<String,Boolean>} Hash whose properties (state names) are matched with\r\n * whether that state is a nested state\r\n * `hash_states` : Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hash_states: {}, is_group_state: {}}}\r\n */\r\nfunction build_nested_state_structure(states) {\r\n  const root_name = \"State\";\r\n  let hash_states = {};\r\n  let is_group_state = {};\r\n\r\n  // Add the starting state\r\n  states = {nok: states};\r\n\r\n  ////////\r\n  // Helper functions\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hash_states[state_name] = new curr_constructor();\r\n      hash_states[state_name].name = state_name;\r\n      const parent_name = (hash_states[state_name].parent_name = get_fn_name(\r\n        curr_constructor\r\n      ));\r\n      hash_states[state_name].root_name = root_name;\r\n\r\n      if (typeof state_config === \"object\") {\r\n        is_group_state[state_name] = true;\r\n        const curr_constructor_new = function () {\r\n        };\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hash_states[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    });\r\n  }\r\n\r\n  function State() {\r\n  }\r\n\r\n  State.prototype = {\r\n    current_state_name: INIT_STATE\r\n  };\r\n\r\n  hash_states[INIT_STATE] = new State();\r\n  hash_states[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hash_states: hash_states,\r\n    is_group_state: is_group_state\r\n  };\r\n}\r\n\r\nexport function normalizeTransitions(fsmDef) {\r\n  const {initialControlState, transitions} = fsmDef;\r\n  const initTransition = findInitTransition(transitions);\r\n\r\n  if (initialControlState) {\r\n    return transitions\r\n      .concat([{from: INIT_STATE, event: INIT_EVENT, to: initialControlState, action: ACTION_IDENTITY}])\r\n  }\r\n  else if (initTransition) {\r\n    return transitions\r\n  }\r\n}\r\n\r\n// Alias for compatibility before deprecating entirely create_state_machine\r\n// TODO: this is not used anymore apparently so remove\r\nexport function create_state_machine(fsmDef, settings) {\r\n  return createStateMachine(fsmDef, settings)\r\n}\r\n\r\n/**\r\n * Creates an instance of state machine from a set of states, transitions, and accepted events. The initial\r\n * extended state for the machine is included in the machine definition.\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @return {function(*=)}\r\n */\r\nexport function createStateMachine(fsmDef, settings) {\r\n  const {\r\n    states: control_states,\r\n    events,\r\n    // transitions ,\r\n    initialExtendedState,\r\n    updateState: userProvidedUpdateStateFn,\r\n  } = fsmDef;\r\n  const {debug, devTool, displayName} = settings || {};\r\n  const checkContracts = debug && debug.checkContracts || void 0;\r\n  let console = debug && debug.console || emptyConsole;\r\n  let tracer = devTool && devTool.tracer || emptyTracer;\r\n  const throwKinglyError = obj => {\r\n    throw new KinglyError(obj, console, tracer)\r\n  };\r\n\r\n  // Conracts must be checked before we start doing all sort of computations\r\n  if (checkContracts) {\r\n    const {failingContracts} = fsmContractChecker(fsmDef, settings, checkContracts);\r\n    try {\r\n      if (failingContracts.length > 0) throwKinglyError({\r\n        when: `Attempting to create a Kingly machine`,\r\n        location: `createStateMachine`,\r\n        info: {fsmDef, settings, failingContracts},\r\n        message: `I found that one or more Kingly contracts are violated!`\r\n      })\r\n    }\r\n    catch (e) {\r\n      // Do not break the program, errors should be passed to console and dev tool\r\n      tracer({\r\n        type: MACHINE_CREATION_ERROR_MSG,\r\n        trace: {\r\n          info: e.errors,\r\n          message: e.message,\r\n          machineState: {cs: INIT_STATE, es: extendedState, hs: history}\r\n        }\r\n      });\r\n      return e\r\n    }\r\n  }\r\n\r\n  const wrappedUpdateState = (extendedState, updates) => {\r\n    const fnName = userProvidedUpdateStateFn.name || userProvidedUpdateStateFn.displayName || \"\";\r\n\r\n    try {\r\n      return userProvidedUpdateStateFn(extendedState, updates)\r\n    }\r\n    catch (e) {\r\n      throwKinglyError({\r\n        when: `Executing updateState function ${fnName}`,\r\n        location: `createStateMachine > wrappedUpdateState`,\r\n        info: {extendedState, updates},\r\n        message: e.message,\r\n        stack: e.stack,\r\n      })\r\n    }\r\n  };\r\n  const transitions = normalizeTransitions(fsmDef);\r\n\r\n  // Create the nested hierarchy\r\n  const hash_states_struct = build_nested_state_structure(control_states);\r\n\r\n  // This will be the extended state object which will be updated by all actions and on which conditions\r\n  // will be evaluated It is safely contained in a closure so it cannot be accessed in any way\r\n  // outside the state machine.\r\n  // Note the extended state is modified by the `settings.updateState` function, which should not modify\r\n  // the extended state object. There is hence no need to do any cloning.\r\n  let extendedState = initialExtendedState;\r\n\r\n  // history maps\r\n  const {stateList, stateAncestors} = computeHistoryMaps(control_states);\r\n  let history = initHistoryDataStructure(stateList);\r\n\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has a init transition defined\r\n  let is_init_state = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined\r\n  // that would be init transitions + eventless transitions\r\n  let is_auto_state = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state is a group of state or not\r\n  const is_group_state = hash_states_struct.is_group_state;\r\n  let hash_states = hash_states_struct.hash_states;\r\n\r\n  function assertContract(contract, arrayParams) {\r\n    const hasFailed = assert(contract, arrayParams);\r\n    if (checkContracts && hasFailed) {\r\n      throwKinglyError(hasFailed)\r\n    }\r\n\r\n    return void 0\r\n  }\r\n\r\n  function getCurrentControlState() {\r\n    return hash_states[INIT_STATE].current_state_name\r\n  }\r\n\r\n  function send_event(event_struct, isExternalEvent) {\r\n    // TODO: maybe open a console.group and close it on return\r\n    assertContract(isEventStruct, [event_struct]);\r\n\r\n    const {eventName, eventData} = destructureEvent(event_struct);\r\n    const current_state = getCurrentControlState();\r\n\r\n    console.debug(\"send event\", event_struct);\r\n\r\n    // Edge case : INIT_EVENT sent and the current state is not the initial state\r\n    // We have to do this separately, as by construction the INIT_STATE is a\r\n    // super state of all states in the machine. Hence sending an INIT_EVENT\r\n    // would always execute the INIT transition by prototypal delegation\r\n    if (isExternalEvent && eventName === INIT_EVENT && current_state !== INIT_STATE) {\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: {eventName, eventData},\r\n          message: `The external event INIT_EVENT can only be sent when starting the machine!`,\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n      console.warn(`The external event INIT_EVENT can only be sent when starting the machine!`)\r\n\r\n      return null\r\n    }\r\n\r\n    const outputs = process_event(\r\n      hash_states_struct.hash_states,\r\n      eventName,\r\n\r\n      eventData,\r\n      extendedState\r\n    );\r\n\r\n    return outputs\r\n  }\r\n\r\n  function process_event(hash_states, event, event_data, extendedState) {\r\n    const current_state = hash_states[INIT_STATE].current_state_name;\r\n    const event_handler = hash_states[current_state][event];\r\n\r\n    if (event_handler) {\r\n      // CASE : There is a transition associated to that event\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event, event_data);\r\n      /* OUT : this event handler modifies the extendedState and possibly other data structures */\r\n      const {stop, outputs: rawOutputs} = event_handler(extendedState, event_data, current_state);\r\n      debug && !stop && console.warn(\"No guards have been fulfilled! We recommend to configure guards explicitly to\" +\r\n        \" cover the full state space!\")\r\n      const outputs = arrayizeOutput(rawOutputs);\r\n\r\n      // we read it anew as the execution of the event handler may have changed it\r\n      const new_current_state = hash_states[INIT_STATE].current_state_name;\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the current state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1: init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case event_data will carry on the data passed on from the last event (else we loose\r\n      // the extendedState?)\r\n      // 2. transitions with no events associated, only conditions (i.e. transient states)\r\n      // NOTE : the guard is to defend against loops occuring when an AUTO transition fails to advance and stays\r\n      // in the same control state!! But by contract that should never happen : all AUTO transitions should advance!\r\n      // TODO : test that case, what is happening? I should add a branch and throw!!\r\n      if (is_auto_state[new_current_state] && new_current_state !== current_state) {\r\n        // CASE : transient state with no triggering event, just conditions\r\n        // automatic transitions = transitions without events\r\n        const auto_event = is_init_state[new_current_state]\r\n          ? INIT_EVENT\r\n          : AUTO_EVENT;\r\n\r\n        tracer({\r\n          type: INTERNAL_INPUT_MSG,\r\n          trace: {\r\n            info: {eventName: auto_event, eventData: event_data},\r\n            event: {[auto_event]: event_data},\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        const nextOutputs = send_event({[auto_event]: event_data}, false);\r\n\r\n        tracer({\r\n          type: INTERNAL_OUTPUTS_MSG,\r\n          trace: {\r\n            outputs: nextOutputs,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        return [].concat(outputs).concat(nextOutputs);\r\n      } else return outputs;\r\n    } else {\r\n      // CASE : There is no transition associated to that event from that state\r\n      console.warn(`There is no transition associated to the event |${event}| in state |${current_state}|!`);\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: {received: {[event]: event_data}},\r\n          message: `There is no transition associated to the event |${event}| in state |${current_state}|!`,\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  function leave_state(from, extendedState, hash_states) {\r\n    // NOTE : extendedState is passed as a parameter for symetry reasons, no real use for it so far\r\n    const state_from = hash_states[from];\r\n    const state_from_name = state_from.name;\r\n\r\n    history = updateHistory(history, stateAncestors, state_from_name);\r\n\r\n    console.info(\"left state\", wrap(from));\r\n  }\r\n\r\n  function enter_next_state(to, updatedExtendedState, hash_states) {\r\n    let state_to;\r\n    let state_to_name;\r\n    // CASE : history state (H)\r\n    if (isHistoryControlState(to)) {\r\n      const history_type = to.deep ? DEEP : to.shallow ? SHALLOW : void 0;\r\n      const history_target = to[history_type];\r\n      // Edge case : history state (H) && no history (i.e. first time state is entered), target state\r\n      // is the entered state\r\n      // TODO: edge case should be init state for compound state, and check it is recursively descended,\r\n      // and error if the history target is an atomic state\r\n      // if (!is_auto_state(history_target)) throw `can't be atomic state`\r\n      // then by setting the compound state, it should evolve toward to init control state naturally\r\n      debug && console && !is_init_state[history_target] && console.error(`Configured a history state which does not relate to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration`);\r\n      state_to_name = history[history_type][history_target] || history_target;\r\n      state_to = hash_states[state_to_name];\r\n    }\r\n    else if (to) {\r\n      // CASE : normal state\r\n      state_to = hash_states[to];\r\n      state_to_name = state_to.name;\r\n    } else {\r\n      throwKinglyError (\"enter_state : unknown case! Not a state name, and not a history state to enter!\");\r\n    }\r\n    hash_states[INIT_STATE].current_state_name = state_to_name;\r\n\r\n    tracer({\r\n      type: DEBUG_MSG,\r\n      trace: {\r\n        message: isHistoryControlState(to)\r\n          ? `Entering history state for ${to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]}`\r\n          : `Entering state ${to}`,\r\n        machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n      }\r\n    });\r\n    debug && console.info(\"AND TRANSITION TO STATE\", state_to_name);\r\n    return state_to_name;\r\n  }\r\n\r\n  function start() {\r\n    tracer({\r\n      type: INIT_INPUT_MSG,\r\n      trace: {\r\n        info: {eventName: INIT_EVENT, eventData: initialExtendedState},\r\n        event: {[INIT_EVENT]: initialExtendedState},\r\n        machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n      }\r\n    });\r\n\r\n    return send_event({[INIT_EVENT]: initialExtendedState}, true);\r\n  }\r\n\r\n  transitions.forEach(function (transition) {\r\n    let {from, to, action, event, guards: arr_predicate} = transition;\r\n    // CASE : ZERO OR ONE condition set\r\n    if (!arr_predicate)\r\n      arr_predicate = [{predicate: void 0, to: to, action: action}];\r\n\r\n    // CASE : transition has a init event\r\n    // NOTE : there should ever only be one, but we don't enforce it here\r\n    if (event === INIT_EVENT) {\r\n      is_init_state[from] = true;\r\n    }\r\n\r\n    let from_proto = hash_states[from];\r\n\r\n    // CASE : automatic transitions : no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      is_auto_state[from] = true;\r\n    }\r\n    // CASE : automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (is_group_state[from] && is_init_state[from]) {\r\n      is_auto_state[from] = true;\r\n    }\r\n\r\n    // TODO : this seriously needs refactoring, that is one line in ramda\r\n    from_proto[event] = arr_predicate.reduce((acc, guard, index) => {\r\n        const action = guard.action || ACTION_IDENTITY;\r\n        const actionName = action.name || action.displayName || \"\";\r\n        const condition_checking_fn = (function (guard, settings) {\r\n          let condition_suffix = \"\";\r\n          // We add the `current_state` because the current control state might be different from\r\n          // the `from` field here This is the case for instance when we are in a substate, but\r\n          // through prototypal inheritance it is the handler of the prototype which is called\r\n          const condition_checking_fn = function (extendedState_, event_data, current_state) {\r\n            from = current_state || from;\r\n            const predicate = guard.predicate || alwaysTrue;\r\n            const predicateName = predicate.name || predicate.displayName || \"<anonymous>\";\r\n            const to = guard.to;\r\n            const shouldTransitionBeTaken = ((extendedState, event_data, settings) => {\r\n              try {\r\n                return predicate(extendedState, event_data, settings);\r\n              }\r\n              catch (e) {\r\n                throwKinglyError({\r\n                  when: `Executing predicate function ${predicateName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken`,\r\n                  info: {extendedState, event, event_data, settings, guard, from, to, index},\r\n                  message: [`Error occurred while processing event ${event} with target state ${to}`, e.message].join(\"\\n\"),\r\n                  stack: e.stack,\r\n                })\r\n              }\r\n            })(extendedState_, event_data, settings);\r\n\r\n            if (typeof shouldTransitionBeTaken !== \"boolean\") {\r\n              throwKinglyError({\r\n                when: `Executing predicate function ${predicateName}`,\r\n                location: `createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult`,\r\n                info: {event, guard, from, to, index, shouldTransitionBeTaken},\r\n                message: `Guard index ${index} with name ${predicateName} did not return a boolean!`,\r\n              })\r\n            }\r\n\r\n            if (shouldTransitionBeTaken) {\r\n              // CASE : guard for transition is fulfilled so we can execute the actions...\r\n              console.info(\"IN STATE \", from);\r\n              if (guard.predicate) {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `The guard ${predicateName} is fulfilled`,\r\n                    info: {eventData: event_data, from, action: actionName, to},\r\n                    machineState: {cs: current_state, es: extendedState_, hs: history}\r\n                  }\r\n                });\r\n                console.info(`CASE: guard ${predicate.name} for transition is fulfilled`);\r\n              }\r\n              else {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `Evaluating transition with no guards`,\r\n                    info: {eventData: event_data, from, action: actionName, to},\r\n                    machineState: {cs: current_state, es: extendedState, hs: history}\r\n                  }\r\n                });\r\n                console.info(`CASE: unguarded transition`);\r\n              }\r\n\r\n              console.info(\"THEN : we execute the action \" + actionName);\r\n              const actionResult = ((extendedState, eventData, settings) => {\r\n                try {\r\n                  return action(extendedState, eventData, settings);\r\n                }\r\n                catch (e) {\r\n                  throwKinglyError({\r\n                    when: `Executing action factory ${actionName}`,\r\n                    location: `createStateMachine > event handler > condition_checking_fn`,\r\n                    info: {extendedState, event, event_data, settings, guard, from, to, index, action},\r\n                    message: e.message,\r\n                    stack: e.stack,\r\n                  })\r\n                }\r\n              })(extendedState_, event_data, settings);\r\n\r\n              if (!isActions(actionResult)) {\r\n                throwKinglyError({\r\n                  when: `Executing action factory ${actionName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn`,\r\n                  info: {extendedState, event, event_data, settings, guard, from, to, index, action, actionResult},\r\n                  message: `Action factory returned a value that does not have the expected shape!`,\r\n                })\r\n              }\r\n\r\n              const {updates, outputs} = actionResult;\r\n\r\n              // Leave the current state\r\n              leave_state(from, extendedState_, hash_states);\r\n\r\n              // Update the extendedState before entering the next state\r\n              extendedState = wrappedUpdateState(extendedState_, updates);\r\n\r\n              // ...and enter the next state (can be different from `to` if we have nesting state group)\r\n              const next_state = enter_next_state(to, updates, hash_states);\r\n              console.info(\"ENTERING NEXT STATE: \", next_state);\r\n              console.info(\"with extended state: \", extendedState);\r\n\r\n              // allows for chaining and stop chaining guard\r\n              return {stop: true, outputs};\r\n            }\r\n            else {\r\n              // CASE : guard for transition is not fulfilled\r\n              tracer({\r\n                type: DEBUG_MSG,\r\n                trace: {\r\n                  message: guard.predicate ? `The guard ${predicateName} is not fulfilled!` : `Evaluated and skipped transition`,\r\n                  info: {eventData: event_data, settings, guard, from, to, index, action: actionName},\r\n                  machineState: {cs: current_state, es: extendedState, hs: history}\r\n                }\r\n              });\r\n              return {stop: false, outputs: null};\r\n            }\r\n          };\r\n          // TODO: remove that, I don't need that anymore\r\n          condition_checking_fn.displayName = from + condition_suffix;\r\n          return condition_checking_fn;\r\n        })(guard, settings);\r\n\r\n        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {\r\n          const condition_checked = acc(extendedState_, event_data, current_state);\r\n          return condition_checked.stop\r\n            ? condition_checked\r\n            : condition_checking_fn(extendedState_, event_data, current_state);\r\n        };\r\n      },\r\n      function dummy() {\r\n        return {stop: false, outputs: null};\r\n      }\r\n    );\r\n  });\r\n\r\n  // TODO: think if rethrow errors we are not responsible for here too\r\n  try {\r\n    start();\r\n  }\r\n  catch (e) {\r\n    // Do not break the program, errors should be passed to console and dev tool\r\n    tracer({\r\n      type: MACHINE_CREATION_ERROR_MSG,\r\n      trace: {\r\n        message: e.message,\r\n        info: {fsmDef, settings, error: e},\r\n        machineState: {cs: INIT_STATE, es: extendedState, hs: history}\r\n      }\r\n    });\r\n    return e\r\n  }\r\n\r\n  // NOTE : yield is a reserved JavaScript word so using yyield\r\n  return function yyield(x) {\r\n    try {\r\n      const {eventName, eventData} = destructureEvent(x);\r\n      const current_state = getCurrentControlState();\r\n\r\n      tracer({\r\n        type: INPUT_MSG,\r\n        trace: {\r\n          info: {eventName, eventData},\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      const outputs = send_event(x, true);\r\n\r\n      debug && console.info(\"OUTPUTS:\", outputs);\r\n      tracer({\r\n        type: OUTPUTS_MSG,\r\n        trace: {\r\n          outputs,\r\n          machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      return outputs\r\n    }\r\n    catch (e) {\r\n      if (e instanceof KinglyError) {\r\n        // We don't break the program, but we can't continue as nothing happened: we return the error\r\n        tracer({\r\n          type: ERROR_MSG,\r\n          trace: {\r\n            error: e,\r\n            message: `An error ocurred while running an input through the machine!`,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        return e\r\n      }\r\n      else {\r\n        tracer({\r\n          type: ERROR_MSG,\r\n          trace: {\r\n            error: e,\r\n            message: `An unknown error ocurred while running an input through the machine!`,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n        console.error(`yyield > unexpected error!`, e);\r\n        // We should only catch the errors we are responsible for!\r\n        throw e\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {WebComponentName} name name for the web component. Must include at least one hyphen per custom\r\n * components' specification\r\n * @param {Subject} eventHandler A factory function which returns a subject, i.e. an object which\r\n * implements the `Observer` and `Observable` interface\r\n * @param {FSM} fsm An executable machine, i.e. a function which accepts machine inputs\r\n * @param {Object.<CommandName, CommandHandler>} commandHandlers\r\n * @param {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an effect moniker to a function performing the corresponding effect.\r\n * @param {{initialEvent, terminalEvent, NO_ACTION}} options\r\n */\r\nexport function makeWebComponentFromFsm({name, eventHandler, fsm, commandHandlers, effectHandlers, options}) {\r\n  class FsmComponent extends HTMLElement {\r\n    constructor() {\r\n      if (name.split('-').length <= 1) throw `makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!`\r\n      super();\r\n      const el = this;\r\n      this.eventSubject = eventHandler;\r\n      this.options = Object.assign({}, options);\r\n      const NO_ACTION = this.options.NO_ACTION || null;\r\n\r\n      // Set up execution of commands\r\n      this.eventSubject.subscribe({\r\n        next: eventStruct => {\r\n          const actions = fsm(eventStruct);\r\n\r\n          if (actions === NO_ACTION) return;\r\n          actions.forEach(action => {\r\n            if (action === NO_ACTION) return;\r\n            const {command, params} = action;\r\n            commandHandlers[command](this.eventSubject.next, params, effectHandlers, el);\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      return [];\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);\r\n      this.eventSubject.complete();\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      // simulate a new creation every time an attribute is changed\r\n      // i.e. they are not expected to change\r\n      this.constructor();\r\n      this.connectedCallback();\r\n    }\r\n  }\r\n\r\n  return customElements.define(name, FsmComponent);\r\n}\r\n\r\n/**\r\n * This function works to merge outputs by simple concatenation and flattening\r\n * Every action return T or [T], and we want in output [T] always\r\n * mergeOutputsFn([a, [b]) = mergeOutputsFn([a,b]) = mergeOutputsFn([[a],b) = mergeOutputsFn([[a],[b]]) = [a,b]\r\n * If we wanted to pass [a] as value we would have to do mergeOutputsFn([[[a]],[b]]) to get [[a],b]\r\n * @param arrayOutputs\r\n * @returns {*}\r\n */\r\nexport function mergeOutputsFn(arrayOutputs) {\r\n  // NOTE : here, this array of outputs could be array x non-array ^n\r\n  // The algorithm is to concat all elements\r\n  return arrayOutputs.reduce((acc, element) => acc.concat(element), [])\r\n}\r\n\r\n/**\r\n * Construct history states `hs` from a list of states for a given state machine. The history states for a given control\r\n * state can then be referenced as follows :\r\n * - `hs.shallow(state)` will be the shallow history state associated to the `state`\r\n * - `hs.deep(state)` will be the deep history state associated to the `state`\r\n * @param {FSM_States} states\r\n * @return {HistoryStateFactory}\r\n */\r\nexport function makeHistoryStates(states) {\r\n  const stateList = Object.keys(getFsmStateList(states));\r\n  // used for referential equality comparison to discriminate history type\r\n\r\n  return (historyType, controlState) => {\r\n    if (!stateList.includes(controlState)) {\r\n      throw `makeHistoryStates: the state for which a history state must be constructed is not a configured state for the state machine under implementation!!`\r\n    }\r\n\r\n    return {\r\n      [historyType]: controlState,\r\n      type: history_symbol\r\n    }\r\n  }\r\n}\r\n\r\nexport function historyState(historyType, controlState) {\r\n  return {\r\n    [historyType]: controlState\r\n  }\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INIT_STATE, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  getDisplayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${getDisplayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {ControlState} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INIT_STATE) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n","// TODO : export only the three functions part of the API! might require updating tests imports\r\n// - move the converter to yed2kingly or a new single script with options (convert to knogly, to uml, etc.)\r\nexport * from './types'\r\nexport * from './synchronous_fsm'\r\nexport * from './converter'\r\nexport * from './properties'\r\nexport * from './helpers'\r\nexport {fsmContracts} from './contracts'\r\n"],"names":["CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE","SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INIT_STATE","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_STATE_UPDATE","NO_OUTPUT","ACTION_IDENTITY","outputs","updates","history_symbol","SHALLOW","DEEP","WRONG_EVENT_FORMAT_ERROR","FUNCTION_THREW_ERROR","fnName","type","INVALID_ACTION_FACTORY_EXECUTED","actionName","INVALID_PREDICATE_EXECUTED","ACTION_FACTORY_DESC","ENTRY_ACTION_FACTORY_DESC","UPDATE_STATE_FN_DESC","PREDICATE_DESC","COMMAND_RENDER","CONTRACTS_EVAL","OUTPUTS_MSG","INPUT_MSG","WARN_MSG","MACHINE_CREATION_ERROR_MSG","ERROR_MSG","INTERNAL_INPUT_MSG","INTERNAL_OUTPUTS_MSG","DEBUG_MSG","INIT_INPUT_MSG","noop","emptyConsole","log","warn","info","debug","error","trace","emptyTracer","isBoolean","x","isFunction","isControlState","isHistoryControlState","isEvent","isActionFactory","make_states","stateList","reduce","acc","state","make_events","eventList","get_fn_name","fn","tokens","exec","toString","wrap","str","join","times","n","Array","apply","length","map","Number","call","always","keys","obj","Object","merge","a","b","assign","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","from","is_to_history_control_state_of","is_history_control_state_of","substring","format_transition_label","_event","predicate","action","name","format_history_transition_state_name","get_all_transitions","guards","getDisplayName","replace","mergeModelUpdates","arrayUpdateActions","extendedState","eventData","settings","updateAction","update","concat","chainModelUpdates","updateState","updatedState","mergeActionFactories","mergeOutputFn","arrayActionFactory","arrayActions","factory","arrayStateUpdates","arrayOutputs","identity","lastOf","arr","formatActionName","predicateName","formattedPredicate","formattedAction","getFsmStateList","states","getLabel","objectTreeLenses","traverse","strategy","PRE_ORDER","seed","visit","accStateList","traversalState","tree","treeLabel","stateHashMap","traverseObj","getStatesType","statesTree","isLeafLabel","getStatesPath","pathStr","get","path","getStatesTransitionsMap","transitions","getStateEventTransitionsMaps","getEventTransitionsMaps","getHistoryStatesMap","reduceTransitions","flatTransition","guardIndex","transitionIndex","gen","underlyingControlState","getHistoryUnderlyingState","set","Map","getTargetStatesMap","getAncestorMap","getChildren","children","childrenControlStates","forEach","computeHistoryMaps","control_states","stateAncestors","JSON","stringify","parentPath","slice","parentControlState","_","ancestors","mapOverTransitionsActions","mapFn","mappedAction","displayName","push","reduceFn","result","transitionStruct","undefined","guard","everyTransition","pred","computeTimesCircledOn","edgePath","edge","edgeInEdgePath","isInitState","s","isInitEvent","e","isEventless","arrayizeOutput","output","isArray","getHistoryParentState","isShallowHistory","isDeepHistory","getHistoryType","history","isHistoryStateEdge","initHistoryDataStructure","initHistory","isCompoundState","analyzedStates","statesAdjacencyList","isAtomicState","updateHistory","state_from_name","oldAncestor","newAncestor","computeHistoryState","controlStateSequence","historyType","historyParentState","findInitTransition","find","tryCatch","errCb","args","tryCatchMachineFn","fnType","argsDesc","err","Error","getFunctionName","probableCause","params","argDesc","index","actionFactory","assert","contract","arrayParams","contractName","isFulfilledOrError","when","message","notifyThrows","console","handleFnExecError","notify","execInfo","actionResultOrError","postCondition","throwFn","invalidResultFn","notifyAndRethrow","throwIfInvalidActionResult","updatedExtendedState","returned","throwIfInvalidGuardResult","resultOrError","predName","throwIfInvalidEntryActionResult","exitActionResultOrError","isActions","isEventStruct","trueOrError","cause","isError","destructureEvent","eventName","formatUndefinedInJSON","key","value","KinglyError","m","tracer","stack","errors","location","fm","infoMsg","fullMsg","noDuplicatedStates","shouldThrow","fsmDef","duplicatedStates","statesHashMap","isFulfilled","blame","noReservedStates","statesType","indexOf","reservedStates","atLeastOneState","isInitialControlStateDeclared","initTransition","initialControlState","declaredStates","eventsAreStrings","events","every","validInitialConfig","validInitialTransition","initTransitions","isInconditionalTransition","areCconditionalTransitions","initEventOnlyInCompoundStates","statesTransitionsMap","statesPath","atomicStates","filter","atomicInitTransitions","atomicState","values","hasInitEventOnlyInCompoundStates","validInitialTransitionForCompoundState","compoundStates","compoundStatesInitTransitions","compoundState","allHaveInitTransitions","Boolean","hasEntryTransitions","allHaveValidInitTransitions","targetStates","targetState","entryTransitions","allHaveTargetStatesWithinHierarchy","validEventLessTransitions","failingOriginControlStates","allStateTransitionsOnOneSingleRow","stateEventTransitionsMaps","originStateList","statesTransitionsInfo","wrongEventConfig","noConflictingTransitionsWithAncestorState","eventTransitionsMaps","ancestorMap","ev","eventTransitionsInfo","wrongStateConfig","ancestorState","isHistoryStatesTargetStates","wrongHistoryStates","isHistoryStatesCompoundStates","originState","isHistoryStatesExisting","historyStatesMap","invalidTransitions","entries","historyState","flatTransitions","howMany","isValidGuard","isValidFsmDef","initialExtendedState","isValidTransitions","isValidStates","isValidEvents","haveTransitionsValidTypes","wrongTransitions","areEventsDeclared","declaredEventList","eventsDeclaredButNotTriggeringTransitions","declaredEvent","eventsNotDeclaredButTriggeringTransitions","triggeringEvent","areStatesDeclared","targetStatesMap","targetStateList","declaredStateList","statesDeclaredButNotTriggeringTransitions","declaredState","statesNotDeclaredButTriggeringTransitions","stateInTransition","isValidSettings","isInitialStateOriginState","isValidSelfTransition","wrongSelfTransitions","fsmContracts","injected","description","contracts","makeContractHandler","contractsDef","contractsDescription","checkContracts","failingContracts","computedArgs","fullArgs","blameMessageHeader","contractsEval","fsmContractChecker","alwaysTrue","build_nested_state_structure","root_name","hash_states","is_group_state","nok","build_state_reducer","curr_constructor","state_name","state_config","parent_name","curr_constructor_new","prototype","State","current_state_name","normalizeTransitions","create_state_machine","createStateMachine","userProvidedUpdateStateFn","devTool","throwKinglyError","machineState","cs","es","hs","wrappedUpdateState","hash_states_struct","is_init_state","is_auto_state","assertContract","hasFailed","getCurrentControlState","send_event","event_struct","isExternalEvent","current_state","process_event","event_data","event_handler","stop","rawOutputs","new_current_state","auto_event","nextOutputs","received","leave_state","state_from","enter_next_state","state_to","state_to_name","history_type","deep","shallow","history_target","start","arr_predicate","from_proto","condition_checking_fn","condition_suffix","extendedState_","shouldTransitionBeTaken","actionResult","next_state","arr_predicate_reduce_fn","condition_checked","dummy","yyield","makeWebComponentFromFsm","eventHandler","fsm","commandHandlers","effectHandlers","options","FsmComponent","split","el","eventSubject","NO_ACTION","subscribe","next","eventStruct","actions","command","initialEvent","terminalEvent","complete","oldValue","newValue","constructor","connectedCallback","HTMLElement","customElements","define","mergeOutputsFn","element","makeHistoryStates","includes","generateStatePlantUmlHeader","optDisplayName","toPlantUml","constructTree","getChildrenNumber","pathMap","childrenTranslation","translation","stateToPlantUML","translationMap","postOrderTraverseTree","mappedTree","clear","format_history_states","format_entry_transitions","translate_transitions","historyStatesObj","accTranslation","allTransitions","historyStates","historyTransitionTranslation","format_history_transitions","standardTransitionTranslation","format_standard_transitions","toDagreVisualizerFormat","arrayTreeLenses","_translatedStates","translatedStates","translatedTransitions","translatedGuards"],"mappings":"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"}