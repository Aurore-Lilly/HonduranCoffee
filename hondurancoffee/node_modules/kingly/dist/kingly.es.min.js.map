{"version":3,"file":"kingly.es.min.js","sources":["../src/properties.js","../node_modules/fp-rosetree/index.js","../src/helpers.js","../src/contracts.js","../src/synchronous_fsm.js","../src/converter.js"],"sourcesContent":["export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INIT_STATE = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_STATE_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = [];\r\nexport const ACTION_IDENTITY = function ACTION_IDENTITY(){\r\n  return {\r\n    outputs : NO_OUTPUT,\r\n    updates : NO_STATE_UPDATE\r\n  }\r\n}\r\nexport const history_symbol = {};\r\nexport const SHALLOW = 'shallow';\r\nexport const DEEP = 'deep';\r\n\r\nexport const WRONG_EVENT_FORMAT_ERROR = `The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.`\r\nexport const FUNCTION_THREW_ERROR = (fnName, type) => `Exception thrown when executing ${type} ${fnName||\"\"}`\r\nexport const INVALID_ACTION_FACTORY_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not an action.`\r\nexport const INVALID_PREDICATE_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not a boolean.`\r\nexport const ACTION_FACTORY_DESC = `action factory`\r\nexport const ENTRY_ACTION_FACTORY_DESC = `(decorating) entry action`\r\nexport const UPDATE_STATE_FN_DESC = `update state function`\r\nexport const PREDICATE_DESC = `predicate`\r\n\r\nexport const COMMAND_RENDER = 'render'\r\n\r\nexport const CONTRACTS_EVAL = \"CONTRACTS_EVAL\";\r\n\r\nexport const OUTPUTS_MSG = \"OUTPUTS_MSG\";\r\nexport const INPUT_MSG = \"INPUT_MSG\";\r\nexport const WARN_MSG = 'WARN_MSG';\r\nexport const MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';\r\nexport const ERROR_MSG = 'ERROR_MSG';\r\nexport const INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';\r\nexport const INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';\r\nexport const DEBUG_MSG = 'DEBUG_MSG';\r\nexport const INIT_INPUT_MSG = 'INIT_INPUT_MSG';\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","// Ramda fns\r\nimport {\r\n  ACTION_FACTORY_DESC, DEEP, ENTRY_ACTION_FACTORY_DESC, FUNCTION_THREW_ERROR, HISTORY_PREFIX, HISTORY_STATE_NAME,\r\n  INIT_EVENT, INIT_STATE, INVALID_ACTION_FACTORY_EXECUTED, INVALID_PREDICATE_EXECUTED, NO_OUTPUT,\r\n  PREDICATE_DESC,\r\n  SHALLOW, WRONG_EVENT_FORMAT_ERROR\r\n} from \"./properties\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\n\r\nexport const noop = () => {\r\n};\r\nexport const emptyConsole = {log: noop, warn: noop, info: noop, debug: noop, error: noop, trace: noop};\r\nexport const emptyTracer = noop;\r\n\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\nexport function isFunction(x) {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport function isControlState(x) {\r\n  return x && typeof x === 'string' || isHistoryControlState(x)\r\n}\r\n\r\nexport function isEvent(x) {\r\n  return typeof x === 'undefined' || typeof x === 'string'\r\n}\r\n\r\nexport function isActionFactory(x) {\r\n  return x && typeof x === 'function'\r\n}\r\n\r\nexport function make_states(stateList) {\r\n  return stateList.reduce((acc, state) => {\r\n    acc[state] = \"\";\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function make_events(eventList) {\r\n  return eventList\r\n}\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) {\r\n  return ['-', str, '-'].join(\"\");\r\n}\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\nexport function always(x) {\r\n  return x\r\n}\r\n\r\nexport function keys(obj) {\r\n  return Object.keys(obj)\r\n}\r\n\r\nexport function merge(a, b) {\r\n  return Object.assign({}, a, b)\r\n}\r\n\r\n// Contracts\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({from, to}) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const {from, event, guards} = transition;\r\n\r\n  return guards\r\n    ? guards.map(({predicate, to, action}) => ({from, event, predicate, to, action}))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function getDisplayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n/**\r\n * This function MERGES extended state updates. That means that given two state updates, the resulting state update\r\n * will be the concatenation of the two, in the order in which they are passed\r\n * @param {function[]}  arrayUpdateActions\r\n * @returns {function(*=, *=, *=): {updates: *}}\r\n */\r\nexport function mergeModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    return {\r\n      updates: arrayUpdateActions.reduce((acc, updateAction) => {\r\n        const update = updateAction(extendedState, eventData, settings).updates;\r\n        if (update) {\r\n          return acc.concat(update)\r\n        }\r\n        else {\r\n          return acc\r\n        }\r\n      }, []),\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function CHAINS extended state updates, in the order in which they are passed. It is thus similar to a pipe.\r\n * The second update function receives the state updated by the first update function.\r\n * @param {function[]}  arrayUpdateActions\r\n */\r\nexport function chainModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    const {updateState} = settings;\r\n    return {\r\n      updates: arrayUpdateActions\r\n        .reduce((acc, updateAction) => {\r\n          const {extendedState, updates} = acc;\r\n          const update = updateAction(extendedState, eventData, settings).updates;\r\n          const updatedState = updateState(extendedState, updates)\r\n\r\n          return {extendedState: updatedState, updates: update}\r\n        }, {extendedState, updates: []})\r\n        .updates || [],\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {function (Array<Array<MachineOutput>>) : Array<MachineOutput>} mergeOutputFn\r\n * @param {Array<ActionFactory>} arrayActionFactory\r\n * @returns {function(*=, *=, *=): {updates: *[], outputs: *|null}}\r\n */\r\nexport function mergeActionFactories(mergeOutputFn, arrayActionFactory) {\r\n  return function (extendedState, eventData, settings) {\r\n    const arrayActions = arrayActionFactory.map(factory => factory(extendedState, eventData, settings));\r\n    const arrayStateUpdates = arrayActions.map(x => x.updates || []);\r\n    const arrayOutputs = arrayActions.map(x => x.outputs || {});\r\n\r\n    return {\r\n      updates: [].concat(...arrayStateUpdates),\r\n      // for instance, mergeFn = R.mergeAll or some variations around R.mergeDeepLeft\r\n      outputs: mergeOutputFn(arrayOutputs)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type ActionFactory*/\r\nexport function identity(extendedState, eventData, settings) {\r\n  return {\r\n    updates: [],\r\n    outputs: NO_OUTPUT\r\n  }\r\n}\r\n\r\nexport function lastOf(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction formatActionName(action, from, event, to, predicate) {\r\n  const predicateName = predicate ? predicate.name : \"\";\r\n  const formattedPredicate = predicateName ? `[${predicateName}]` : \"\";\r\n  const actionName = action ? action.name : \"identity\";\r\n  const formattedAction = actionName ? actionName : \"unnamed action\";\r\n  return `${formattedAction}:${from}-${event}->${to} ${formattedPredicate}`;\r\n}\r\n\r\nexport function getFsmStateList(states) {\r\n  const {getLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (accStateList, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      accStateList[controlState] = \"\";\r\n\r\n      return accStateList;\r\n    }\r\n  };\r\n  const stateHashMap = traverseObj(traverse, states);\r\n\r\n  return stateHashMap\r\n}\r\n\r\nexport function getStatesType(statesTree) {\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      // true iff control state is a compound state\r\n      return isLeafLabel(treeLabel)\r\n        ? (acc[controlState] = false, acc)\r\n        : (acc[controlState] = true, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesPath(statesTree) {\r\n  const {getLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const pathStr = traversalState.get(tree).path.join('.');\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      return (acc[controlState] = pathStr, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesTransitionsMap(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = transition;\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getStateEventTransitionsMaps(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getEventTransitionsMaps(transitions) {\r\n  // Map an event to the origin control states of the transitions it triggers\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[event] = acc[event] || {};\r\n      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getHistoryStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {from, event, to, action, predicate, gen} = flatTransition;\r\n      if (isHistoryControlState(from)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(from);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n      else if (isHistoryControlState(to)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(to);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getTargetStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {to} = flatTransition;\r\n      map.set(to, (map.get(to) || []).concat([flatTransition]));\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getAncestorMap(statesTree) {\r\n  const {getLabel, getChildren} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = getChildren(tree)\r\n      const childrenControlStates = children.map(tree => Object.keys(getLabel(tree))[0]);\r\n\r\n      childrenControlStates.forEach(state => {\r\n        acc[state] = acc[state] || [];\r\n        acc[state] = acc[state].concat(controlState);\r\n      });\r\n\r\n      return acc\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function computeHistoryMaps(control_states) {\r\n  if (Object.keys(control_states).length === 0) {\r\n    throw `computeHistoryMaps : passed empty control states parameter?`\r\n  }\r\n\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {stateList: [], stateAncestors: {}},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      acc.stateList = acc.stateList.concat(controlState);\r\n\r\n      // NOTE : we don't have to worry about path having only one element\r\n      // that case correspond to the root of the tree which is excluded from visiting\r\n      const {path} = traversalState.get(tree);\r\n      traversalState.set(JSON.stringify(path), controlState);\r\n      const parentPath = path.slice(0, -1);\r\n      if (parentPath.length === 1) {\r\n        // That's the root\r\n        traversalState.set(JSON.stringify(parentPath), INIT_STATE);\r\n      }\r\n      else {\r\n        const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n        acc.stateAncestors[controlState] = [parentControlState];\r\n\r\n        const {ancestors} = path.reduce((acc, _) => {\r\n          const parentPath = acc.path.slice(0, -1);\r\n          acc.path = parentPath;\r\n          if (parentPath.length > 1) {\r\n            const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n            acc.ancestors = acc.ancestors.concat(parentControlState);\r\n          }\r\n\r\n          return acc\r\n        }, {ancestors: [], path});\r\n        acc.stateAncestors[controlState] = ancestors;\r\n      }\r\n\r\n      return acc\r\n    }\r\n  };\r\n  const {stateList, stateAncestors} = traverseObj(traverse, control_states);\r\n\r\n  return {stateList, stateAncestors}\r\n}\r\n\r\nexport function mapOverTransitionsActions(mapFn, transitions) {\r\n  return reduceTransitions(function (acc, transition, guardIndex, transitionIndex) {\r\n    const {from, event, to, action, predicate} = transition;\r\n    const mappedAction = mapFn(action, transition, guardIndex, transitionIndex);\r\n    mappedAction.displayName = mappedAction.displayName || (action && (action.name || action.displayName || formatActionName(action, from, event, to, predicate)));\r\n\r\n    if (typeof(predicate) === 'undefined') {\r\n      acc.push({from, event, to, action: mappedAction})\r\n    }\r\n    else {\r\n      if (guardIndex === 0) {\r\n        acc.push({from, event, guards: [{to, predicate, action: mappedAction}]})\r\n      }\r\n      else {\r\n        acc[acc.length - 1].guards.push({to, predicate, action: mappedAction})\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, [], transitions)\r\n}\r\n\r\nexport function reduceTransitions(reduceFn, seed, transitions) {\r\n  const result = transitions.reduce((acc, transitionStruct, transitionIndex) => {\r\n    let {from, event, to, gen, action, guards} = transitionStruct;\r\n    // Edge case when no guards are defined\r\n    if (!guards) {\r\n      guards = gen ? [{to, action, gen, predicate: undefined}] : [{to, action, predicate: undefined}]\r\n    }\r\n    return guards.reduce((acc, guard, guardIndex) => {\r\n      const {to, action, gen, predicate} = guard;\r\n      return gen\r\n        ? reduceFn(acc, {from, event, to, action, predicate, gen}, guardIndex, transitionIndex)\r\n        : reduceFn(acc, {from, event, to, action, predicate}, guardIndex, transitionIndex)\r\n    }, acc);\r\n  }, seed);\r\n\r\n  return result\r\n}\r\n\r\nexport function everyTransition(pred, transition) {\r\n  return reduceTransitions((acc, flatTransition) => {\r\n    return acc && pred(flatTransition)\r\n  }, true, [transition])\r\n}\r\n\r\nexport function computeTimesCircledOn(edgePath, edge) {\r\n  return edgePath.reduce((acc, edgeInEdgePath) => edgeInEdgePath === edge ? acc + 1 : acc, 0);\r\n}\r\n\r\nexport function isInitState(s) {\r\n  return s === INIT_STATE\r\n}\r\n\r\nexport function isInitEvent(e) {\r\n  return e === INIT_EVENT\r\n}\r\n\r\nexport function isEventless(e) {\r\n  return typeof e === 'undefined'\r\n}\r\n\r\nexport function arrayizeOutput(output) {\r\n  return output === NO_OUTPUT\r\n    ? NO_OUTPUT\r\n    : Array.isArray(output)\r\n      ? output\r\n      : [output]\r\n}\r\n\r\nexport function isHistoryControlState(to) {\r\n  return typeof to === 'object' && (DEEP in to || SHALLOW in to)\r\n}\r\n\r\nexport function getHistoryParentState(to) {\r\n  return to[SHALLOW] || to[DEEP]\r\n}\r\n\r\nexport function isShallowHistory(to) {\r\n  return to[SHALLOW]\r\n}\r\n\r\nexport function isDeepHistory(to) {\r\n  return to[DEEP]\r\n}\r\n\r\nexport function getHistoryType(history) {\r\n  return history[DEEP] ? DEEP : SHALLOW\r\n}\r\n\r\nexport function getHistoryUnderlyingState(history) {\r\n  return history[getHistoryType(history)]\r\n}\r\n\r\nexport function isHistoryStateEdge(edge) {\r\n  return typeof edge.history !== 'undefined'\r\n}\r\n\r\n/**\r\n * Creates a history object from a state list. The created history object represents the history states when no\r\n * control states have been entered or exited.\r\n * @param stateList\r\n * @returns {History}\r\n */\r\nexport function initHistoryDataStructure(stateList) {\r\n  // NOTE : we update history in place, so we need two different objects here, even\r\n  // when they start with the same value\r\n  const initHistory = () => stateList.reduce((acc, state) => (acc[state] = '', acc), {});\r\n  return {[DEEP]: initHistory(), [SHALLOW]: initHistory()};\r\n}\r\n\r\nexport function isCompoundState(analyzedStates, controlState) {\r\n  const {statesAdjacencyList} = analyzedStates;\r\n  return statesAdjacencyList[controlState] && statesAdjacencyList[controlState].length !== 0\r\n}\r\n\r\nexport function isAtomicState(analyzedStates, controlState) {\r\n  return !isCompoundState(analyzedStates, controlState)\r\n}\r\n\r\n/**\r\n * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the\r\n * `stateAncestors` which are the ancestors for the exited state.\r\n * @param {History} history Contains deep history and shallow history for all\r\n * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function\r\n * `updateHistory` allows to update the history as transitions occur in the state machine.\r\n * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors\r\n * @returns {History}\r\n * @modifies history\r\n */\r\nexport function updateHistory(history, stateAncestors, state_from_name) {\r\n  // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)\r\n\r\n  if (state_from_name === INIT_STATE) {\r\n    return history\r\n  }\r\n  else {\r\n      // ancestors for the state which is exited\r\n      const ancestors = stateAncestors[state_from_name] || [];\r\n      ancestors.reduce((oldAncestor, newAncestor) => {\r\n        // set the exited state in the history of all ancestors\r\n        history[DEEP][newAncestor] = state_from_name;\r\n        history[SHALLOW][newAncestor] = oldAncestor;\r\n\r\n        return newAncestor\r\n      }, state_from_name);\r\n\r\n    return history\r\n  }\r\n}\r\n\r\n/**\r\n * for all parentState, computes history(parentState), understood as the last control state descending from the\r\n * parent state. Last can be understood two ways : DEEP and SHALLOW. Deep history state refer to the last atomic\r\n * control state which is a children of the parent state and was exited. Shallow history states refer to the last\r\n * control state which is a direct child of the parent state and was exited.\r\n * @param {FSM_States} states\r\n * @param {Array<ControlState>} controlStateSequence Sequence of control states which has been entered and exited,\r\n * and from which the history must be injected\r\n * @param {DEEP | SHALLOW} historyType\r\n * @param {ControlState} historyParentState\r\n * @returns {Object.<DEEP|SHALLOW, Object.<ControlState, ControlState>>}\r\n */\r\nexport function computeHistoryState(states, controlStateSequence, historyType, historyParentState) {\r\n  // NOTE : we compute the whole story every time. This is inefficient, but for now sufficient\r\n  const {stateList, stateAncestors} = computeHistoryMaps(states);\r\n  let history = initHistoryDataStructure(stateList);\r\n  history = controlStateSequence.reduce(\r\n    (history, controlState) => updateHistory(history, stateAncestors, controlState),\r\n    history\r\n  );\r\n\r\n  return history[historyType][historyParentState]\r\n}\r\n\r\nexport function findInitTransition(transitions) {\r\n  return transitions.find(transition => {\r\n    return transition.from === INIT_STATE && transition.event === INIT_EVENT\r\n  })\r\n}\r\n\r\nexport function tryCatch(fn, errCb) {\r\n  return function tryCatch(...args) {\r\n    try {\r\n      return fn.apply(fn, args);\r\n    }\r\n    catch (e) {\r\n      return errCb(e, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport function tryCatchMachineFn(fnType, fn, argsDesc = []) {\r\n  return tryCatch(fn, (e, args) => {\r\n    const err = new Error(e);\r\n    const fnName = getFunctionName(fn);\r\n    // NOTE : we concatenate causes but not `info`\r\n    const probableCause = FUNCTION_THREW_ERROR(fnName, fnType);\r\n    err.probableCause = e.probableCause ? [e.probableCause, probableCause].join('\\n') : probableCause;\r\n\r\n    const info = {\r\n      fnName,\r\n      params: argsDesc.reduce((acc, argDesc, index) => {\r\n        return acc[argDesc] = args[index], acc\r\n      }, {})\r\n    };\r\n    err.info = e.info ? [].concat([e.info]).concat([info]) : info;\r\n\r\n    return err\r\n  })\r\n}\r\n\r\nexport function getFunctionName(actionFactory) {\r\n  return actionFactory.name || actionFactory.displayName || 'anonymous'\r\n}\r\n\r\n/**\r\n *\r\n * @param {function: true | Error} contract Contract returns either true (fulfilled contract) or an Error with an\r\n * optional info properties to give more details about the cause of the error\r\n * @param {Array} arrayParams Parameters to be passed to the conract\r\n * @returns {undefined|{when, location, info, message, ...}} if the contract is fulfilled\r\n * @throws if the contract fails\r\n */\r\nexport function assert(contract, arrayParams) {\r\n  const contractName = contract.name ||contract.name.displayName || \"\";\r\n  const isFulfilledOrError = contract.apply(null, arrayParams);\r\n  if (isFulfilledOrError === true) return void 0\r\n  else {\r\n    return {\r\n      ...isFulfilledOrError,\r\n      when: `Checking contract`,\r\n      message: [isFulfilledOrError.message, `failed contract ${contractName}`].join(\"\\n\"),\r\n      info: isFulfilledOrError.info,\r\n    }\r\n  }\r\n}\r\n\r\nexport function notifyThrows(console, error) {\r\n  console.error(error);\r\n  error.probableCause && console.error(`Probable cause: ${error.probableCause}`);\r\n  error.info && console.error(`ERROR: additional info`, error.info);\r\n}\r\n\r\n/**\r\n * false iff no errors or invalid actions\r\n * if not throws an exception\r\n * @param {{debug, console}} notify\r\n * @param {*} execInfo Information about the call - should include the function, and the parameters for the function\r\n * call\r\n * @param {Actions | Error} actionResultOrError\r\n * @param {function} throwFn handles when the action factory throws during its execution\r\n * @param {function} invalidResultFn handles when the action factory returns invalid actions\r\n * @returns {boolean}\r\n * @param postCondition\r\n */\r\nexport function handleFnExecError(notify, execInfo, actionResultOrError, postCondition, throwFn, invalidResultFn) {\r\n  const {debug, console} = notify;\r\n\r\n  if (debug && actionResultOrError instanceof Error) {\r\n    throwFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else if (debug && !postCondition(actionResultOrError)) {\r\n    invalidResultFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else return false\r\n}\r\n\r\nexport function notifyAndRethrow({debug, console}, actionResultOrError) {\r\n  notifyThrows(console, actionResultOrError)\r\n  throw actionResultOrError\r\n}\r\n\r\nexport function throwIfInvalidActionResult({debug, console}, actionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: actionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidGuardResult({debug, console}, resultOrError, exec) {\r\n  const predName = getFunctionName(exec.predicate);\r\n  const error = new Error(INVALID_PREDICATE_EXECUTED(predName, PREDICATE_DESC));\r\n  error.info = {\r\n    predicateName: predName,\r\n    params: exec,\r\n    returned: resultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidEntryActionResult({debug, console}, exitActionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ENTRY_ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: exitActionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function isActions(obj) {\r\n  return obj && `updates` in obj && `outputs` in obj\r\n    && Array.isArray(obj.outputs)\r\n  // && Array.isArray(obj.updates)\r\n  // !! does not have to be arrays. HAs to be anything that is accepted by updateState\r\n}\r\n\r\n/**\r\n * That is a Either contract, not a Boolean contract!\r\n * @param obj\r\n * @returns {boolean|Error}\r\n */\r\nexport function isEventStruct(obj) {\r\n  let trueOrError;\r\n  if (!obj || typeof obj !== 'object') {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `not an object!`}\r\n  }\r\n  else if (Object.keys(obj).length > 1) {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `Event objects must have only one key which is the event name!`}\r\n  }\r\n  else trueOrError = true;\r\n\r\n  return trueOrError\r\n}\r\n\r\nexport function isError(obj) {\r\n  return obj instanceof Error\r\n}\r\n\r\nexport function destructureEvent(obj) {\r\n  const eventName = Object.keys(obj)[0];\r\n  const eventData = obj[eventName];\r\n\r\n  return {eventName, eventData}\r\n}\r\n\r\nexport function formatUndefinedInJSON(obj){\r\n  return JSON.stringify(obj, (key,value)=> {if (value === undefined) return \"undefined\"; else return value})\r\n}\r\n\r\nexport class KinglyError extends Error {\r\n  constructor(m, console, tracer) {\r\n    super(m && m.message || \"\");\r\n    this.name = `KinglyError`;\r\n    this.stack = m && m.stack || this.stack;\r\n    this.errors = m;\r\n    const { when, location, info, message } = m || {};\r\n    const fm = `At ${location}: ${when} => ${message}`;\r\n    const infoMsg = info ? `See extra info in console` : \"\";\r\n    const fullMsg = [fm, infoMsg].join(\"\\n\");\r\n    // this.message = fullMsg;\r\n    console && console.error(fullMsg);\r\n    info && console && console.info(info);\r\n  }\r\n}\r\n","import {\r\n    emptyConsole,\r\n    findInitTransition,\r\n    getAncestorMap,\r\n    getEventTransitionsMaps,\r\n    getHistoryStatesMap,\r\n    getHistoryUnderlyingState,\r\n    getStatesPath,\r\n    getStatesTransitionsMap,\r\n    getStateEventTransitionsMaps,\r\n    getStatesType,\r\n    getTargetStatesMap,\r\n    isActionFactory,\r\n    isControlState,\r\n    isEvent,\r\n    isFunction,\r\n    isHistoryControlState,\r\n    noop\r\n} from \"./helpers\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\nimport {CONTRACTS_EVAL, INIT_EVENT, INIT_STATE} from \"./properties\"\r\n\r\n// Contracts\r\n\r\n// S2. State names must be unique\r\nexport const noDuplicatedStates = {\r\n    name: 'noDuplicatedStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {getLabel} = objectTreeLenses;\r\n        const traverse = {\r\n            strategy: PRE_ORDER,\r\n            seed: {duplicatedStates: [], statesHashMap: {}},\r\n            visit: (acc, traversalState, tree) => {\r\n                const {duplicatedStates, statesHashMap} = acc;\r\n                const treeLabel = getLabel(tree);\r\n                const controlState = Object.keys(treeLabel)[0];\r\n                if (controlState in statesHashMap) {\r\n                    return {\r\n                        duplicatedStates: duplicatedStates.concat(controlState),\r\n                        statesHashMap\r\n                    }\r\n                }\r\n                else {\r\n                    return {\r\n                        duplicatedStates,\r\n                        statesHashMap: (statesHashMap[controlState] = \"\", statesHashMap)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const {duplicatedStates} = traverseObj(traverse, fsmDef.states);\r\n\r\n        const isFulfilled = duplicatedStates.length === 0;\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `State names must be unique! Found duplicated state names. Cf. log`,\r\n                info: {duplicatedStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S1. State name cannot be a reserved state name (for now only INIT_STATE)\r\nexport const noReservedStates = {\r\n    name: 'noReservedStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesType}) => {\r\n        return {\r\n            isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,\r\n            blame: {\r\n                message: `You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log`,\r\n                info: {reservedStates: [INIT_STATE], statesType}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S4. At least one control state (other than the initial state) muat be declared\r\nexport const atLeastOneState = {\r\n    name: 'atLeastOneState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesType}) => {\r\n        return {\r\n            isFulfilled: Object.keys(statesType).length > 0,\r\n            blame: {\r\n                message: `Machine configuration must define at least one control state! Cf. log`,\r\n                info: {statesType}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S5. check initial control state is a defined state in states\r\nexport const isInitialControlStateDeclared = {\r\n    name: 'isInitialControlStateDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition, statesType}) => {\r\n        const {initialControlState, transitions} = fsmDef;\r\n        const stateList = Object.keys(statesType);\r\n        if (initialControlState) {\r\n            return {\r\n                isFulfilled: stateList.indexOf(initialControlState) > -1,\r\n                blame: {\r\n                    message: `Configured initial control state must be a declared state. Cf. log`,\r\n                    info: {initialControlState, declaredStates: stateList}\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n\r\n    },\r\n};\r\n\r\n// E0. `fsmDef.events` msut be an array of strings\r\nexport const eventsAreStrings = {\r\n    name: 'eventsAreStrings',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        return {\r\n            isFulfilled: fsmDef.events.every(x => typeof x === 'string'),\r\n            blame: {\r\n                message: `Events must be an array of strings!`,\r\n                info: {events: fsmDef.events}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const validInitialConfig = {\r\n    name: 'validInitialConfig',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition}) => {\r\n        const {initialControlState} = fsmDef;\r\n\r\n        if (initTransition && initialControlState) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!`,\r\n                    info: {initialControlState, initTransition}\r\n                }\r\n            }\r\n        }\r\n        else if (!initTransition && !initialControlState) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?`,\r\n                    info: {initialControlState, initTransition}\r\n                }\r\n            }\r\n        }\r\n        else return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n    },\r\n};\r\n\r\n// T1. There must be configured at least one transition away from the initial state\r\n// T2. A transition away from the initial state can only be triggered by the initial event\r\n// T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history\r\n// state as target\r\n// T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We\r\n// can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and\r\n// debugging!. So enforce ACTIONS to be identity\r\nexport const validInitialTransition = {\r\n    name: 'validInitialTransition',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition}) => {\r\n        const {initialControlState, transitions} = fsmDef;\r\n        const initTransitions = transitions.reduce((acc, transition) => {\r\n            transition.from === INIT_STATE && acc.push(transition);\r\n            return acc\r\n        }, []);\r\n        // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!\r\n        // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't\r\n        // enforce the part of the contract which require to have no actions for initial transitions...\r\n        const isFulfilled =\r\n            (initialControlState && !initTransition) ||\r\n            (!initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT\r\n                && (\r\n                    isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY\r\n                    || areCconditionalTransitions(initTransition)\r\n                    // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)\r\n                )\r\n            );\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Invalid configuration for initial transition! Cf. log`,\r\n                info: {initTransition, initTransitions, initialControlState}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound\r\n// state or A is the initial state\r\nexport const initEventOnlyInCompoundStates = {\r\n    name: 'initEventOnlyInCompoundStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const atomicStates = Object.keys(statesType).filter(controlState => !statesType[controlState]);\r\n        const atomicInitTransitions = atomicStates.map(\r\n            atomicState => ({\r\n                [atomicState]: statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]\r\n            })\r\n        ).filter(obj => Object.values(obj)[0]);\r\n\r\n        const hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0\r\n\r\n        return {\r\n            isFulfilled: hasInitEventOnlyInCompoundStates,\r\n            blame: {\r\n                message: `Found at least one atomic state with an entry transition! That is forbidden! Cf. log`,\r\n                info: {initTransitions: atomicInitTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined\r\n// T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have a history state as target\r\n// NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop\r\n// T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have the history state as target and has a target control state that is one of its substates (no\r\n// out-of-hierarchy INIT transitions)\r\nexport const validInitialTransitionForCompoundState = {\r\n    name: 'validInitialTransitionForCompoundState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const compoundStates = Object.keys(statesType).filter(controlState => statesType[controlState]);\r\n        const compoundStatesInitTransitions = compoundStates.map(\r\n            compoundState => statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT]);\r\n\r\n        const allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);\r\n\r\n        if (!allHaveInitTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state without an entry transition! Cf. log`,\r\n                    info: {\r\n                        hasEntryTransitions: compoundStates.map(\r\n                            state => ({[state]: !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT])}))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const allHaveValidInitTransitions = allHaveInitTransitions &&\r\n            compoundStatesInitTransitions.every(initTransition => {\r\n                const {guards, to} = initTransition;\r\n                if (!guards) {\r\n                    //  T7a\r\n                    return typeof to === 'string'\r\n                }\r\n                else {\r\n                    const targetStates = guards.map(guard => guard.to);\r\n                    return targetStates.every(targetState => typeof targetState === 'string')\r\n                }\r\n            });\r\n        if (!allHaveValidInitTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log`,\r\n                    info: {entryTransitions: compoundStatesInitTransitions}\r\n                }\r\n            }\r\n        }\r\n        ;\r\n\r\n        const allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions &&\r\n            compoundStatesInitTransitions.every(initTransition => {\r\n                const {from, guards, to} = initTransition;\r\n\r\n                // Don't forget to also eliminate the case when from = to\r\n                // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the\r\n                // other from declared states\r\n                if (!guards){\r\n                    return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n                }\r\n                else {\r\n                    const targetStates = guards.map(guard => guard.to);\r\n                    return targetStates.every(to => {\r\n                        return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n                    })\r\n                }\r\n            });\r\n        if (!allHaveTargetStatesWithinHierarchy) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! `,\r\n                    info: {states: fsmDef.states, statesPath, entryTransitions: compoundStatesInitTransitions}\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            isFulfilled: true,\r\n            blame: void 0\r\n        }\r\n    },\r\n};\r\n\r\n// T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X\r\n// T24. Check that we have this implicitly : Compound states must not have eventless transitions\r\n// defined on them (would introduce ambiguity with the INIT transition).\r\nexport const validEventLessTransitions = {\r\n    name: 'validEventLessTransitions',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const stateList = Object.keys(statesType);\r\n        const failingOriginControlStates = stateList.map(state => {\r\n            return {\r\n                [state]: statesTransitionsMap[state] &&\r\n                `${void 0}` in statesTransitionsMap[state] &&\r\n                Object.keys(statesTransitionsMap[state]).length !== 1\r\n            }\r\n        }).filter(obj => Object.values(obj)[0] !== void 0 && Object.values(obj)[0]);\r\n\r\n        const isFulfilled = failingOriginControlStates.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found at least one control state without both an eventless transition and a competing transition! Cf. log`,\r\n                info: {failingOriginControlStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together\r\n// in a single array and there cannot be two transition rows showcasing A -ev-> * transitions\r\nexport const allStateTransitionsOnOneSingleRow = {\r\n    name: 'allStateTransitionsOnOneSingleRow',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const statesTransitionsInfo = originStateList.reduce((acc, state) => {\r\n            const events = Object.keys(stateEventTransitionsMaps[state]);\r\n            const wrongEventConfig = events.filter(event => stateEventTransitionsMaps[state][event].length > 1);\r\n            if (wrongEventConfig.length > 0) {\r\n                acc[state] = wrongEventConfig;\r\n            }\r\n\r\n            return acc\r\n        }, {});\r\n\r\n        const isFulfilled = Object.keys(statesTransitionsInfo).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log`,\r\n                info: {statesTransitionsInfo}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A\r\n// with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.\r\n// The event `ev` could trigger a transition towards either B or C\r\nexport const noConflictingTransitionsWithAncestorState = {\r\n    name: 'noConflictingTransitionsWithAncestorState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, eventTransitionsMaps, ancestorMap}) => {\r\n        const eventList = Object.keys(eventTransitionsMaps).filter(ev => ev !== INIT_EVENT && ev !== void 0);\r\n        const eventTransitionsInfo = eventList.reduce((acc, event) => {\r\n            const states = Object.keys(eventTransitionsMaps[event]);\r\n            // The wrongly configured states are those which have an ancestor also in the transition map for the same event\r\n            const wrongStateConfig = states\r\n                .filter(state => state !== INIT_STATE)\r\n                .map(state => ancestorMap[state] && {\r\n                    [state]: ancestorMap[state].find(\r\n                        ancestorState => states.indexOf(ancestorState) > -1\r\n                    )\r\n                })\r\n                // removing cases : undefined and {[state]: undefined}\r\n                .filter(obj => {\r\n                    return obj && Object.values(obj).filter(Boolean).length > 0\r\n                });\r\n\r\n            if (wrongStateConfig.length > 0) {\r\n                acc[event] = wrongStateConfig;\r\n            }\r\n\r\n            return acc\r\n        }, {});\r\n\r\n        const isFulfilled = Object.keys(eventTransitionsInfo).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log`,\r\n                info: {eventTransitionsInfo}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T16.a History states must be target states\r\nexport const isHistoryStatesTargetStates = {\r\n    name: 'isHistoryStatesTargetStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {}) => {\r\n        const wrongHistoryStates = fsmDef.transitions.reduce((acc, transition) => {\r\n            return isHistoryControlState(transition.from)\r\n                ? acc.concat(transition)\r\n                : acc\r\n        }, []);\r\n\r\n        const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log`,\r\n                info: {wrongHistoryStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T16.b History states must be compound states\r\nexport const isHistoryStatesCompoundStates = {\r\n    name: 'isHistoryStatesCompoundStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, statesType}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const wrongHistoryStates = originStateList.map(originState => {\r\n            if (originState === INIT_STATE) return []\r\n\r\n            const events = Object.keys(stateEventTransitionsMaps[originState]);\r\n\r\n            return events.reduce((acc, event) => {\r\n                // I should only ever have one transition, that is checked in another contract\r\n                // !! if there are several transitions, we may have a false positive, but that is ok\r\n                // When the other contract will fail and the issue will be solved, and app will be rerun,\r\n                // this will be recomputed correctly\r\n                const transition = stateEventTransitionsMaps[originState][event][0];\r\n                const {guards, to} = transition;\r\n                if (!guards) {\r\n                    // Reminder: statesType[controlState] === true iff controlState is compound state\r\n                    return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n                        ? acc.concat(transition)\r\n                        : acc\r\n                }\r\n                else {\r\n                    return guards.reduce((acc, guard) => {\r\n                        const {to} = guard;\r\n\r\n                        return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n                            ? acc.concat(transition)\r\n                            : acc\r\n                    }, acc)\r\n                }\r\n            }, [])\r\n        })\r\n            .reduce((acc, x) => acc.concat(x), []);\r\n\r\n        const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log`,\r\n                info: {wrongHistoryStates, states: fsmDef.states}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T17 An history state must refer to an existing state\r\nexport const isHistoryStatesExisting = {\r\n    name: 'isHistoryStatesExisting',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {historyStatesMap, statesType}) => {\r\n        const invalidTransitions = Array.from(historyStatesMap.entries())\r\n            .map(([historyState, flatTransitions]) => {\r\n                return !(historyState in statesType) && {historyState, flatTransitions}\r\n            })\r\n            .filter(Boolean);\r\n\r\n        const howMany = Object.keys(invalidTransitions).length;\r\n        const isFulfilled = howMany === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found ${howMany} history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition.`,\r\n                info: {invalidTransitions, states: fsmDef.states}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport function isInconditionalTransition(transition) {\r\n    const {from, event, guards, to, action} = transition;\r\n\r\n    return typeof guards === `${void 0}` && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action)\r\n}\r\n\r\nexport function isValidGuard(guard) {\r\n    const {to, predicate, action} = guard;\r\n\r\n    return to && isControlState(to) && isFunction(predicate) && isActionFactory(action)\r\n}\r\n\r\nexport function areCconditionalTransitions(transition) {\r\n    const {from, event, guards, to} = transition;\r\n\r\n    return guards && Array.isArray(guards) && guards.length > 0\r\n        && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard)\r\n}\r\n\r\nexport const isValidFsmDef = {\r\n    name: 'isValidFsmDef',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {transitions, states, events, initialExtendedState} = fsmDef;\r\n        const isValidTransitions = transitions && Array.isArray(transitions);\r\n        const isValidStates = states && typeof(states) === 'object';\r\n        const isValidEvents = events && Array.isArray(events);\r\n        if (!isValidTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The transitions property for a machine definition must be an array!`,\r\n                    info: {transitions}\r\n                }\r\n            }\r\n        }\r\n        else if (!isValidStates) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The states property for a machine definition must be an object!`,\r\n                    info: {states}\r\n                }\r\n            }\r\n        }\r\n        else if (!isValidEvents) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The events property for a machine definition must be an array!`,\r\n                    info: {events}\r\n                }\r\n            }\r\n        }\r\n        // NOTE : we do not deal with initialExtendedState, initialControlState and settings\r\n        // this is done in other contracts\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n    },\r\n}\r\n\r\n// T18. Transitions have a valid format, and are either inconditional (no guards) or conditional\r\n// events are strings\r\n// guards are functions\r\n// action factories are functions\r\nexport const haveTransitionsValidTypes = {\r\n    name: 'haveTransitionsValidTypes',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {transitions} = fsmDef;\r\n        const wrongTransitions = transitions\r\n            .map((transition, transitionIndex) => {\r\n                return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {\r\n                    transition,\r\n                    index: transitionIndex\r\n                }\r\n            })\r\n            .filter(Boolean)\r\n\r\n        const howMany = Object.keys(wrongTransitions).length;\r\n        const isFulfilled = howMany === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found ${howMany} transitions with invalid format! Check logs for more details.`,\r\n                info: {wrongTransitions, transitions}\r\n            }\r\n        }\r\n    },\r\n}\r\n\r\nexport const areEventsDeclared = {\r\n    name: 'areEventsDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {eventTransitionsMaps}) => {\r\n        const eventList = Object.keys(eventTransitionsMaps);\r\n        const declaredEventList = fsmDef.events;\r\n        const eventsDeclaredButNotTriggeringTransitions = declaredEventList\r\n            .map(declaredEvent => eventList.indexOf(declaredEvent) === -1 && declaredEvent)\r\n            .filter(Boolean);\r\n        const eventsNotDeclaredButTriggeringTransitions = eventList\r\n            .map(triggeringEvent => declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent)\r\n            .filter(Boolean)\r\n            // Filtering out init events which must not be declared, being reserved events\r\n            // Filtering out undefined events linked to eventless transitions\r\n            .filter(ev => ev !== INIT_EVENT && ev !== 'undefined')\r\n\r\n        const isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0\r\n            && eventsNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `All declared events must be used in transitions. All events used in transition must be declared! Cf. log`,\r\n                info: {eventsDeclaredButNotTriggeringTransitions, eventsNotDeclaredButTriggeringTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const areStatesDeclared = {\r\n    name: 'areStatesDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, targetStatesMap, statesType}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const targetStateList = Array.from(targetStatesMap.keys()).filter(x => typeof x !== 'object');\r\n        const stateList = Object.keys([originStateList, targetStateList].reduce((acc, stateList) => {\r\n            stateList.forEach(state => acc[state] = true)\r\n            return acc\r\n        }, {}));\r\n        const declaredStateList = Object.keys(statesType);\r\n        const statesDeclaredButNotTriggeringTransitions = declaredStateList\r\n            .map(declaredState => stateList.indexOf(declaredState) === -1 && declaredState)\r\n            .filter(Boolean);\r\n        const statesNotDeclaredButTriggeringTransitions = stateList\r\n            .map(stateInTransition =>\r\n                stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition)\r\n            .filter(Boolean);\r\n\r\n        const isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0\r\n            && statesNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `All declared states must be used in transitions. All states used in transition must be declared! Cf. log`,\r\n                info: {statesDeclaredButNotTriggeringTransitions, statesNotDeclaredButTriggeringTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T25. SS1 - as of v0.13 settings is no longer mandatory\r\nexport const isValidSettings = {\r\n    name: 'isValidSettings',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef) => {\r\n        return {\r\n            isFulfilled: true,\r\n            blame: void 0\r\n        }\r\n    },\r\n};\r\n\r\n// T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not\r\nexport const isInitialStateOriginState = {\r\n    name: 'isInitialStateOriginState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {targetStatesMap}) => {\r\n\r\n        if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one transition with the initial state as target state! CF. log`,\r\n                    info: {targetStates: Array.from(targetStatesMap.keys()), transitions: fsmDef.transitions}\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of\r\n// little practical value, though being a possible source of ambiguity or infinite loops)\r\n// A -_> A impossible on compound states because there is A -INIT-> X\r\n// so only possibility is A -_> A with A atomic state\r\nexport const isValidSelfTransition = {\r\n    name: 'isValidSelfTransition',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {targetStatesMap, statesType}) => {\r\n        const targetStates = Array.from(targetStatesMap.keys());\r\n        const wrongSelfTransitions = targetStates\r\n            .map(targetState => {\r\n                const flatTransitions = targetStatesMap.get(targetState);\r\n                return flatTransitions\r\n                    .map(flatTransition => {\r\n                        const {from, event} = flatTransition;\r\n                        if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {\r\n                            return {state: targetState, flatTransition}\r\n                        }\r\n                    })\r\n                    .filter(Boolean)\r\n            })\r\n            .filter(x => x.length > 0);\r\n\r\n        return {\r\n            isFulfilled: wrongSelfTransitions.length === 0,\r\n            blame: {\r\n                message: `Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log`,\r\n                info: {wrongSelfTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const fsmContracts = {\r\n    injected: (fsmDef, settings) => {\r\n        return {\r\n            statesType: getStatesType(fsmDef.states),\r\n            initTransition: findInitTransition(fsmDef.transitions),\r\n            statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),\r\n            stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),\r\n            eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),\r\n            ancestorMap: getAncestorMap(fsmDef.states),\r\n            statesPath: getStatesPath(fsmDef.states),\r\n            historyStatesMap: getHistoryStatesMap(fsmDef.transitions),\r\n            targetStatesMap: getTargetStatesMap(fsmDef.transitions)\r\n        }\r\n    },\r\n    description: 'FSM structure',\r\n    contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates],\r\n};\r\n\r\n/**\r\n * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may\r\n * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing\r\n * contract data structure include relevant information about the failing contract, in particular the contract name,\r\n * the associated error message and additional info expliciting the error message.\r\n * @param contractsDef\r\n * @param settings\r\n * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}\r\n */\r\nfunction makeContractHandler(contractsDef, settings) {\r\n    const console = settings && settings.debug && settings.debug.console || emptyConsole;\r\n    const trace = settings && settings.debug && settings.debug.trace || noop;\r\n    const contractsDescription = contractsDef.description;\r\n\r\n    return function checkContracts(...args) {\r\n        const failingContracts = [];\r\n        const computedArgs = contractsDef.injected.apply(null, args);\r\n        const isFulfilled = contractsDef.contracts.reduce((acc, contract) => {\r\n            const {name: contractName, predicate, shouldThrow} = contract;\r\n            const fullArgs = args.concat(computedArgs);\r\n            const {isFulfilled, blame} = predicate.apply(null, fullArgs);\r\n            const blameMessageHeader = `${contractsDescription} FAILS ${contractName}!`;\r\n            const {message, info} = blame || {};\r\n\r\n            if (isFulfilled) return acc\r\n            else {\r\n                failingContracts.push({name: contractName, message, info});\r\n                console.error(blameMessageHeader);\r\n                console.error([contractName, message].join(': '));\r\n                console.debug('Supporting error data:', info);\r\n\r\n                if (shouldThrow) throw new Error([blameMessageHeader, `check console for information!`].join('\\n'))\r\n                else {\r\n                    return false\r\n                }\r\n            }\r\n        }, true)\r\n\r\n        const contractsEval = {isFulfilled, failingContracts};\r\n        trace({[CONTRACTS_EVAL]: contractsEval})\r\n\r\n        return contractsEval\r\n    }\r\n}\r\n\r\nexport const fsmContractChecker = (fsmDef, settings, fsmContracts) => makeContractHandler(fsmContracts, settings)(fsmDef, settings);\r\n\r\n// Terminology\r\n// . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`\r\n// For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,\r\n// guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition\r\n// uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be\r\n// referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.\r\n// . We write A < B if A is a substate of B, with the implication that B is hence a compound state\r\n// . We write A !< B if A is a direct substate of B\r\n// . We write A. !< B if A is a substate of B, and A is also an atomic state\r\n// . We write A -ev-> B to denote a transition from A to B triggered by `ev`\r\n\r\n// Behaviour\r\n// B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly\r\n// returning to the same state)\r\n// ENFORCED by T13, T4, T10, necessary for generative testing\r\n// B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress\r\n// the state machine.\r\n// NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird\r\n// ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice\r\n// B8. It is possible to reach any states\r\n// NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal\r\n","import {\r\n  ACTION_IDENTITY,\r\n  AUTO_EVENT, DEBUG_MSG,\r\n  DEEP,\r\n  ERROR_MSG,\r\n  history_symbol,\r\n  INIT_EVENT, INIT_INPUT_MSG,\r\n  INIT_STATE, INPUT_MSG, INTERNAL_INPUT_MSG, INTERNAL_OUTPUTS_MSG, MACHINE_CREATION_ERROR_MSG,\r\n  OUTPUTS_MSG,\r\n  SHALLOW,\r\n  STATE_PROTOTYPE_NAME,\r\n  WARN_MSG\r\n} from \"./properties\";\r\nimport {\r\n  arrayizeOutput,\r\n  assert,\r\n  computeHistoryMaps,\r\n  destructureEvent,\r\n  emptyConsole,\r\n  emptyTracer,\r\n  findInitTransition,\r\n  get_fn_name,\r\n  getFsmStateList,\r\n  initHistoryDataStructure,\r\n  isActions,\r\n  isEventStruct,\r\n  isHistoryControlState,\r\n  keys, KinglyError,\r\n  updateHistory,\r\n  wrap\r\n} from \"./helpers\";\r\nimport {fsmContractChecker} from \"./contracts\"\r\n\r\nfunction alwaysTrue() {\r\n  return true\r\n};\r\n\r\n/**\r\n * Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state` : {Object<String,Boolean>} Hash whose properties (state names) are matched with\r\n * whether that state is a nested state\r\n * `hash_states` : Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hash_states: {}, is_group_state: {}}}\r\n */\r\nfunction build_nested_state_structure(states) {\r\n  const root_name = \"State\";\r\n  let hash_states = {};\r\n  let is_group_state = {};\r\n\r\n  // Add the starting state\r\n  states = {nok: states};\r\n\r\n  ////////\r\n  // Helper functions\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hash_states[state_name] = new curr_constructor();\r\n      hash_states[state_name].name = state_name;\r\n      const parent_name = (hash_states[state_name].parent_name = get_fn_name(\r\n        curr_constructor\r\n      ));\r\n      hash_states[state_name].root_name = root_name;\r\n\r\n      if (typeof state_config === \"object\") {\r\n        is_group_state[state_name] = true;\r\n        const curr_constructor_new = function () {\r\n        };\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hash_states[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    });\r\n  }\r\n\r\n  function State() {\r\n  }\r\n\r\n  State.prototype = {\r\n    current_state_name: INIT_STATE\r\n  };\r\n\r\n  hash_states[INIT_STATE] = new State();\r\n  hash_states[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hash_states: hash_states,\r\n    is_group_state: is_group_state\r\n  };\r\n}\r\n\r\nexport function normalizeTransitions(fsmDef) {\r\n  const {initialControlState, transitions} = fsmDef;\r\n  const initTransition = findInitTransition(transitions);\r\n\r\n  if (initialControlState) {\r\n    return transitions\r\n      .concat([{from: INIT_STATE, event: INIT_EVENT, to: initialControlState, action: ACTION_IDENTITY}])\r\n  }\r\n  else if (initTransition) {\r\n    return transitions\r\n  }\r\n}\r\n\r\n// Alias for compatibility before deprecating entirely create_state_machine\r\n// TODO: this is not used anymore apparently so remove\r\nexport function create_state_machine(fsmDef, settings) {\r\n  return createStateMachine(fsmDef, settings)\r\n}\r\n\r\n/**\r\n * Creates an instance of state machine from a set of states, transitions, and accepted events. The initial\r\n * extended state for the machine is included in the machine definition.\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @return {function(*=)}\r\n */\r\nexport function createStateMachine(fsmDef, settings) {\r\n  const {\r\n    states: control_states,\r\n    events,\r\n    // transitions ,\r\n    initialExtendedState,\r\n    updateState: userProvidedUpdateStateFn,\r\n  } = fsmDef;\r\n  const {debug, devTool, displayName} = settings || {};\r\n  const checkContracts = debug && debug.checkContracts || void 0;\r\n  let console = debug && debug.console || emptyConsole;\r\n  let tracer = devTool && devTool.tracer || emptyTracer;\r\n  const throwKinglyError = obj => {\r\n    throw new KinglyError(obj, console, tracer)\r\n  };\r\n\r\n  // Conracts must be checked before we start doing all sort of computations\r\n  if (checkContracts) {\r\n    const {failingContracts} = fsmContractChecker(fsmDef, settings, checkContracts);\r\n    try {\r\n      if (failingContracts.length > 0) throwKinglyError({\r\n        when: `Attempting to create a Kingly machine`,\r\n        location: `createStateMachine`,\r\n        info: {fsmDef, settings, failingContracts},\r\n        message: `I found that one or more Kingly contracts are violated!`\r\n      })\r\n    }\r\n    catch (e) {\r\n      // Do not break the program, errors should be passed to console and dev tool\r\n      tracer({\r\n        type: MACHINE_CREATION_ERROR_MSG,\r\n        trace: {\r\n          info: e.errors,\r\n          message: e.message,\r\n          machineState: {cs: INIT_STATE, es: extendedState, hs: history}\r\n        }\r\n      });\r\n      return e\r\n    }\r\n  }\r\n\r\n  const wrappedUpdateState = (extendedState, updates) => {\r\n    const fnName = userProvidedUpdateStateFn.name || userProvidedUpdateStateFn.displayName || \"\";\r\n\r\n    try {\r\n      return userProvidedUpdateStateFn(extendedState, updates)\r\n    }\r\n    catch (e) {\r\n      throwKinglyError({\r\n        when: `Executing updateState function ${fnName}`,\r\n        location: `createStateMachine > wrappedUpdateState`,\r\n        info: {extendedState, updates},\r\n        message: e.message,\r\n        stack: e.stack,\r\n      })\r\n    }\r\n  };\r\n  const transitions = normalizeTransitions(fsmDef);\r\n\r\n  // Create the nested hierarchy\r\n  const hash_states_struct = build_nested_state_structure(control_states);\r\n\r\n  // This will be the extended state object which will be updated by all actions and on which conditions\r\n  // will be evaluated It is safely contained in a closure so it cannot be accessed in any way\r\n  // outside the state machine.\r\n  // Note the extended state is modified by the `settings.updateState` function, which should not modify\r\n  // the extended state object. There is hence no need to do any cloning.\r\n  let extendedState = initialExtendedState;\r\n\r\n  // history maps\r\n  const {stateList, stateAncestors} = computeHistoryMaps(control_states);\r\n  let history = initHistoryDataStructure(stateList);\r\n\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has a init transition defined\r\n  let is_init_state = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined\r\n  // that would be init transitions + eventless transitions\r\n  let is_auto_state = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state is a group of state or not\r\n  const is_group_state = hash_states_struct.is_group_state;\r\n  let hash_states = hash_states_struct.hash_states;\r\n\r\n  function assertContract(contract, arrayParams) {\r\n    const hasFailed = assert(contract, arrayParams);\r\n    if (checkContracts && hasFailed) {\r\n      throwKinglyError(hasFailed)\r\n    }\r\n\r\n    return void 0\r\n  }\r\n\r\n  function getCurrentControlState() {\r\n    return hash_states[INIT_STATE].current_state_name\r\n  }\r\n\r\n  function send_event(event_struct, isExternalEvent) {\r\n    // TODO: maybe open a console.group and close it on return\r\n    assertContract(isEventStruct, [event_struct]);\r\n\r\n    const {eventName, eventData} = destructureEvent(event_struct);\r\n    const current_state = getCurrentControlState();\r\n\r\n    console.debug(\"send event\", event_struct);\r\n\r\n    // Edge case : INIT_EVENT sent and the current state is not the initial state\r\n    // We have to do this separately, as by construction the INIT_STATE is a\r\n    // super state of all states in the machine. Hence sending an INIT_EVENT\r\n    // would always execute the INIT transition by prototypal delegation\r\n    if (isExternalEvent && eventName === INIT_EVENT && current_state !== INIT_STATE) {\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: {eventName, eventData},\r\n          message: `The external event INIT_EVENT can only be sent when starting the machine!`,\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n      console.warn(`The external event INIT_EVENT can only be sent when starting the machine!`)\r\n\r\n      return null\r\n    }\r\n\r\n    const outputs = process_event(\r\n      hash_states_struct.hash_states,\r\n      eventName,\r\n\r\n      eventData,\r\n      extendedState\r\n    );\r\n\r\n    return outputs\r\n  }\r\n\r\n  function process_event(hash_states, event, event_data, extendedState) {\r\n    const current_state = hash_states[INIT_STATE].current_state_name;\r\n    const event_handler = hash_states[current_state][event];\r\n\r\n    if (event_handler) {\r\n      // CASE : There is a transition associated to that event\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event, event_data);\r\n      /* OUT : this event handler modifies the extendedState and possibly other data structures */\r\n      const {stop, outputs: rawOutputs} = event_handler(extendedState, event_data, current_state);\r\n      debug && !stop && console.warn(\"No guards have been fulfilled! We recommend to configure guards explicitly to\" +\r\n        \" cover the full state space!\")\r\n      const outputs = arrayizeOutput(rawOutputs);\r\n\r\n      // we read it anew as the execution of the event handler may have changed it\r\n      const new_current_state = hash_states[INIT_STATE].current_state_name;\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the current state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1: init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case event_data will carry on the data passed on from the last event (else we loose\r\n      // the extendedState?)\r\n      // 2. transitions with no events associated, only conditions (i.e. transient states)\r\n      // NOTE : the guard is to defend against loops occuring when an AUTO transition fails to advance and stays\r\n      // in the same control state!! But by contract that should never happen : all AUTO transitions should advance!\r\n      // TODO : test that case, what is happening? I should add a branch and throw!!\r\n      if (is_auto_state[new_current_state] && new_current_state !== current_state) {\r\n        // CASE : transient state with no triggering event, just conditions\r\n        // automatic transitions = transitions without events\r\n        const auto_event = is_init_state[new_current_state]\r\n          ? INIT_EVENT\r\n          : AUTO_EVENT;\r\n\r\n        tracer({\r\n          type: INTERNAL_INPUT_MSG,\r\n          trace: {\r\n            info: {eventName: auto_event, eventData: event_data},\r\n            event: {[auto_event]: event_data},\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        const nextOutputs = send_event({[auto_event]: event_data}, false);\r\n\r\n        tracer({\r\n          type: INTERNAL_OUTPUTS_MSG,\r\n          trace: {\r\n            outputs: nextOutputs,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        return [].concat(outputs).concat(nextOutputs);\r\n      } else return outputs;\r\n    } else {\r\n      // CASE : There is no transition associated to that event from that state\r\n      console.warn(`There is no transition associated to the event |${event}| in state |${current_state}|!`);\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: {received: {[event]: event_data}},\r\n          message: `There is no transition associated to the event |${event}| in state |${current_state}|!`,\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  function leave_state(from, extendedState, hash_states) {\r\n    // NOTE : extendedState is passed as a parameter for symetry reasons, no real use for it so far\r\n    const state_from = hash_states[from];\r\n    const state_from_name = state_from.name;\r\n\r\n    history = updateHistory(history, stateAncestors, state_from_name);\r\n\r\n    console.info(\"left state\", wrap(from));\r\n  }\r\n\r\n  function enter_next_state(to, updatedExtendedState, hash_states) {\r\n    let state_to;\r\n    let state_to_name;\r\n    // CASE : history state (H)\r\n    if (isHistoryControlState(to)) {\r\n      const history_type = to.deep ? DEEP : to.shallow ? SHALLOW : void 0;\r\n      const history_target = to[history_type];\r\n      // Edge case : history state (H) && no history (i.e. first time state is entered), target state\r\n      // is the entered state\r\n      // TODO: edge case should be init state for compound state, and check it is recursively descended,\r\n      // and error if the history target is an atomic state\r\n      // if (!is_auto_state(history_target)) throw `can't be atomic state`\r\n      // then by setting the compound state, it should evolve toward to init control state naturally\r\n      debug && console && !is_init_state[history_target] && console.error(`Configured a history state which does not relate to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration`);\r\n      state_to_name = history[history_type][history_target] || history_target;\r\n      state_to = hash_states[state_to_name];\r\n    }\r\n    else if (to) {\r\n      // CASE : normal state\r\n      state_to = hash_states[to];\r\n      state_to_name = state_to.name;\r\n    } else {\r\n      throwKinglyError (\"enter_state : unknown case! Not a state name, and not a history state to enter!\");\r\n    }\r\n    hash_states[INIT_STATE].current_state_name = state_to_name;\r\n\r\n    tracer({\r\n      type: DEBUG_MSG,\r\n      trace: {\r\n        message: isHistoryControlState(to)\r\n          ? `Entering history state for ${to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]}`\r\n          : `Entering state ${to}`,\r\n        machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n      }\r\n    });\r\n    debug && console.info(\"AND TRANSITION TO STATE\", state_to_name);\r\n    return state_to_name;\r\n  }\r\n\r\n  function start() {\r\n    tracer({\r\n      type: INIT_INPUT_MSG,\r\n      trace: {\r\n        info: {eventName: INIT_EVENT, eventData: initialExtendedState},\r\n        event: {[INIT_EVENT]: initialExtendedState},\r\n        machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n      }\r\n    });\r\n\r\n    return send_event({[INIT_EVENT]: initialExtendedState}, true);\r\n  }\r\n\r\n  transitions.forEach(function (transition) {\r\n    let {from, to, action, event, guards: arr_predicate} = transition;\r\n    // CASE : ZERO OR ONE condition set\r\n    if (!arr_predicate)\r\n      arr_predicate = [{predicate: void 0, to: to, action: action}];\r\n\r\n    // CASE : transition has a init event\r\n    // NOTE : there should ever only be one, but we don't enforce it here\r\n    if (event === INIT_EVENT) {\r\n      is_init_state[from] = true;\r\n    }\r\n\r\n    let from_proto = hash_states[from];\r\n\r\n    // CASE : automatic transitions : no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      is_auto_state[from] = true;\r\n    }\r\n    // CASE : automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (is_group_state[from] && is_init_state[from]) {\r\n      is_auto_state[from] = true;\r\n    }\r\n\r\n    // TODO : this seriously needs refactoring, that is one line in ramda\r\n    from_proto[event] = arr_predicate.reduce((acc, guard, index) => {\r\n        const action = guard.action || ACTION_IDENTITY;\r\n        const actionName = action.name || action.displayName || \"\";\r\n        const condition_checking_fn = (function (guard, settings) {\r\n          let condition_suffix = \"\";\r\n          // We add the `current_state` because the current control state might be different from\r\n          // the `from` field here This is the case for instance when we are in a substate, but\r\n          // through prototypal inheritance it is the handler of the prototype which is called\r\n          const condition_checking_fn = function (extendedState_, event_data, current_state) {\r\n            from = current_state || from;\r\n            const predicate = guard.predicate || alwaysTrue;\r\n            const predicateName = predicate.name || predicate.displayName || \"<anonymous>\";\r\n            const to = guard.to;\r\n            const shouldTransitionBeTaken = ((extendedState, event_data, settings) => {\r\n              try {\r\n                return predicate(extendedState, event_data, settings);\r\n              }\r\n              catch (e) {\r\n                throwKinglyError({\r\n                  when: `Executing predicate function ${predicateName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken`,\r\n                  info: {extendedState, event, event_data, settings, guard, from, to, index},\r\n                  message: [`Error occurred while processing event ${event} with target state ${to}`, e.message].join(\"\\n\"),\r\n                  stack: e.stack,\r\n                })\r\n              }\r\n            })(extendedState_, event_data, settings);\r\n\r\n            if (typeof shouldTransitionBeTaken !== \"boolean\") {\r\n              throwKinglyError({\r\n                when: `Executing predicate function ${predicateName}`,\r\n                location: `createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult`,\r\n                info: {event, guard, from, to, index, shouldTransitionBeTaken},\r\n                message: `Guard index ${index} with name ${predicateName} did not return a boolean!`,\r\n              })\r\n            }\r\n\r\n            if (shouldTransitionBeTaken) {\r\n              // CASE : guard for transition is fulfilled so we can execute the actions...\r\n              console.info(\"IN STATE \", from);\r\n              if (guard.predicate) {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `The guard ${predicateName} is fulfilled`,\r\n                    info: {eventData: event_data, from, action: actionName, to},\r\n                    machineState: {cs: current_state, es: extendedState_, hs: history}\r\n                  }\r\n                });\r\n                console.info(`CASE: guard ${predicate.name} for transition is fulfilled`);\r\n              }\r\n              else {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `Evaluating transition with no guards`,\r\n                    info: {eventData: event_data, from, action: actionName, to},\r\n                    machineState: {cs: current_state, es: extendedState, hs: history}\r\n                  }\r\n                });\r\n                console.info(`CASE: unguarded transition`);\r\n              }\r\n\r\n              console.info(\"THEN : we execute the action \" + actionName);\r\n              const actionResult = ((extendedState, eventData, settings) => {\r\n                try {\r\n                  return action(extendedState, eventData, settings);\r\n                }\r\n                catch (e) {\r\n                  throwKinglyError({\r\n                    when: `Executing action factory ${actionName}`,\r\n                    location: `createStateMachine > event handler > condition_checking_fn`,\r\n                    info: {extendedState, event, event_data, settings, guard, from, to, index, action},\r\n                    message: e.message,\r\n                    stack: e.stack,\r\n                  })\r\n                }\r\n              })(extendedState_, event_data, settings);\r\n\r\n              if (!isActions(actionResult)) {\r\n                throwKinglyError({\r\n                  when: `Executing action factory ${actionName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn`,\r\n                  info: {extendedState, event, event_data, settings, guard, from, to, index, action, actionResult},\r\n                  message: `Action factory returned a value that does not have the expected shape!`,\r\n                })\r\n              }\r\n\r\n              const {updates, outputs} = actionResult;\r\n\r\n              // Leave the current state\r\n              leave_state(from, extendedState_, hash_states);\r\n\r\n              // Update the extendedState before entering the next state\r\n              extendedState = wrappedUpdateState(extendedState_, updates);\r\n\r\n              // ...and enter the next state (can be different from `to` if we have nesting state group)\r\n              const next_state = enter_next_state(to, updates, hash_states);\r\n              console.info(\"ENTERING NEXT STATE: \", next_state);\r\n              console.info(\"with extended state: \", extendedState);\r\n\r\n              // allows for chaining and stop chaining guard\r\n              return {stop: true, outputs};\r\n            }\r\n            else {\r\n              // CASE : guard for transition is not fulfilled\r\n              tracer({\r\n                type: DEBUG_MSG,\r\n                trace: {\r\n                  message: guard.predicate ? `The guard ${predicateName} is not fulfilled!` : `Evaluated and skipped transition`,\r\n                  info: {eventData: event_data, settings, guard, from, to, index, action: actionName},\r\n                  machineState: {cs: current_state, es: extendedState, hs: history}\r\n                }\r\n              });\r\n              return {stop: false, outputs: null};\r\n            }\r\n          };\r\n          // TODO: remove that, I don't need that anymore\r\n          condition_checking_fn.displayName = from + condition_suffix;\r\n          return condition_checking_fn;\r\n        })(guard, settings);\r\n\r\n        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {\r\n          const condition_checked = acc(extendedState_, event_data, current_state);\r\n          return condition_checked.stop\r\n            ? condition_checked\r\n            : condition_checking_fn(extendedState_, event_data, current_state);\r\n        };\r\n      },\r\n      function dummy() {\r\n        return {stop: false, outputs: null};\r\n      }\r\n    );\r\n  });\r\n\r\n  // TODO: think if rethrow errors we are not responsible for here too\r\n  try {\r\n    start();\r\n  }\r\n  catch (e) {\r\n    // Do not break the program, errors should be passed to console and dev tool\r\n    tracer({\r\n      type: MACHINE_CREATION_ERROR_MSG,\r\n      trace: {\r\n        message: e.message,\r\n        info: {fsmDef, settings, error: e},\r\n        machineState: {cs: INIT_STATE, es: extendedState, hs: history}\r\n      }\r\n    });\r\n    return e\r\n  }\r\n\r\n  // NOTE : yield is a reserved JavaScript word so using yyield\r\n  return function yyield(x) {\r\n    try {\r\n      const {eventName, eventData} = destructureEvent(x);\r\n      const current_state = getCurrentControlState();\r\n\r\n      tracer({\r\n        type: INPUT_MSG,\r\n        trace: {\r\n          info: {eventName, eventData},\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      const outputs = send_event(x, true);\r\n\r\n      debug && console.info(\"OUTPUTS:\", outputs);\r\n      tracer({\r\n        type: OUTPUTS_MSG,\r\n        trace: {\r\n          outputs,\r\n          machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      return outputs\r\n    }\r\n    catch (e) {\r\n      if (e instanceof KinglyError) {\r\n        // We don't break the program, but we can't continue as nothing happened: we return the error\r\n        tracer({\r\n          type: ERROR_MSG,\r\n          trace: {\r\n            error: e,\r\n            message: `An error ocurred while running an input through the machine!`,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        return e\r\n      }\r\n      else {\r\n        tracer({\r\n          type: ERROR_MSG,\r\n          trace: {\r\n            error: e,\r\n            message: `An unknown error ocurred while running an input through the machine!`,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n        console.error(`yyield > unexpected error!`, e);\r\n        // We should only catch the errors we are responsible for!\r\n        throw e\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {WebComponentName} name name for the web component. Must include at least one hyphen per custom\r\n * components' specification\r\n * @param {Subject} eventHandler A factory function which returns a subject, i.e. an object which\r\n * implements the `Observer` and `Observable` interface\r\n * @param {FSM} fsm An executable machine, i.e. a function which accepts machine inputs\r\n * @param {Object.<CommandName, CommandHandler>} commandHandlers\r\n * @param {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an effect moniker to a function performing the corresponding effect.\r\n * @param {{initialEvent, terminalEvent, NO_ACTION}} options\r\n */\r\nexport function makeWebComponentFromFsm({name, eventHandler, fsm, commandHandlers, effectHandlers, options}) {\r\n  class FsmComponent extends HTMLElement {\r\n    constructor() {\r\n      if (name.split('-').length <= 1) throw `makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!`\r\n      super();\r\n      const el = this;\r\n      this.eventSubject = eventHandler;\r\n      this.options = Object.assign({}, options);\r\n      const NO_ACTION = this.options.NO_ACTION || null;\r\n\r\n      // Set up execution of commands\r\n      this.eventSubject.subscribe({\r\n        next: eventStruct => {\r\n          const actions = fsm(eventStruct);\r\n\r\n          if (actions === NO_ACTION) return;\r\n          actions.forEach(action => {\r\n            if (action === NO_ACTION) return;\r\n            const {command, params} = action;\r\n            commandHandlers[command](this.eventSubject.next, params, effectHandlers, el);\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      return [];\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);\r\n      this.eventSubject.complete();\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      // simulate a new creation every time an attribute is changed\r\n      // i.e. they are not expected to change\r\n      this.constructor();\r\n      this.connectedCallback();\r\n    }\r\n  }\r\n\r\n  return customElements.define(name, FsmComponent);\r\n}\r\n\r\n/**\r\n * This function works to merge outputs by simple concatenation and flattening\r\n * Every action return T or [T], and we want in output [T] always\r\n * mergeOutputsFn([a, [b]) = mergeOutputsFn([a,b]) = mergeOutputsFn([[a],b) = mergeOutputsFn([[a],[b]]) = [a,b]\r\n * If we wanted to pass [a] as value we would have to do mergeOutputsFn([[[a]],[b]]) to get [[a],b]\r\n * @param arrayOutputs\r\n * @returns {*}\r\n */\r\nexport function mergeOutputsFn(arrayOutputs) {\r\n  // NOTE : here, this array of outputs could be array x non-array ^n\r\n  // The algorithm is to concat all elements\r\n  return arrayOutputs.reduce((acc, element) => acc.concat(element), [])\r\n}\r\n\r\n/**\r\n * Construct history states `hs` from a list of states for a given state machine. The history states for a given control\r\n * state can then be referenced as follows :\r\n * - `hs.shallow(state)` will be the shallow history state associated to the `state`\r\n * - `hs.deep(state)` will be the deep history state associated to the `state`\r\n * @param {FSM_States} states\r\n * @return {HistoryStateFactory}\r\n */\r\nexport function makeHistoryStates(states) {\r\n  const stateList = Object.keys(getFsmStateList(states));\r\n  // used for referential equality comparison to discriminate history type\r\n\r\n  return (historyType, controlState) => {\r\n    if (!stateList.includes(controlState)) {\r\n      throw `makeHistoryStates: the state for which a history state must be constructed is not a configured state for the state machine under implementation!!`\r\n    }\r\n\r\n    return {\r\n      [historyType]: controlState,\r\n      type: history_symbol\r\n    }\r\n  }\r\n}\r\n\r\nexport function historyState(historyType, controlState) {\r\n  return {\r\n    [historyType]: controlState\r\n  }\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INIT_STATE, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  getDisplayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${getDisplayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {ControlState} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INIT_STATE) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n"],"names":["CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE","SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INIT_STATE","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_STATE_UPDATE","NO_OUTPUT","ACTION_IDENTITY","outputs","updates","history_symbol","SHALLOW","DEEP","WRONG_EVENT_FORMAT_ERROR","FUNCTION_THREW_ERROR","fnName","type","INVALID_ACTION_FACTORY_EXECUTED","actionName","INVALID_PREDICATE_EXECUTED","ACTION_FACTORY_DESC","ENTRY_ACTION_FACTORY_DESC","UPDATE_STATE_FN_DESC","PREDICATE_DESC","COMMAND_RENDER","CONTRACTS_EVAL","OUTPUTS_MSG","INPUT_MSG","WARN_MSG","MACHINE_CREATION_ERROR_MSG","ERROR_MSG","INTERNAL_INPUT_MSG","INTERNAL_OUTPUTS_MSG","DEBUG_MSG","INIT_INPUT_MSG","PATH_ROOT","PRE_ORDER","clone","a","undefined","JSON","parse","stringify","merge","objA","objB","Object","assign","updatePathInTraversalState","traversalState","subTree","subTreeChildren","forEach","subTreeChild","index","traversalStateParent","get","traversalStateChild","currentChildPath","path","set","isAdded","isVisited","concat","updateVisitInTraversalState","tree","visitTree","traversalSpecs","store","lenses","traverse","empty","emptyOrEmptyConstructor","add","takeAndRemoveOne","isEmpty","getChildren","visit","seed","seedOrSeedConstructor","Map","currentStore","visitAcc","clear","breadthFirstTraverseTree","shift","length","subTrees","push","apply","preorderTraverseTree","unshift","postOrderTraverseTree","predicate","isLeaf","result","isLeafLabel","label","objectTreeLenses","getLabel","Array","isArray","keys","value","values","map","prop","[object Object]","constructTree","children","labelKey","traverseObj","obj","treeObj","root","strategy","BFS","POST_ORDER","arrayTreeLenses","noop","emptyConsole","log","warn","info","debug","error","trace","emptyTracer","isBoolean","x","isFunction","isControlState","isHistoryControlState","isEvent","isActionFactory","make_states","stateList","reduce","acc","state","make_events","eventList","get_fn_name","fn","exec","toString","wrap","str","join","times","n","Number","call","always","b","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","from","is_to_history_control_state_of","is_history_control_state_of","substring","format_transition_label","_event","action","name","format_history_transition_state_name","get_all_transitions","guards","getDisplayName","replace","mergeModelUpdates","arrayUpdateActions","extendedState","eventData","settings","updateAction","update","chainModelUpdates","updateState","mergeActionFactories","mergeOutputFn","arrayActionFactory","arrayActions","factory","arrayStateUpdates","arrayOutputs","identity","lastOf","arr","formatActionName","predicateName","formattedPredicate","getFsmStateList","states","accStateList","treeLabel","getStatesType","statesTree","getStatesPath","pathStr","getStatesTransitionsMap","transitions","getStateEventTransitionsMaps","getEventTransitionsMaps","getHistoryStatesMap","reduceTransitions","flatTransition","guardIndex","transitionIndex","gen","underlyingControlState","getHistoryUnderlyingState","getTargetStatesMap","getAncestorMap","computeHistoryMaps","control_states","stateAncestors","parentPath","slice","parentControlState","ancestors","_","mapOverTransitionsActions","mapFn","mappedAction","displayName","reduceFn","transitionStruct","guard","everyTransition","pred","computeTimesCircledOn","edgePath","edge","edgeInEdgePath","isInitState","s","isInitEvent","e","isEventless","arrayizeOutput","output","_typeof","getHistoryParentState","isShallowHistory","isDeepHistory","getHistoryType","history","isHistoryStateEdge","initHistoryDataStructure","initHistory","isCompoundState","analyzedStates","statesAdjacencyList","isAtomicState","updateHistory","state_from_name","oldAncestor","newAncestor","computeHistoryState","controlStateSequence","historyType","historyParentState","findInitTransition","find","tryCatch","errCb","args","tryCatchMachineFn","fnType","argsDesc","err","Error","getFunctionName","probableCause","params","argDesc","actionFactory","assert","contract","arrayParams","contractName","isFulfilledOrError","when","message","notifyThrows","console","handleFnExecError","notify","execInfo","actionResultOrError","postCondition","throwFn","invalidResultFn","notifyAndRethrow","throwIfInvalidActionResult","updatedExtendedState","returned","throwIfInvalidGuardResult","resultOrError","predName","throwIfInvalidEntryActionResult","exitActionResultOrError","isActions","isEventStruct","trueOrError","cause","isError","destructureEvent","eventName","formatUndefinedInJSON","key","KinglyError","m","tracer","stack","_this","errors","location","fullMsg","noDuplicatedStates","shouldThrow","fsmDef","duplicatedStates","statesHashMap","isFulfilled","blame","noReservedStates","statesType","indexOf","reservedStates","atLeastOneState","isInitialControlStateDeclared","initTransition","initialControlState","declaredStates","eventsAreStrings","events","every","validInitialConfig","validInitialTransition","initTransitions","isInconditionalTransition","areCconditionalTransitions","initEventOnlyInCompoundStates","statesTransitionsMap","atomicInitTransitions","statesPath","filter","atomicState","validInitialTransitionForCompoundState","compoundStates","compoundStatesInitTransitions","compoundState","allHaveInitTransitions","Boolean","hasEntryTransitions","allHaveValidInitTransitions","targetState","entryTransitions","validEventLessTransitions","failingOriginControlStates","allStateTransitionsOnOneSingleRow","stateEventTransitionsMaps","statesTransitionsInfo","wrongEventConfig","noConflictingTransitionsWithAncestorState","eventTransitionsMaps","ancestorMap","eventTransitionsInfo","ev","wrongStateConfig","ancestorState","isHistoryStatesTargetStates","wrongHistoryStates","isHistoryStatesCompoundStates","originState","isHistoryStatesExisting","historyStatesMap","invalidTransitions","entries","historyState","flatTransitions","howMany","isValidGuard","isValidFsmDef","isValidTransitions","initialExtendedState","isValidStates","isValidEvents","haveTransitionsValidTypes","wrongTransitions","areEventsDeclared","declaredEventList","eventsDeclaredButNotTriggeringTransitions","declaredEvent","eventsNotDeclaredButTriggeringTransitions","triggeringEvent","areStatesDeclared","targetStatesMap","originStateList","targetStateList","declaredStateList","statesDeclaredButNotTriggeringTransitions","declaredState","statesNotDeclaredButTriggeringTransitions","stateInTransition","isValidSettings","isInitialStateOriginState","targetStates","isValidSelfTransition","wrongSelfTransitions","fsmContracts","injected","description","contracts","makeContractHandler","contractsDef","contractsDescription","failingContracts","computedArgs","contractsEval","fullArgs","blameMessageHeader","fsmContractChecker","alwaysTrue","build_nested_state_structure","root_name","hash_states","is_group_state","State","nok","prototype","current_state_name","build_state_reducer","curr_constructor","state_name","state_config","parent_name","curr_constructor_new","normalizeTransitions","create_state_machine","createStateMachine","userProvidedUpdateStateFn","devTool","checkContracts","throwKinglyError","machineState","cs","es","hs","hash_states_struct","is_init_state","is_auto_state","getCurrentControlState","send_event","event_struct","isExternalEvent","hasFailed","current_state","event_data","event_handler","stop","rawOutputs","new_current_state","auto_event","nextOutputs","received","process_event","arr_predicate","from_proto","condition_checking_fn","extendedState_","shouldTransitionBeTaken","actionResult","leave_state","wrappedUpdateState","next_state","state_to_name","history_type","deep","shallow","history_target","enter_next_state","condition_checked","makeWebComponentFromFsm","eventHandler","fsm","commandHandlers","effectHandlers","options","FsmComponent","split","el","eventSubject","NO_ACTION","subscribe","next","eventStruct","actions","command","HTMLElement","initialEvent","this","terminalEvent","complete","oldValue","newValue","constructor","connectedCallback","customElements","define","mergeOutputsFn","element","makeHistoryStates","includes","generateStatePlantUmlHeader","optDisplayName","toPlantUml","translationMap","pathMap","translation","stateToPlantUML","getChildrenNumber","mappedTree","childrenTranslation","format_history_states","format_entry_transitions","translate_transitions","historyStatesObj","accTranslation","format_history_transitions","format_standard_transitions","toDagreVisualizerFormat","translatedStates","translatedTransitions"],"mappings":"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"}