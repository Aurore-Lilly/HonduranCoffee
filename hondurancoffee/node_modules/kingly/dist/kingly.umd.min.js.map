{"version":3,"file":"kingly.umd.min.js","sources":["../src/properties.js","../node_modules/fp-rosetree/index.js","../src/helpers.js","../src/contracts.js","../src/synchronous_fsm.js","../src/converter.js"],"sourcesContent":["export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INIT_STATE = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_STATE_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = [];\r\nexport const ACTION_IDENTITY = function ACTION_IDENTITY(){\r\n  return {\r\n    outputs : NO_OUTPUT,\r\n    updates : NO_STATE_UPDATE\r\n  }\r\n}\r\nexport const history_symbol = {};\r\nexport const SHALLOW = 'shallow';\r\nexport const DEEP = 'deep';\r\n\r\nexport const WRONG_EVENT_FORMAT_ERROR = `The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.`\r\nexport const FUNCTION_THREW_ERROR = (fnName, type) => `Exception thrown when executing ${type} ${fnName||\"\"}`\r\nexport const INVALID_ACTION_FACTORY_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not an action.`\r\nexport const INVALID_PREDICATE_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not a boolean.`\r\nexport const ACTION_FACTORY_DESC = `action factory`\r\nexport const ENTRY_ACTION_FACTORY_DESC = `(decorating) entry action`\r\nexport const UPDATE_STATE_FN_DESC = `update state function`\r\nexport const PREDICATE_DESC = `predicate`\r\n\r\nexport const COMMAND_RENDER = 'render'\r\n\r\nexport const CONTRACTS_EVAL = \"CONTRACTS_EVAL\";\r\n\r\nexport const OUTPUTS_MSG = \"OUTPUTS_MSG\";\r\nexport const INPUT_MSG = \"INPUT_MSG\";\r\nexport const WARN_MSG = 'WARN_MSG';\r\nexport const MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';\r\nexport const ERROR_MSG = 'ERROR_MSG';\r\nexport const INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';\r\nexport const INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';\r\nexport const DEBUG_MSG = 'DEBUG_MSG';\r\nexport const INIT_INPUT_MSG = 'INIT_INPUT_MSG';\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","// Ramda fns\r\nimport {\r\n  ACTION_FACTORY_DESC, DEEP, ENTRY_ACTION_FACTORY_DESC, FUNCTION_THREW_ERROR, HISTORY_PREFIX, HISTORY_STATE_NAME,\r\n  INIT_EVENT, INIT_STATE, INVALID_ACTION_FACTORY_EXECUTED, INVALID_PREDICATE_EXECUTED, NO_OUTPUT,\r\n  PREDICATE_DESC,\r\n  SHALLOW, WRONG_EVENT_FORMAT_ERROR\r\n} from \"./properties\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\n\r\nexport const noop = () => {\r\n};\r\nexport const emptyConsole = {log: noop, warn: noop, info: noop, debug: noop, error: noop, trace: noop};\r\nexport const emptyTracer = noop;\r\n\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\nexport function isFunction(x) {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport function isControlState(x) {\r\n  return x && typeof x === 'string' || isHistoryControlState(x)\r\n}\r\n\r\nexport function isEvent(x) {\r\n  return typeof x === 'undefined' || typeof x === 'string'\r\n}\r\n\r\nexport function isActionFactory(x) {\r\n  return x && typeof x === 'function'\r\n}\r\n\r\nexport function make_states(stateList) {\r\n  return stateList.reduce((acc, state) => {\r\n    acc[state] = \"\";\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function make_events(eventList) {\r\n  return eventList\r\n}\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) {\r\n  return ['-', str, '-'].join(\"\");\r\n}\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\nexport function always(x) {\r\n  return x\r\n}\r\n\r\nexport function keys(obj) {\r\n  return Object.keys(obj)\r\n}\r\n\r\nexport function merge(a, b) {\r\n  return Object.assign({}, a, b)\r\n}\r\n\r\n// Contracts\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({from, to}) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const {from, event, guards} = transition;\r\n\r\n  return guards\r\n    ? guards.map(({predicate, to, action}) => ({from, event, predicate, to, action}))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function getDisplayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n/**\r\n * This function MERGES extended state updates. That means that given two state updates, the resulting state update\r\n * will be the concatenation of the two, in the order in which they are passed\r\n * @param {function[]}  arrayUpdateActions\r\n * @returns {function(*=, *=, *=): {updates: *}}\r\n */\r\nexport function mergeModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    return {\r\n      updates: arrayUpdateActions.reduce((acc, updateAction) => {\r\n        const update = updateAction(extendedState, eventData, settings).updates;\r\n        if (update) {\r\n          return acc.concat(update)\r\n        }\r\n        else {\r\n          return acc\r\n        }\r\n      }, []),\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function CHAINS extended state updates, in the order in which they are passed. It is thus similar to a pipe.\r\n * The second update function receives the state updated by the first update function.\r\n * @param {function[]}  arrayUpdateActions\r\n */\r\nexport function chainModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    const {updateState} = settings;\r\n    return {\r\n      updates: arrayUpdateActions\r\n        .reduce((acc, updateAction) => {\r\n          const {extendedState, updates} = acc;\r\n          const update = updateAction(extendedState, eventData, settings).updates;\r\n          const updatedState = updateState(extendedState, updates)\r\n\r\n          return {extendedState: updatedState, updates: update}\r\n        }, {extendedState, updates: []})\r\n        .updates || [],\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {function (Array<Array<MachineOutput>>) : Array<MachineOutput>} mergeOutputFn\r\n * @param {Array<ActionFactory>} arrayActionFactory\r\n * @returns {function(*=, *=, *=): {updates: *[], outputs: *|null}}\r\n */\r\nexport function mergeActionFactories(mergeOutputFn, arrayActionFactory) {\r\n  return function (extendedState, eventData, settings) {\r\n    const arrayActions = arrayActionFactory.map(factory => factory(extendedState, eventData, settings));\r\n    const arrayStateUpdates = arrayActions.map(x => x.updates || []);\r\n    const arrayOutputs = arrayActions.map(x => x.outputs || {});\r\n\r\n    return {\r\n      updates: [].concat(...arrayStateUpdates),\r\n      // for instance, mergeFn = R.mergeAll or some variations around R.mergeDeepLeft\r\n      outputs: mergeOutputFn(arrayOutputs)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type ActionFactory*/\r\nexport function identity(extendedState, eventData, settings) {\r\n  return {\r\n    updates: [],\r\n    outputs: NO_OUTPUT\r\n  }\r\n}\r\n\r\nexport function lastOf(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction formatActionName(action, from, event, to, predicate) {\r\n  const predicateName = predicate ? predicate.name : \"\";\r\n  const formattedPredicate = predicateName ? `[${predicateName}]` : \"\";\r\n  const actionName = action ? action.name : \"identity\";\r\n  const formattedAction = actionName ? actionName : \"unnamed action\";\r\n  return `${formattedAction}:${from}-${event}->${to} ${formattedPredicate}`;\r\n}\r\n\r\nexport function getFsmStateList(states) {\r\n  const {getLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (accStateList, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      accStateList[controlState] = \"\";\r\n\r\n      return accStateList;\r\n    }\r\n  };\r\n  const stateHashMap = traverseObj(traverse, states);\r\n\r\n  return stateHashMap\r\n}\r\n\r\nexport function getStatesType(statesTree) {\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      // true iff control state is a compound state\r\n      return isLeafLabel(treeLabel)\r\n        ? (acc[controlState] = false, acc)\r\n        : (acc[controlState] = true, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesPath(statesTree) {\r\n  const {getLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const pathStr = traversalState.get(tree).path.join('.');\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      return (acc[controlState] = pathStr, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesTransitionsMap(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = transition;\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getStateEventTransitionsMaps(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getEventTransitionsMaps(transitions) {\r\n  // Map an event to the origin control states of the transitions it triggers\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[event] = acc[event] || {};\r\n      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getHistoryStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {from, event, to, action, predicate, gen} = flatTransition;\r\n      if (isHistoryControlState(from)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(from);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n      else if (isHistoryControlState(to)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(to);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getTargetStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {to} = flatTransition;\r\n      map.set(to, (map.get(to) || []).concat([flatTransition]));\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getAncestorMap(statesTree) {\r\n  const {getLabel, getChildren} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = getChildren(tree)\r\n      const childrenControlStates = children.map(tree => Object.keys(getLabel(tree))[0]);\r\n\r\n      childrenControlStates.forEach(state => {\r\n        acc[state] = acc[state] || [];\r\n        acc[state] = acc[state].concat(controlState);\r\n      });\r\n\r\n      return acc\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function computeHistoryMaps(control_states) {\r\n  if (Object.keys(control_states).length === 0) {\r\n    throw `computeHistoryMaps : passed empty control states parameter?`\r\n  }\r\n\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {stateList: [], stateAncestors: {}},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      acc.stateList = acc.stateList.concat(controlState);\r\n\r\n      // NOTE : we don't have to worry about path having only one element\r\n      // that case correspond to the root of the tree which is excluded from visiting\r\n      const {path} = traversalState.get(tree);\r\n      traversalState.set(JSON.stringify(path), controlState);\r\n      const parentPath = path.slice(0, -1);\r\n      if (parentPath.length === 1) {\r\n        // That's the root\r\n        traversalState.set(JSON.stringify(parentPath), INIT_STATE);\r\n      }\r\n      else {\r\n        const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n        acc.stateAncestors[controlState] = [parentControlState];\r\n\r\n        const {ancestors} = path.reduce((acc, _) => {\r\n          const parentPath = acc.path.slice(0, -1);\r\n          acc.path = parentPath;\r\n          if (parentPath.length > 1) {\r\n            const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n            acc.ancestors = acc.ancestors.concat(parentControlState);\r\n          }\r\n\r\n          return acc\r\n        }, {ancestors: [], path});\r\n        acc.stateAncestors[controlState] = ancestors;\r\n      }\r\n\r\n      return acc\r\n    }\r\n  };\r\n  const {stateList, stateAncestors} = traverseObj(traverse, control_states);\r\n\r\n  return {stateList, stateAncestors}\r\n}\r\n\r\nexport function mapOverTransitionsActions(mapFn, transitions) {\r\n  return reduceTransitions(function (acc, transition, guardIndex, transitionIndex) {\r\n    const {from, event, to, action, predicate} = transition;\r\n    const mappedAction = mapFn(action, transition, guardIndex, transitionIndex);\r\n    mappedAction.displayName = mappedAction.displayName || (action && (action.name || action.displayName || formatActionName(action, from, event, to, predicate)));\r\n\r\n    if (typeof(predicate) === 'undefined') {\r\n      acc.push({from, event, to, action: mappedAction})\r\n    }\r\n    else {\r\n      if (guardIndex === 0) {\r\n        acc.push({from, event, guards: [{to, predicate, action: mappedAction}]})\r\n      }\r\n      else {\r\n        acc[acc.length - 1].guards.push({to, predicate, action: mappedAction})\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, [], transitions)\r\n}\r\n\r\nexport function reduceTransitions(reduceFn, seed, transitions) {\r\n  const result = transitions.reduce((acc, transitionStruct, transitionIndex) => {\r\n    let {from, event, to, gen, action, guards} = transitionStruct;\r\n    // Edge case when no guards are defined\r\n    if (!guards) {\r\n      guards = gen ? [{to, action, gen, predicate: undefined}] : [{to, action, predicate: undefined}]\r\n    }\r\n    return guards.reduce((acc, guard, guardIndex) => {\r\n      const {to, action, gen, predicate} = guard;\r\n      return gen\r\n        ? reduceFn(acc, {from, event, to, action, predicate, gen}, guardIndex, transitionIndex)\r\n        : reduceFn(acc, {from, event, to, action, predicate}, guardIndex, transitionIndex)\r\n    }, acc);\r\n  }, seed);\r\n\r\n  return result\r\n}\r\n\r\nexport function everyTransition(pred, transition) {\r\n  return reduceTransitions((acc, flatTransition) => {\r\n    return acc && pred(flatTransition)\r\n  }, true, [transition])\r\n}\r\n\r\nexport function computeTimesCircledOn(edgePath, edge) {\r\n  return edgePath.reduce((acc, edgeInEdgePath) => edgeInEdgePath === edge ? acc + 1 : acc, 0);\r\n}\r\n\r\nexport function isInitState(s) {\r\n  return s === INIT_STATE\r\n}\r\n\r\nexport function isInitEvent(e) {\r\n  return e === INIT_EVENT\r\n}\r\n\r\nexport function isEventless(e) {\r\n  return typeof e === 'undefined'\r\n}\r\n\r\nexport function arrayizeOutput(output) {\r\n  return output === NO_OUTPUT\r\n    ? NO_OUTPUT\r\n    : Array.isArray(output)\r\n      ? output\r\n      : [output]\r\n}\r\n\r\nexport function isHistoryControlState(to) {\r\n  return typeof to === 'object' && (DEEP in to || SHALLOW in to)\r\n}\r\n\r\nexport function getHistoryParentState(to) {\r\n  return to[SHALLOW] || to[DEEP]\r\n}\r\n\r\nexport function isShallowHistory(to) {\r\n  return to[SHALLOW]\r\n}\r\n\r\nexport function isDeepHistory(to) {\r\n  return to[DEEP]\r\n}\r\n\r\nexport function getHistoryType(history) {\r\n  return history[DEEP] ? DEEP : SHALLOW\r\n}\r\n\r\nexport function getHistoryUnderlyingState(history) {\r\n  return history[getHistoryType(history)]\r\n}\r\n\r\nexport function isHistoryStateEdge(edge) {\r\n  return typeof edge.history !== 'undefined'\r\n}\r\n\r\n/**\r\n * Creates a history object from a state list. The created history object represents the history states when no\r\n * control states have been entered or exited.\r\n * @param stateList\r\n * @returns {History}\r\n */\r\nexport function initHistoryDataStructure(stateList) {\r\n  // NOTE : we update history in place, so we need two different objects here, even\r\n  // when they start with the same value\r\n  const initHistory = () => stateList.reduce((acc, state) => (acc[state] = '', acc), {});\r\n  return {[DEEP]: initHistory(), [SHALLOW]: initHistory()};\r\n}\r\n\r\nexport function isCompoundState(analyzedStates, controlState) {\r\n  const {statesAdjacencyList} = analyzedStates;\r\n  return statesAdjacencyList[controlState] && statesAdjacencyList[controlState].length !== 0\r\n}\r\n\r\nexport function isAtomicState(analyzedStates, controlState) {\r\n  return !isCompoundState(analyzedStates, controlState)\r\n}\r\n\r\n/**\r\n * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the\r\n * `stateAncestors` which are the ancestors for the exited state.\r\n * @param {History} history Contains deep history and shallow history for all\r\n * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function\r\n * `updateHistory` allows to update the history as transitions occur in the state machine.\r\n * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors\r\n * @returns {History}\r\n * @modifies history\r\n */\r\nexport function updateHistory(history, stateAncestors, state_from_name) {\r\n  // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)\r\n\r\n  if (state_from_name === INIT_STATE) {\r\n    return history\r\n  }\r\n  else {\r\n      // ancestors for the state which is exited\r\n      const ancestors = stateAncestors[state_from_name] || [];\r\n      ancestors.reduce((oldAncestor, newAncestor) => {\r\n        // set the exited state in the history of all ancestors\r\n        history[DEEP][newAncestor] = state_from_name;\r\n        history[SHALLOW][newAncestor] = oldAncestor;\r\n\r\n        return newAncestor\r\n      }, state_from_name);\r\n\r\n    return history\r\n  }\r\n}\r\n\r\n/**\r\n * for all parentState, computes history(parentState), understood as the last control state descending from the\r\n * parent state. Last can be understood two ways : DEEP and SHALLOW. Deep history state refer to the last atomic\r\n * control state which is a children of the parent state and was exited. Shallow history states refer to the last\r\n * control state which is a direct child of the parent state and was exited.\r\n * @param {FSM_States} states\r\n * @param {Array<ControlState>} controlStateSequence Sequence of control states which has been entered and exited,\r\n * and from which the history must be injected\r\n * @param {DEEP | SHALLOW} historyType\r\n * @param {ControlState} historyParentState\r\n * @returns {Object.<DEEP|SHALLOW, Object.<ControlState, ControlState>>}\r\n */\r\nexport function computeHistoryState(states, controlStateSequence, historyType, historyParentState) {\r\n  // NOTE : we compute the whole story every time. This is inefficient, but for now sufficient\r\n  const {stateList, stateAncestors} = computeHistoryMaps(states);\r\n  let history = initHistoryDataStructure(stateList);\r\n  history = controlStateSequence.reduce(\r\n    (history, controlState) => updateHistory(history, stateAncestors, controlState),\r\n    history\r\n  );\r\n\r\n  return history[historyType][historyParentState]\r\n}\r\n\r\nexport function findInitTransition(transitions) {\r\n  return transitions.find(transition => {\r\n    return transition.from === INIT_STATE && transition.event === INIT_EVENT\r\n  })\r\n}\r\n\r\nexport function tryCatch(fn, errCb) {\r\n  return function tryCatch(...args) {\r\n    try {\r\n      return fn.apply(fn, args);\r\n    }\r\n    catch (e) {\r\n      return errCb(e, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport function tryCatchMachineFn(fnType, fn, argsDesc = []) {\r\n  return tryCatch(fn, (e, args) => {\r\n    const err = new Error(e);\r\n    const fnName = getFunctionName(fn);\r\n    // NOTE : we concatenate causes but not `info`\r\n    const probableCause = FUNCTION_THREW_ERROR(fnName, fnType);\r\n    err.probableCause = e.probableCause ? [e.probableCause, probableCause].join('\\n') : probableCause;\r\n\r\n    const info = {\r\n      fnName,\r\n      params: argsDesc.reduce((acc, argDesc, index) => {\r\n        return acc[argDesc] = args[index], acc\r\n      }, {})\r\n    };\r\n    err.info = e.info ? [].concat([e.info]).concat([info]) : info;\r\n\r\n    return err\r\n  })\r\n}\r\n\r\nexport function getFunctionName(actionFactory) {\r\n  return actionFactory.name || actionFactory.displayName || 'anonymous'\r\n}\r\n\r\n/**\r\n *\r\n * @param {function: true | Error} contract Contract returns either true (fulfilled contract) or an Error with an\r\n * optional info properties to give more details about the cause of the error\r\n * @param {Array} arrayParams Parameters to be passed to the conract\r\n * @returns {undefined|{when, location, info, message, ...}} if the contract is fulfilled\r\n * @throws if the contract fails\r\n */\r\nexport function assert(contract, arrayParams) {\r\n  const contractName = contract.name ||contract.name.displayName || \"\";\r\n  const isFulfilledOrError = contract.apply(null, arrayParams);\r\n  if (isFulfilledOrError === true) return void 0\r\n  else {\r\n    return {\r\n      ...isFulfilledOrError,\r\n      when: `Checking contract`,\r\n      message: [isFulfilledOrError.message, `failed contract ${contractName}`].join(\"\\n\"),\r\n      info: isFulfilledOrError.info,\r\n    }\r\n  }\r\n}\r\n\r\nexport function notifyThrows(console, error) {\r\n  console.error(error);\r\n  error.probableCause && console.error(`Probable cause: ${error.probableCause}`);\r\n  error.info && console.error(`ERROR: additional info`, error.info);\r\n}\r\n\r\n/**\r\n * false iff no errors or invalid actions\r\n * if not throws an exception\r\n * @param {{debug, console}} notify\r\n * @param {*} execInfo Information about the call - should include the function, and the parameters for the function\r\n * call\r\n * @param {Actions | Error} actionResultOrError\r\n * @param {function} throwFn handles when the action factory throws during its execution\r\n * @param {function} invalidResultFn handles when the action factory returns invalid actions\r\n * @returns {boolean}\r\n * @param postCondition\r\n */\r\nexport function handleFnExecError(notify, execInfo, actionResultOrError, postCondition, throwFn, invalidResultFn) {\r\n  const {debug, console} = notify;\r\n\r\n  if (debug && actionResultOrError instanceof Error) {\r\n    throwFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else if (debug && !postCondition(actionResultOrError)) {\r\n    invalidResultFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else return false\r\n}\r\n\r\nexport function notifyAndRethrow({debug, console}, actionResultOrError) {\r\n  notifyThrows(console, actionResultOrError)\r\n  throw actionResultOrError\r\n}\r\n\r\nexport function throwIfInvalidActionResult({debug, console}, actionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: actionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidGuardResult({debug, console}, resultOrError, exec) {\r\n  const predName = getFunctionName(exec.predicate);\r\n  const error = new Error(INVALID_PREDICATE_EXECUTED(predName, PREDICATE_DESC));\r\n  error.info = {\r\n    predicateName: predName,\r\n    params: exec,\r\n    returned: resultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidEntryActionResult({debug, console}, exitActionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ENTRY_ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: exitActionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function isActions(obj) {\r\n  return obj && `updates` in obj && `outputs` in obj\r\n    && Array.isArray(obj.outputs)\r\n  // && Array.isArray(obj.updates)\r\n  // !! does not have to be arrays. HAs to be anything that is accepted by updateState\r\n}\r\n\r\n/**\r\n * That is a Either contract, not a Boolean contract!\r\n * @param obj\r\n * @returns {boolean|Error}\r\n */\r\nexport function isEventStruct(obj) {\r\n  let trueOrError;\r\n  if (!obj || typeof obj !== 'object') {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `not an object!`}\r\n  }\r\n  else if (Object.keys(obj).length > 1) {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `Event objects must have only one key which is the event name!`}\r\n  }\r\n  else trueOrError = true;\r\n\r\n  return trueOrError\r\n}\r\n\r\nexport function isError(obj) {\r\n  return obj instanceof Error\r\n}\r\n\r\nexport function destructureEvent(obj) {\r\n  const eventName = Object.keys(obj)[0];\r\n  const eventData = obj[eventName];\r\n\r\n  return {eventName, eventData}\r\n}\r\n\r\nexport function formatUndefinedInJSON(obj){\r\n  return JSON.stringify(obj, (key,value)=> {if (value === undefined) return \"undefined\"; else return value})\r\n}\r\n\r\nexport class KinglyError extends Error {\r\n  constructor(m, console, tracer) {\r\n    super(m && m.message || \"\");\r\n    this.name = `KinglyError`;\r\n    this.stack = m && m.stack || this.stack;\r\n    this.errors = m;\r\n    const { when, location, info, message } = m || {};\r\n    const fm = `At ${location}: ${when} => ${message}`;\r\n    const infoMsg = info ? `See extra info in console` : \"\";\r\n    const fullMsg = [fm, infoMsg].join(\"\\n\");\r\n    // this.message = fullMsg;\r\n    console && console.error(fullMsg);\r\n    info && console && console.info(info);\r\n  }\r\n}\r\n","import {\r\n    emptyConsole,\r\n    findInitTransition,\r\n    getAncestorMap,\r\n    getEventTransitionsMaps,\r\n    getHistoryStatesMap,\r\n    getHistoryUnderlyingState,\r\n    getStatesPath,\r\n    getStatesTransitionsMap,\r\n    getStateEventTransitionsMaps,\r\n    getStatesType,\r\n    getTargetStatesMap,\r\n    isActionFactory,\r\n    isControlState,\r\n    isEvent,\r\n    isFunction,\r\n    isHistoryControlState,\r\n    noop\r\n} from \"./helpers\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\nimport {CONTRACTS_EVAL, INIT_EVENT, INIT_STATE} from \"./properties\"\r\n\r\n// Contracts\r\n\r\n// S2. State names must be unique\r\nexport const noDuplicatedStates = {\r\n    name: 'noDuplicatedStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {getLabel} = objectTreeLenses;\r\n        const traverse = {\r\n            strategy: PRE_ORDER,\r\n            seed: {duplicatedStates: [], statesHashMap: {}},\r\n            visit: (acc, traversalState, tree) => {\r\n                const {duplicatedStates, statesHashMap} = acc;\r\n                const treeLabel = getLabel(tree);\r\n                const controlState = Object.keys(treeLabel)[0];\r\n                if (controlState in statesHashMap) {\r\n                    return {\r\n                        duplicatedStates: duplicatedStates.concat(controlState),\r\n                        statesHashMap\r\n                    }\r\n                }\r\n                else {\r\n                    return {\r\n                        duplicatedStates,\r\n                        statesHashMap: (statesHashMap[controlState] = \"\", statesHashMap)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const {duplicatedStates} = traverseObj(traverse, fsmDef.states);\r\n\r\n        const isFulfilled = duplicatedStates.length === 0;\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `State names must be unique! Found duplicated state names. Cf. log`,\r\n                info: {duplicatedStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S1. State name cannot be a reserved state name (for now only INIT_STATE)\r\nexport const noReservedStates = {\r\n    name: 'noReservedStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesType}) => {\r\n        return {\r\n            isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,\r\n            blame: {\r\n                message: `You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log`,\r\n                info: {reservedStates: [INIT_STATE], statesType}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S4. At least one control state (other than the initial state) muat be declared\r\nexport const atLeastOneState = {\r\n    name: 'atLeastOneState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesType}) => {\r\n        return {\r\n            isFulfilled: Object.keys(statesType).length > 0,\r\n            blame: {\r\n                message: `Machine configuration must define at least one control state! Cf. log`,\r\n                info: {statesType}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S5. check initial control state is a defined state in states\r\nexport const isInitialControlStateDeclared = {\r\n    name: 'isInitialControlStateDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition, statesType}) => {\r\n        const {initialControlState, transitions} = fsmDef;\r\n        const stateList = Object.keys(statesType);\r\n        if (initialControlState) {\r\n            return {\r\n                isFulfilled: stateList.indexOf(initialControlState) > -1,\r\n                blame: {\r\n                    message: `Configured initial control state must be a declared state. Cf. log`,\r\n                    info: {initialControlState, declaredStates: stateList}\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n\r\n    },\r\n};\r\n\r\n// E0. `fsmDef.events` msut be an array of strings\r\nexport const eventsAreStrings = {\r\n    name: 'eventsAreStrings',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        return {\r\n            isFulfilled: fsmDef.events.every(x => typeof x === 'string'),\r\n            blame: {\r\n                message: `Events must be an array of strings!`,\r\n                info: {events: fsmDef.events}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const validInitialConfig = {\r\n    name: 'validInitialConfig',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition}) => {\r\n        const {initialControlState} = fsmDef;\r\n\r\n        if (initTransition && initialControlState) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!`,\r\n                    info: {initialControlState, initTransition}\r\n                }\r\n            }\r\n        }\r\n        else if (!initTransition && !initialControlState) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?`,\r\n                    info: {initialControlState, initTransition}\r\n                }\r\n            }\r\n        }\r\n        else return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n    },\r\n};\r\n\r\n// T1. There must be configured at least one transition away from the initial state\r\n// T2. A transition away from the initial state can only be triggered by the initial event\r\n// T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history\r\n// state as target\r\n// T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We\r\n// can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and\r\n// debugging!. So enforce ACTIONS to be identity\r\nexport const validInitialTransition = {\r\n    name: 'validInitialTransition',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition}) => {\r\n        const {initialControlState, transitions} = fsmDef;\r\n        const initTransitions = transitions.reduce((acc, transition) => {\r\n            transition.from === INIT_STATE && acc.push(transition);\r\n            return acc\r\n        }, []);\r\n        // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!\r\n        // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't\r\n        // enforce the part of the contract which require to have no actions for initial transitions...\r\n        const isFulfilled =\r\n            (initialControlState && !initTransition) ||\r\n            (!initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT\r\n                && (\r\n                    isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY\r\n                    || areCconditionalTransitions(initTransition)\r\n                    // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)\r\n                )\r\n            );\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Invalid configuration for initial transition! Cf. log`,\r\n                info: {initTransition, initTransitions, initialControlState}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound\r\n// state or A is the initial state\r\nexport const initEventOnlyInCompoundStates = {\r\n    name: 'initEventOnlyInCompoundStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const atomicStates = Object.keys(statesType).filter(controlState => !statesType[controlState]);\r\n        const atomicInitTransitions = atomicStates.map(\r\n            atomicState => ({\r\n                [atomicState]: statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]\r\n            })\r\n        ).filter(obj => Object.values(obj)[0]);\r\n\r\n        const hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0\r\n\r\n        return {\r\n            isFulfilled: hasInitEventOnlyInCompoundStates,\r\n            blame: {\r\n                message: `Found at least one atomic state with an entry transition! That is forbidden! Cf. log`,\r\n                info: {initTransitions: atomicInitTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined\r\n// T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have a history state as target\r\n// NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop\r\n// T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have the history state as target and has a target control state that is one of its substates (no\r\n// out-of-hierarchy INIT transitions)\r\nexport const validInitialTransitionForCompoundState = {\r\n    name: 'validInitialTransitionForCompoundState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const compoundStates = Object.keys(statesType).filter(controlState => statesType[controlState]);\r\n        const compoundStatesInitTransitions = compoundStates.map(\r\n            compoundState => statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT]);\r\n\r\n        const allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);\r\n\r\n        if (!allHaveInitTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state without an entry transition! Cf. log`,\r\n                    info: {\r\n                        hasEntryTransitions: compoundStates.map(\r\n                            state => ({[state]: !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT])}))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const allHaveValidInitTransitions = allHaveInitTransitions &&\r\n            compoundStatesInitTransitions.every(initTransition => {\r\n                const {guards, to} = initTransition;\r\n                if (!guards) {\r\n                    //  T7a\r\n                    return typeof to === 'string'\r\n                }\r\n                else {\r\n                    const targetStates = guards.map(guard => guard.to);\r\n                    return targetStates.every(targetState => typeof targetState === 'string')\r\n                }\r\n            });\r\n        if (!allHaveValidInitTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log`,\r\n                    info: {entryTransitions: compoundStatesInitTransitions}\r\n                }\r\n            }\r\n        }\r\n        ;\r\n\r\n        const allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions &&\r\n            compoundStatesInitTransitions.every(initTransition => {\r\n                const {from, guards, to} = initTransition;\r\n\r\n                // Don't forget to also eliminate the case when from = to\r\n                // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the\r\n                // other from declared states\r\n                if (!guards){\r\n                    return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n                }\r\n                else {\r\n                    const targetStates = guards.map(guard => guard.to);\r\n                    return targetStates.every(to => {\r\n                        return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n                    })\r\n                }\r\n            });\r\n        if (!allHaveTargetStatesWithinHierarchy) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! `,\r\n                    info: {states: fsmDef.states, statesPath, entryTransitions: compoundStatesInitTransitions}\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            isFulfilled: true,\r\n            blame: void 0\r\n        }\r\n    },\r\n};\r\n\r\n// T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X\r\n// T24. Check that we have this implicitly : Compound states must not have eventless transitions\r\n// defined on them (would introduce ambiguity with the INIT transition).\r\nexport const validEventLessTransitions = {\r\n    name: 'validEventLessTransitions',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const stateList = Object.keys(statesType);\r\n        const failingOriginControlStates = stateList.map(state => {\r\n            return {\r\n                [state]: statesTransitionsMap[state] &&\r\n                `${void 0}` in statesTransitionsMap[state] &&\r\n                Object.keys(statesTransitionsMap[state]).length !== 1\r\n            }\r\n        }).filter(obj => Object.values(obj)[0] !== void 0 && Object.values(obj)[0]);\r\n\r\n        const isFulfilled = failingOriginControlStates.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found at least one control state without both an eventless transition and a competing transition! Cf. log`,\r\n                info: {failingOriginControlStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together\r\n// in a single array and there cannot be two transition rows showcasing A -ev-> * transitions\r\nexport const allStateTransitionsOnOneSingleRow = {\r\n    name: 'allStateTransitionsOnOneSingleRow',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const statesTransitionsInfo = originStateList.reduce((acc, state) => {\r\n            const events = Object.keys(stateEventTransitionsMaps[state]);\r\n            const wrongEventConfig = events.filter(event => stateEventTransitionsMaps[state][event].length > 1);\r\n            if (wrongEventConfig.length > 0) {\r\n                acc[state] = wrongEventConfig;\r\n            }\r\n\r\n            return acc\r\n        }, {});\r\n\r\n        const isFulfilled = Object.keys(statesTransitionsInfo).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log`,\r\n                info: {statesTransitionsInfo}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A\r\n// with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.\r\n// The event `ev` could trigger a transition towards either B or C\r\nexport const noConflictingTransitionsWithAncestorState = {\r\n    name: 'noConflictingTransitionsWithAncestorState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, eventTransitionsMaps, ancestorMap}) => {\r\n        const eventList = Object.keys(eventTransitionsMaps).filter(ev => ev !== INIT_EVENT && ev !== void 0);\r\n        const eventTransitionsInfo = eventList.reduce((acc, event) => {\r\n            const states = Object.keys(eventTransitionsMaps[event]);\r\n            // The wrongly configured states are those which have an ancestor also in the transition map for the same event\r\n            const wrongStateConfig = states\r\n                .filter(state => state !== INIT_STATE)\r\n                .map(state => ancestorMap[state] && {\r\n                    [state]: ancestorMap[state].find(\r\n                        ancestorState => states.indexOf(ancestorState) > -1\r\n                    )\r\n                })\r\n                // removing cases : undefined and {[state]: undefined}\r\n                .filter(obj => {\r\n                    return obj && Object.values(obj).filter(Boolean).length > 0\r\n                });\r\n\r\n            if (wrongStateConfig.length > 0) {\r\n                acc[event] = wrongStateConfig;\r\n            }\r\n\r\n            return acc\r\n        }, {});\r\n\r\n        const isFulfilled = Object.keys(eventTransitionsInfo).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log`,\r\n                info: {eventTransitionsInfo}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T16.a History states must be target states\r\nexport const isHistoryStatesTargetStates = {\r\n    name: 'isHistoryStatesTargetStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {}) => {\r\n        const wrongHistoryStates = fsmDef.transitions.reduce((acc, transition) => {\r\n            return isHistoryControlState(transition.from)\r\n                ? acc.concat(transition)\r\n                : acc\r\n        }, []);\r\n\r\n        const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log`,\r\n                info: {wrongHistoryStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T16.b History states must be compound states\r\nexport const isHistoryStatesCompoundStates = {\r\n    name: 'isHistoryStatesCompoundStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, statesType}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const wrongHistoryStates = originStateList.map(originState => {\r\n            if (originState === INIT_STATE) return []\r\n\r\n            const events = Object.keys(stateEventTransitionsMaps[originState]);\r\n\r\n            return events.reduce((acc, event) => {\r\n                // I should only ever have one transition, that is checked in another contract\r\n                // !! if there are several transitions, we may have a false positive, but that is ok\r\n                // When the other contract will fail and the issue will be solved, and app will be rerun,\r\n                // this will be recomputed correctly\r\n                const transition = stateEventTransitionsMaps[originState][event][0];\r\n                const {guards, to} = transition;\r\n                if (!guards) {\r\n                    // Reminder: statesType[controlState] === true iff controlState is compound state\r\n                    return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n                        ? acc.concat(transition)\r\n                        : acc\r\n                }\r\n                else {\r\n                    return guards.reduce((acc, guard) => {\r\n                        const {to} = guard;\r\n\r\n                        return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n                            ? acc.concat(transition)\r\n                            : acc\r\n                    }, acc)\r\n                }\r\n            }, [])\r\n        })\r\n            .reduce((acc, x) => acc.concat(x), []);\r\n\r\n        const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log`,\r\n                info: {wrongHistoryStates, states: fsmDef.states}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T17 An history state must refer to an existing state\r\nexport const isHistoryStatesExisting = {\r\n    name: 'isHistoryStatesExisting',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {historyStatesMap, statesType}) => {\r\n        const invalidTransitions = Array.from(historyStatesMap.entries())\r\n            .map(([historyState, flatTransitions]) => {\r\n                return !(historyState in statesType) && {historyState, flatTransitions}\r\n            })\r\n            .filter(Boolean);\r\n\r\n        const howMany = Object.keys(invalidTransitions).length;\r\n        const isFulfilled = howMany === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found ${howMany} history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition.`,\r\n                info: {invalidTransitions, states: fsmDef.states}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport function isInconditionalTransition(transition) {\r\n    const {from, event, guards, to, action} = transition;\r\n\r\n    return typeof guards === `${void 0}` && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action)\r\n}\r\n\r\nexport function isValidGuard(guard) {\r\n    const {to, predicate, action} = guard;\r\n\r\n    return to && isControlState(to) && isFunction(predicate) && isActionFactory(action)\r\n}\r\n\r\nexport function areCconditionalTransitions(transition) {\r\n    const {from, event, guards, to} = transition;\r\n\r\n    return guards && Array.isArray(guards) && guards.length > 0\r\n        && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard)\r\n}\r\n\r\nexport const isValidFsmDef = {\r\n    name: 'isValidFsmDef',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {transitions, states, events, initialExtendedState} = fsmDef;\r\n        const isValidTransitions = transitions && Array.isArray(transitions);\r\n        const isValidStates = states && typeof(states) === 'object';\r\n        const isValidEvents = events && Array.isArray(events);\r\n        if (!isValidTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The transitions property for a machine definition must be an array!`,\r\n                    info: {transitions}\r\n                }\r\n            }\r\n        }\r\n        else if (!isValidStates) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The states property for a machine definition must be an object!`,\r\n                    info: {states}\r\n                }\r\n            }\r\n        }\r\n        else if (!isValidEvents) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The events property for a machine definition must be an array!`,\r\n                    info: {events}\r\n                }\r\n            }\r\n        }\r\n        // NOTE : we do not deal with initialExtendedState, initialControlState and settings\r\n        // this is done in other contracts\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n    },\r\n}\r\n\r\n// T18. Transitions have a valid format, and are either inconditional (no guards) or conditional\r\n// events are strings\r\n// guards are functions\r\n// action factories are functions\r\nexport const haveTransitionsValidTypes = {\r\n    name: 'haveTransitionsValidTypes',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {transitions} = fsmDef;\r\n        const wrongTransitions = transitions\r\n            .map((transition, transitionIndex) => {\r\n                return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {\r\n                    transition,\r\n                    index: transitionIndex\r\n                }\r\n            })\r\n            .filter(Boolean)\r\n\r\n        const howMany = Object.keys(wrongTransitions).length;\r\n        const isFulfilled = howMany === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found ${howMany} transitions with invalid format! Check logs for more details.`,\r\n                info: {wrongTransitions, transitions}\r\n            }\r\n        }\r\n    },\r\n}\r\n\r\nexport const areEventsDeclared = {\r\n    name: 'areEventsDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {eventTransitionsMaps}) => {\r\n        const eventList = Object.keys(eventTransitionsMaps);\r\n        const declaredEventList = fsmDef.events;\r\n        const eventsDeclaredButNotTriggeringTransitions = declaredEventList\r\n            .map(declaredEvent => eventList.indexOf(declaredEvent) === -1 && declaredEvent)\r\n            .filter(Boolean);\r\n        const eventsNotDeclaredButTriggeringTransitions = eventList\r\n            .map(triggeringEvent => declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent)\r\n            .filter(Boolean)\r\n            // Filtering out init events which must not be declared, being reserved events\r\n            // Filtering out undefined events linked to eventless transitions\r\n            .filter(ev => ev !== INIT_EVENT && ev !== 'undefined')\r\n\r\n        const isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0\r\n            && eventsNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `All declared events must be used in transitions. All events used in transition must be declared! Cf. log`,\r\n                info: {eventsDeclaredButNotTriggeringTransitions, eventsNotDeclaredButTriggeringTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const areStatesDeclared = {\r\n    name: 'areStatesDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, targetStatesMap, statesType}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const targetStateList = Array.from(targetStatesMap.keys()).filter(x => typeof x !== 'object');\r\n        const stateList = Object.keys([originStateList, targetStateList].reduce((acc, stateList) => {\r\n            stateList.forEach(state => acc[state] = true)\r\n            return acc\r\n        }, {}));\r\n        const declaredStateList = Object.keys(statesType);\r\n        const statesDeclaredButNotTriggeringTransitions = declaredStateList\r\n            .map(declaredState => stateList.indexOf(declaredState) === -1 && declaredState)\r\n            .filter(Boolean);\r\n        const statesNotDeclaredButTriggeringTransitions = stateList\r\n            .map(stateInTransition =>\r\n                stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition)\r\n            .filter(Boolean);\r\n\r\n        const isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0\r\n            && statesNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `All declared states must be used in transitions. All states used in transition must be declared! Cf. log`,\r\n                info: {statesDeclaredButNotTriggeringTransitions, statesNotDeclaredButTriggeringTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T25. SS1 - as of v0.13 settings is no longer mandatory\r\nexport const isValidSettings = {\r\n    name: 'isValidSettings',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef) => {\r\n        return {\r\n            isFulfilled: true,\r\n            blame: void 0\r\n        }\r\n    },\r\n};\r\n\r\n// T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not\r\nexport const isInitialStateOriginState = {\r\n    name: 'isInitialStateOriginState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {targetStatesMap}) => {\r\n\r\n        if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one transition with the initial state as target state! CF. log`,\r\n                    info: {targetStates: Array.from(targetStatesMap.keys()), transitions: fsmDef.transitions}\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of\r\n// little practical value, though being a possible source of ambiguity or infinite loops)\r\n// A -_> A impossible on compound states because there is A -INIT-> X\r\n// so only possibility is A -_> A with A atomic state\r\nexport const isValidSelfTransition = {\r\n    name: 'isValidSelfTransition',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {targetStatesMap, statesType}) => {\r\n        const targetStates = Array.from(targetStatesMap.keys());\r\n        const wrongSelfTransitions = targetStates\r\n            .map(targetState => {\r\n                const flatTransitions = targetStatesMap.get(targetState);\r\n                return flatTransitions\r\n                    .map(flatTransition => {\r\n                        const {from, event} = flatTransition;\r\n                        if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {\r\n                            return {state: targetState, flatTransition}\r\n                        }\r\n                    })\r\n                    .filter(Boolean)\r\n            })\r\n            .filter(x => x.length > 0);\r\n\r\n        return {\r\n            isFulfilled: wrongSelfTransitions.length === 0,\r\n            blame: {\r\n                message: `Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log`,\r\n                info: {wrongSelfTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const fsmContracts = {\r\n    injected: (fsmDef, settings) => {\r\n        return {\r\n            statesType: getStatesType(fsmDef.states),\r\n            initTransition: findInitTransition(fsmDef.transitions),\r\n            statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),\r\n            stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),\r\n            eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),\r\n            ancestorMap: getAncestorMap(fsmDef.states),\r\n            statesPath: getStatesPath(fsmDef.states),\r\n            historyStatesMap: getHistoryStatesMap(fsmDef.transitions),\r\n            targetStatesMap: getTargetStatesMap(fsmDef.transitions)\r\n        }\r\n    },\r\n    description: 'FSM structure',\r\n    contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates],\r\n};\r\n\r\n/**\r\n * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may\r\n * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing\r\n * contract data structure include relevant information about the failing contract, in particular the contract name,\r\n * the associated error message and additional info expliciting the error message.\r\n * @param contractsDef\r\n * @param settings\r\n * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}\r\n */\r\nfunction makeContractHandler(contractsDef, settings) {\r\n    const console = settings && settings.debug && settings.debug.console || emptyConsole;\r\n    const trace = settings && settings.debug && settings.debug.trace || noop;\r\n    const contractsDescription = contractsDef.description;\r\n\r\n    return function checkContracts(...args) {\r\n        const failingContracts = [];\r\n        const computedArgs = contractsDef.injected.apply(null, args);\r\n        const isFulfilled = contractsDef.contracts.reduce((acc, contract) => {\r\n            const {name: contractName, predicate, shouldThrow} = contract;\r\n            const fullArgs = args.concat(computedArgs);\r\n            const {isFulfilled, blame} = predicate.apply(null, fullArgs);\r\n            const blameMessageHeader = `${contractsDescription} FAILS ${contractName}!`;\r\n            const {message, info} = blame || {};\r\n\r\n            if (isFulfilled) return acc\r\n            else {\r\n                failingContracts.push({name: contractName, message, info});\r\n                console.error(blameMessageHeader);\r\n                console.error([contractName, message].join(': '));\r\n                console.debug('Supporting error data:', info);\r\n\r\n                if (shouldThrow) throw new Error([blameMessageHeader, `check console for information!`].join('\\n'))\r\n                else {\r\n                    return false\r\n                }\r\n            }\r\n        }, true)\r\n\r\n        const contractsEval = {isFulfilled, failingContracts};\r\n        trace({[CONTRACTS_EVAL]: contractsEval})\r\n\r\n        return contractsEval\r\n    }\r\n}\r\n\r\nexport const fsmContractChecker = (fsmDef, settings, fsmContracts) => makeContractHandler(fsmContracts, settings)(fsmDef, settings);\r\n\r\n// Terminology\r\n// . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`\r\n// For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,\r\n// guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition\r\n// uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be\r\n// referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.\r\n// . We write A < B if A is a substate of B, with the implication that B is hence a compound state\r\n// . We write A !< B if A is a direct substate of B\r\n// . We write A. !< B if A is a substate of B, and A is also an atomic state\r\n// . We write A -ev-> B to denote a transition from A to B triggered by `ev`\r\n\r\n// Behaviour\r\n// B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly\r\n// returning to the same state)\r\n// ENFORCED by T13, T4, T10, necessary for generative testing\r\n// B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress\r\n// the state machine.\r\n// NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird\r\n// ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice\r\n// B8. It is possible to reach any states\r\n// NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal\r\n","import {\r\n  ACTION_IDENTITY,\r\n  AUTO_EVENT, DEBUG_MSG,\r\n  DEEP,\r\n  ERROR_MSG,\r\n  history_symbol,\r\n  INIT_EVENT, INIT_INPUT_MSG,\r\n  INIT_STATE, INPUT_MSG, INTERNAL_INPUT_MSG, INTERNAL_OUTPUTS_MSG, MACHINE_CREATION_ERROR_MSG,\r\n  OUTPUTS_MSG,\r\n  SHALLOW,\r\n  STATE_PROTOTYPE_NAME,\r\n  WARN_MSG\r\n} from \"./properties\";\r\nimport {\r\n  arrayizeOutput,\r\n  assert,\r\n  computeHistoryMaps,\r\n  destructureEvent,\r\n  emptyConsole,\r\n  emptyTracer,\r\n  findInitTransition,\r\n  get_fn_name,\r\n  getFsmStateList,\r\n  initHistoryDataStructure,\r\n  isActions,\r\n  isEventStruct,\r\n  isHistoryControlState,\r\n  keys, KinglyError,\r\n  updateHistory,\r\n  wrap\r\n} from \"./helpers\";\r\nimport {fsmContractChecker} from \"./contracts\"\r\n\r\nfunction alwaysTrue() {\r\n  return true\r\n};\r\n\r\n/**\r\n * Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state` : {Object<String,Boolean>} Hash whose properties (state names) are matched with\r\n * whether that state is a nested state\r\n * `hash_states` : Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hash_states: {}, is_group_state: {}}}\r\n */\r\nfunction build_nested_state_structure(states) {\r\n  const root_name = \"State\";\r\n  let hash_states = {};\r\n  let is_group_state = {};\r\n\r\n  // Add the starting state\r\n  states = {nok: states};\r\n\r\n  ////////\r\n  // Helper functions\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hash_states[state_name] = new curr_constructor();\r\n      hash_states[state_name].name = state_name;\r\n      const parent_name = (hash_states[state_name].parent_name = get_fn_name(\r\n        curr_constructor\r\n      ));\r\n      hash_states[state_name].root_name = root_name;\r\n\r\n      if (typeof state_config === \"object\") {\r\n        is_group_state[state_name] = true;\r\n        const curr_constructor_new = function () {\r\n        };\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hash_states[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    });\r\n  }\r\n\r\n  function State() {\r\n  }\r\n\r\n  State.prototype = {\r\n    current_state_name: INIT_STATE\r\n  };\r\n\r\n  hash_states[INIT_STATE] = new State();\r\n  hash_states[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hash_states: hash_states,\r\n    is_group_state: is_group_state\r\n  };\r\n}\r\n\r\nexport function normalizeTransitions(fsmDef) {\r\n  const {initialControlState, transitions} = fsmDef;\r\n  const initTransition = findInitTransition(transitions);\r\n\r\n  if (initialControlState) {\r\n    return transitions\r\n      .concat([{from: INIT_STATE, event: INIT_EVENT, to: initialControlState, action: ACTION_IDENTITY}])\r\n  }\r\n  else if (initTransition) {\r\n    return transitions\r\n  }\r\n}\r\n\r\n// Alias for compatibility before deprecating entirely create_state_machine\r\n// TODO: this is not used anymore apparently so remove\r\nexport function create_state_machine(fsmDef, settings) {\r\n  return createStateMachine(fsmDef, settings)\r\n}\r\n\r\n/**\r\n * Creates an instance of state machine from a set of states, transitions, and accepted events. The initial\r\n * extended state for the machine is included in the machine definition.\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @return {function(*=)}\r\n */\r\nexport function createStateMachine(fsmDef, settings) {\r\n  const {\r\n    states: control_states,\r\n    events,\r\n    // transitions ,\r\n    initialExtendedState,\r\n    updateState: userProvidedUpdateStateFn,\r\n  } = fsmDef;\r\n  const {debug, devTool, displayName} = settings || {};\r\n  const checkContracts = debug && debug.checkContracts || void 0;\r\n  let console = debug && debug.console || emptyConsole;\r\n  let tracer = devTool && devTool.tracer || emptyTracer;\r\n  const throwKinglyError = obj => {\r\n    throw new KinglyError(obj, console, tracer)\r\n  };\r\n\r\n  // Conracts must be checked before we start doing all sort of computations\r\n  if (checkContracts) {\r\n    const {failingContracts} = fsmContractChecker(fsmDef, settings, checkContracts);\r\n    try {\r\n      if (failingContracts.length > 0) throwKinglyError({\r\n        when: `Attempting to create a Kingly machine`,\r\n        location: `createStateMachine`,\r\n        info: {fsmDef, settings, failingContracts},\r\n        message: `I found that one or more Kingly contracts are violated!`\r\n      })\r\n    }\r\n    catch (e) {\r\n      // Do not break the program, errors should be passed to console and dev tool\r\n      tracer({\r\n        type: MACHINE_CREATION_ERROR_MSG,\r\n        trace: {\r\n          info: e.errors,\r\n          message: e.message,\r\n          machineState: {cs: INIT_STATE, es: extendedState, hs: history}\r\n        }\r\n      });\r\n      return e\r\n    }\r\n  }\r\n\r\n  const wrappedUpdateState = (extendedState, updates) => {\r\n    const fnName = userProvidedUpdateStateFn.name || userProvidedUpdateStateFn.displayName || \"\";\r\n\r\n    try {\r\n      return userProvidedUpdateStateFn(extendedState, updates)\r\n    }\r\n    catch (e) {\r\n      throwKinglyError({\r\n        when: `Executing updateState function ${fnName}`,\r\n        location: `createStateMachine > wrappedUpdateState`,\r\n        info: {extendedState, updates},\r\n        message: e.message,\r\n        stack: e.stack,\r\n      })\r\n    }\r\n  };\r\n  const transitions = normalizeTransitions(fsmDef);\r\n\r\n  // Create the nested hierarchy\r\n  const hash_states_struct = build_nested_state_structure(control_states);\r\n\r\n  // This will be the extended state object which will be updated by all actions and on which conditions\r\n  // will be evaluated It is safely contained in a closure so it cannot be accessed in any way\r\n  // outside the state machine.\r\n  // Note the extended state is modified by the `settings.updateState` function, which should not modify\r\n  // the extended state object. There is hence no need to do any cloning.\r\n  let extendedState = initialExtendedState;\r\n\r\n  // history maps\r\n  const {stateList, stateAncestors} = computeHistoryMaps(control_states);\r\n  let history = initHistoryDataStructure(stateList);\r\n\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has a init transition defined\r\n  let is_init_state = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined\r\n  // that would be init transitions + eventless transitions\r\n  let is_auto_state = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state is a group of state or not\r\n  const is_group_state = hash_states_struct.is_group_state;\r\n  let hash_states = hash_states_struct.hash_states;\r\n\r\n  function assertContract(contract, arrayParams) {\r\n    const hasFailed = assert(contract, arrayParams);\r\n    if (checkContracts && hasFailed) {\r\n      throwKinglyError(hasFailed)\r\n    }\r\n\r\n    return void 0\r\n  }\r\n\r\n  function getCurrentControlState() {\r\n    return hash_states[INIT_STATE].current_state_name\r\n  }\r\n\r\n  function send_event(event_struct, isExternalEvent) {\r\n    // TODO: maybe open a console.group and close it on return\r\n    assertContract(isEventStruct, [event_struct]);\r\n\r\n    const {eventName, eventData} = destructureEvent(event_struct);\r\n    const current_state = getCurrentControlState();\r\n\r\n    console.debug(\"send event\", event_struct);\r\n\r\n    // Edge case : INIT_EVENT sent and the current state is not the initial state\r\n    // We have to do this separately, as by construction the INIT_STATE is a\r\n    // super state of all states in the machine. Hence sending an INIT_EVENT\r\n    // would always execute the INIT transition by prototypal delegation\r\n    if (isExternalEvent && eventName === INIT_EVENT && current_state !== INIT_STATE) {\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: {eventName, eventData},\r\n          message: `The external event INIT_EVENT can only be sent when starting the machine!`,\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n      console.warn(`The external event INIT_EVENT can only be sent when starting the machine!`)\r\n\r\n      return null\r\n    }\r\n\r\n    const outputs = process_event(\r\n      hash_states_struct.hash_states,\r\n      eventName,\r\n\r\n      eventData,\r\n      extendedState\r\n    );\r\n\r\n    return outputs\r\n  }\r\n\r\n  function process_event(hash_states, event, event_data, extendedState) {\r\n    const current_state = hash_states[INIT_STATE].current_state_name;\r\n    const event_handler = hash_states[current_state][event];\r\n\r\n    if (event_handler) {\r\n      // CASE : There is a transition associated to that event\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event, event_data);\r\n      /* OUT : this event handler modifies the extendedState and possibly other data structures */\r\n      const {stop, outputs: rawOutputs} = event_handler(extendedState, event_data, current_state);\r\n      debug && !stop && console.warn(\"No guards have been fulfilled! We recommend to configure guards explicitly to\" +\r\n        \" cover the full state space!\")\r\n      const outputs = arrayizeOutput(rawOutputs);\r\n\r\n      // we read it anew as the execution of the event handler may have changed it\r\n      const new_current_state = hash_states[INIT_STATE].current_state_name;\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the current state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1: init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case event_data will carry on the data passed on from the last event (else we loose\r\n      // the extendedState?)\r\n      // 2. transitions with no events associated, only conditions (i.e. transient states)\r\n      // NOTE : the guard is to defend against loops occuring when an AUTO transition fails to advance and stays\r\n      // in the same control state!! But by contract that should never happen : all AUTO transitions should advance!\r\n      // TODO : test that case, what is happening? I should add a branch and throw!!\r\n      if (is_auto_state[new_current_state] && new_current_state !== current_state) {\r\n        // CASE : transient state with no triggering event, just conditions\r\n        // automatic transitions = transitions without events\r\n        const auto_event = is_init_state[new_current_state]\r\n          ? INIT_EVENT\r\n          : AUTO_EVENT;\r\n\r\n        tracer({\r\n          type: INTERNAL_INPUT_MSG,\r\n          trace: {\r\n            info: {eventName: auto_event, eventData: event_data},\r\n            event: {[auto_event]: event_data},\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        const nextOutputs = send_event({[auto_event]: event_data}, false);\r\n\r\n        tracer({\r\n          type: INTERNAL_OUTPUTS_MSG,\r\n          trace: {\r\n            outputs: nextOutputs,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        return [].concat(outputs).concat(nextOutputs);\r\n      } else return outputs;\r\n    } else {\r\n      // CASE : There is no transition associated to that event from that state\r\n      console.warn(`There is no transition associated to the event |${event}| in state |${current_state}|!`);\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: {received: {[event]: event_data}},\r\n          message: `There is no transition associated to the event |${event}| in state |${current_state}|!`,\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  function leave_state(from, extendedState, hash_states) {\r\n    // NOTE : extendedState is passed as a parameter for symetry reasons, no real use for it so far\r\n    const state_from = hash_states[from];\r\n    const state_from_name = state_from.name;\r\n\r\n    history = updateHistory(history, stateAncestors, state_from_name);\r\n\r\n    console.info(\"left state\", wrap(from));\r\n  }\r\n\r\n  function enter_next_state(to, updatedExtendedState, hash_states) {\r\n    let state_to;\r\n    let state_to_name;\r\n    // CASE : history state (H)\r\n    if (isHistoryControlState(to)) {\r\n      const history_type = to.deep ? DEEP : to.shallow ? SHALLOW : void 0;\r\n      const history_target = to[history_type];\r\n      // Edge case : history state (H) && no history (i.e. first time state is entered), target state\r\n      // is the entered state\r\n      // TODO: edge case should be init state for compound state, and check it is recursively descended,\r\n      // and error if the history target is an atomic state\r\n      // if (!is_auto_state(history_target)) throw `can't be atomic state`\r\n      // then by setting the compound state, it should evolve toward to init control state naturally\r\n      debug && console && !is_init_state[history_target] && console.error(`Configured a history state which does not relate to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration`);\r\n      state_to_name = history[history_type][history_target] || history_target;\r\n      state_to = hash_states[state_to_name];\r\n    }\r\n    else if (to) {\r\n      // CASE : normal state\r\n      state_to = hash_states[to];\r\n      state_to_name = state_to.name;\r\n    } else {\r\n      throwKinglyError (\"enter_state : unknown case! Not a state name, and not a history state to enter!\");\r\n    }\r\n    hash_states[INIT_STATE].current_state_name = state_to_name;\r\n\r\n    tracer({\r\n      type: DEBUG_MSG,\r\n      trace: {\r\n        message: isHistoryControlState(to)\r\n          ? `Entering history state for ${to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]}`\r\n          : `Entering state ${to}`,\r\n        machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n      }\r\n    });\r\n    debug && console.info(\"AND TRANSITION TO STATE\", state_to_name);\r\n    return state_to_name;\r\n  }\r\n\r\n  function start() {\r\n    tracer({\r\n      type: INIT_INPUT_MSG,\r\n      trace: {\r\n        info: {eventName: INIT_EVENT, eventData: initialExtendedState},\r\n        event: {[INIT_EVENT]: initialExtendedState},\r\n        machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n      }\r\n    });\r\n\r\n    return send_event({[INIT_EVENT]: initialExtendedState}, true);\r\n  }\r\n\r\n  transitions.forEach(function (transition) {\r\n    let {from, to, action, event, guards: arr_predicate} = transition;\r\n    // CASE : ZERO OR ONE condition set\r\n    if (!arr_predicate)\r\n      arr_predicate = [{predicate: void 0, to: to, action: action}];\r\n\r\n    // CASE : transition has a init event\r\n    // NOTE : there should ever only be one, but we don't enforce it here\r\n    if (event === INIT_EVENT) {\r\n      is_init_state[from] = true;\r\n    }\r\n\r\n    let from_proto = hash_states[from];\r\n\r\n    // CASE : automatic transitions : no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      is_auto_state[from] = true;\r\n    }\r\n    // CASE : automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (is_group_state[from] && is_init_state[from]) {\r\n      is_auto_state[from] = true;\r\n    }\r\n\r\n    // TODO : this seriously needs refactoring, that is one line in ramda\r\n    from_proto[event] = arr_predicate.reduce((acc, guard, index) => {\r\n        const action = guard.action || ACTION_IDENTITY;\r\n        const actionName = action.name || action.displayName || \"\";\r\n        const condition_checking_fn = (function (guard, settings) {\r\n          let condition_suffix = \"\";\r\n          // We add the `current_state` because the current control state might be different from\r\n          // the `from` field here This is the case for instance when we are in a substate, but\r\n          // through prototypal inheritance it is the handler of the prototype which is called\r\n          const condition_checking_fn = function (extendedState_, event_data, current_state) {\r\n            from = current_state || from;\r\n            const predicate = guard.predicate || alwaysTrue;\r\n            const predicateName = predicate.name || predicate.displayName || \"<anonymous>\";\r\n            const to = guard.to;\r\n            const shouldTransitionBeTaken = ((extendedState, event_data, settings) => {\r\n              try {\r\n                return predicate(extendedState, event_data, settings);\r\n              }\r\n              catch (e) {\r\n                throwKinglyError({\r\n                  when: `Executing predicate function ${predicateName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken`,\r\n                  info: {extendedState, event, event_data, settings, guard, from, to, index},\r\n                  message: [`Error occurred while processing event ${event} with target state ${to}`, e.message].join(\"\\n\"),\r\n                  stack: e.stack,\r\n                })\r\n              }\r\n            })(extendedState_, event_data, settings);\r\n\r\n            if (typeof shouldTransitionBeTaken !== \"boolean\") {\r\n              throwKinglyError({\r\n                when: `Executing predicate function ${predicateName}`,\r\n                location: `createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult`,\r\n                info: {event, guard, from, to, index, shouldTransitionBeTaken},\r\n                message: `Guard index ${index} with name ${predicateName} did not return a boolean!`,\r\n              })\r\n            }\r\n\r\n            if (shouldTransitionBeTaken) {\r\n              // CASE : guard for transition is fulfilled so we can execute the actions...\r\n              console.info(\"IN STATE \", from);\r\n              if (guard.predicate) {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `The guard ${predicateName} is fulfilled`,\r\n                    info: {eventData: event_data, from, action: actionName, to},\r\n                    machineState: {cs: current_state, es: extendedState_, hs: history}\r\n                  }\r\n                });\r\n                console.info(`CASE: guard ${predicate.name} for transition is fulfilled`);\r\n              }\r\n              else {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `Evaluating transition with no guards`,\r\n                    info: {eventData: event_data, from, action: actionName, to},\r\n                    machineState: {cs: current_state, es: extendedState, hs: history}\r\n                  }\r\n                });\r\n                console.info(`CASE: unguarded transition`);\r\n              }\r\n\r\n              console.info(\"THEN : we execute the action \" + actionName);\r\n              const actionResult = ((extendedState, eventData, settings) => {\r\n                try {\r\n                  return action(extendedState, eventData, settings);\r\n                }\r\n                catch (e) {\r\n                  throwKinglyError({\r\n                    when: `Executing action factory ${actionName}`,\r\n                    location: `createStateMachine > event handler > condition_checking_fn`,\r\n                    info: {extendedState, event, event_data, settings, guard, from, to, index, action},\r\n                    message: e.message,\r\n                    stack: e.stack,\r\n                  })\r\n                }\r\n              })(extendedState_, event_data, settings);\r\n\r\n              if (!isActions(actionResult)) {\r\n                throwKinglyError({\r\n                  when: `Executing action factory ${actionName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn`,\r\n                  info: {extendedState, event, event_data, settings, guard, from, to, index, action, actionResult},\r\n                  message: `Action factory returned a value that does not have the expected shape!`,\r\n                })\r\n              }\r\n\r\n              const {updates, outputs} = actionResult;\r\n\r\n              // Leave the current state\r\n              leave_state(from, extendedState_, hash_states);\r\n\r\n              // Update the extendedState before entering the next state\r\n              extendedState = wrappedUpdateState(extendedState_, updates);\r\n\r\n              // ...and enter the next state (can be different from `to` if we have nesting state group)\r\n              const next_state = enter_next_state(to, updates, hash_states);\r\n              console.info(\"ENTERING NEXT STATE: \", next_state);\r\n              console.info(\"with extended state: \", extendedState);\r\n\r\n              // allows for chaining and stop chaining guard\r\n              return {stop: true, outputs};\r\n            }\r\n            else {\r\n              // CASE : guard for transition is not fulfilled\r\n              tracer({\r\n                type: DEBUG_MSG,\r\n                trace: {\r\n                  message: guard.predicate ? `The guard ${predicateName} is not fulfilled!` : `Evaluated and skipped transition`,\r\n                  info: {eventData: event_data, settings, guard, from, to, index, action: actionName},\r\n                  machineState: {cs: current_state, es: extendedState, hs: history}\r\n                }\r\n              });\r\n              return {stop: false, outputs: null};\r\n            }\r\n          };\r\n          // TODO: remove that, I don't need that anymore\r\n          condition_checking_fn.displayName = from + condition_suffix;\r\n          return condition_checking_fn;\r\n        })(guard, settings);\r\n\r\n        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {\r\n          const condition_checked = acc(extendedState_, event_data, current_state);\r\n          return condition_checked.stop\r\n            ? condition_checked\r\n            : condition_checking_fn(extendedState_, event_data, current_state);\r\n        };\r\n      },\r\n      function dummy() {\r\n        return {stop: false, outputs: null};\r\n      }\r\n    );\r\n  });\r\n\r\n  // TODO: think if rethrow errors we are not responsible for here too\r\n  try {\r\n    start();\r\n  }\r\n  catch (e) {\r\n    // Do not break the program, errors should be passed to console and dev tool\r\n    tracer({\r\n      type: MACHINE_CREATION_ERROR_MSG,\r\n      trace: {\r\n        message: e.message,\r\n        info: {fsmDef, settings, error: e},\r\n        machineState: {cs: INIT_STATE, es: extendedState, hs: history}\r\n      }\r\n    });\r\n    return e\r\n  }\r\n\r\n  // NOTE : yield is a reserved JavaScript word so using yyield\r\n  return function yyield(x) {\r\n    try {\r\n      const {eventName, eventData} = destructureEvent(x);\r\n      const current_state = getCurrentControlState();\r\n\r\n      tracer({\r\n        type: INPUT_MSG,\r\n        trace: {\r\n          info: {eventName, eventData},\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      const outputs = send_event(x, true);\r\n\r\n      debug && console.info(\"OUTPUTS:\", outputs);\r\n      tracer({\r\n        type: OUTPUTS_MSG,\r\n        trace: {\r\n          outputs,\r\n          machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      return outputs\r\n    }\r\n    catch (e) {\r\n      if (e instanceof KinglyError) {\r\n        // We don't break the program, but we can't continue as nothing happened: we return the error\r\n        tracer({\r\n          type: ERROR_MSG,\r\n          trace: {\r\n            error: e,\r\n            message: `An error ocurred while running an input through the machine!`,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        return e\r\n      }\r\n      else {\r\n        tracer({\r\n          type: ERROR_MSG,\r\n          trace: {\r\n            error: e,\r\n            message: `An unknown error ocurred while running an input through the machine!`,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n        console.error(`yyield > unexpected error!`, e);\r\n        // We should only catch the errors we are responsible for!\r\n        throw e\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {WebComponentName} name name for the web component. Must include at least one hyphen per custom\r\n * components' specification\r\n * @param {Subject} eventHandler A factory function which returns a subject, i.e. an object which\r\n * implements the `Observer` and `Observable` interface\r\n * @param {FSM} fsm An executable machine, i.e. a function which accepts machine inputs\r\n * @param {Object.<CommandName, CommandHandler>} commandHandlers\r\n * @param {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an effect moniker to a function performing the corresponding effect.\r\n * @param {{initialEvent, terminalEvent, NO_ACTION}} options\r\n */\r\nexport function makeWebComponentFromFsm({name, eventHandler, fsm, commandHandlers, effectHandlers, options}) {\r\n  class FsmComponent extends HTMLElement {\r\n    constructor() {\r\n      if (name.split('-').length <= 1) throw `makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!`\r\n      super();\r\n      const el = this;\r\n      this.eventSubject = eventHandler;\r\n      this.options = Object.assign({}, options);\r\n      const NO_ACTION = this.options.NO_ACTION || null;\r\n\r\n      // Set up execution of commands\r\n      this.eventSubject.subscribe({\r\n        next: eventStruct => {\r\n          const actions = fsm(eventStruct);\r\n\r\n          if (actions === NO_ACTION) return;\r\n          actions.forEach(action => {\r\n            if (action === NO_ACTION) return;\r\n            const {command, params} = action;\r\n            commandHandlers[command](this.eventSubject.next, params, effectHandlers, el);\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      return [];\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);\r\n      this.eventSubject.complete();\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      // simulate a new creation every time an attribute is changed\r\n      // i.e. they are not expected to change\r\n      this.constructor();\r\n      this.connectedCallback();\r\n    }\r\n  }\r\n\r\n  return customElements.define(name, FsmComponent);\r\n}\r\n\r\n/**\r\n * This function works to merge outputs by simple concatenation and flattening\r\n * Every action return T or [T], and we want in output [T] always\r\n * mergeOutputsFn([a, [b]) = mergeOutputsFn([a,b]) = mergeOutputsFn([[a],b) = mergeOutputsFn([[a],[b]]) = [a,b]\r\n * If we wanted to pass [a] as value we would have to do mergeOutputsFn([[[a]],[b]]) to get [[a],b]\r\n * @param arrayOutputs\r\n * @returns {*}\r\n */\r\nexport function mergeOutputsFn(arrayOutputs) {\r\n  // NOTE : here, this array of outputs could be array x non-array ^n\r\n  // The algorithm is to concat all elements\r\n  return arrayOutputs.reduce((acc, element) => acc.concat(element), [])\r\n}\r\n\r\n/**\r\n * Construct history states `hs` from a list of states for a given state machine. The history states for a given control\r\n * state can then be referenced as follows :\r\n * - `hs.shallow(state)` will be the shallow history state associated to the `state`\r\n * - `hs.deep(state)` will be the deep history state associated to the `state`\r\n * @param {FSM_States} states\r\n * @return {HistoryStateFactory}\r\n */\r\nexport function makeHistoryStates(states) {\r\n  const stateList = Object.keys(getFsmStateList(states));\r\n  // used for referential equality comparison to discriminate history type\r\n\r\n  return (historyType, controlState) => {\r\n    if (!stateList.includes(controlState)) {\r\n      throw `makeHistoryStates: the state for which a history state must be constructed is not a configured state for the state machine under implementation!!`\r\n    }\r\n\r\n    return {\r\n      [historyType]: controlState,\r\n      type: history_symbol\r\n    }\r\n  }\r\n}\r\n\r\nexport function historyState(historyType, controlState) {\r\n  return {\r\n    [historyType]: controlState\r\n  }\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INIT_STATE, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  getDisplayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${getDisplayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {ControlState} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INIT_STATE) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n"],"names":["SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INIT_STATE","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_STATE_UPDATE","NO_OUTPUT","ACTION_IDENTITY","outputs","updates","history_symbol","SHALLOW","DEEP","WRONG_EVENT_FORMAT_ERROR","FUNCTION_THREW_ERROR","fnName","type","INVALID_ACTION_FACTORY_EXECUTED","actionName","INVALID_PREDICATE_EXECUTED","ACTION_FACTORY_DESC","ENTRY_ACTION_FACTORY_DESC","PREDICATE_DESC","CONTRACTS_EVAL","OUTPUTS_MSG","INPUT_MSG","WARN_MSG","MACHINE_CREATION_ERROR_MSG","ERROR_MSG","INTERNAL_INPUT_MSG","INTERNAL_OUTPUTS_MSG","DEBUG_MSG","INIT_INPUT_MSG","PATH_ROOT","PRE_ORDER","clone","a","undefined","JSON","parse","stringify","merge","objA","objB","Object","assign","updatePathInTraversalState","traversalState","subTree","subTreeChildren","forEach","subTreeChild","index","traversalStateParent","get","traversalStateChild","currentChildPath","path","set","isAdded","isVisited","concat","updateVisitInTraversalState","tree","visitTree","traversalSpecs","store","lenses","traverse","empty","emptyOrEmptyConstructor","add","takeAndRemoveOne","isEmpty","getChildren","visit","seed","seedOrSeedConstructor","Map","currentStore","visitAcc","clear","breadthFirstTraverseTree","shift","length","subTrees","push","apply","preorderTraverseTree","unshift","postOrderTraverseTree","predicate","isLeaf","result","objectTreeLenses","isLeafLabel","label","getLabel","Array","isArray","keys","value","values","map","prop","[object Object]","constructTree","children","labelKey","traverseObj","obj","treeObj","root","strategy","BFS","POST_ORDER","arrayTreeLenses","noop","emptyConsole","log","warn","info","debug","error","trace","emptyTracer","isFunction","x","isControlState","isHistoryControlState","isEvent","isActionFactory","get_fn_name","fn","exec","toString","wrap","str","join","times","n","Number","call","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","from","is_to_history_control_state_of","is_history_control_state_of","state","substring","format_transition_label","_event","action","name","format_history_transition_state_name","get_all_transitions","guards","getDisplayName","replace","getFsmStateList","states","accStateList","treeLabel","getStatesType","statesTree","acc","getStatesPath","pathStr","getStatesTransitionsMap","transitions","reduce","getStateEventTransitionsMaps","getEventTransitionsMaps","getHistoryStatesMap","reduceTransitions","flatTransition","guardIndex","transitionIndex","gen","underlyingControlState","getHistoryUnderlyingState","getTargetStatesMap","getAncestorMap","computeHistoryMaps","control_states","stateList","stateAncestors","parentPath","slice","parentControlState","ancestors","_","reduceFn","transitionStruct","guard","arrayizeOutput","output","_typeof","getHistoryType","history","initHistoryDataStructure","initHistory","isCompoundState","analyzedStates","statesAdjacencyList","updateHistory","state_from_name","oldAncestor","newAncestor","findInitTransition","find","tryCatch","errCb","args","e","getFunctionName","actionFactory","displayName","assert","contract","arrayParams","contractName","isFulfilledOrError","when","message","notifyThrows","console","probableCause","isActions","isEventStruct","trueOrError","Error","cause","destructureEvent","eventName","eventData","KinglyError","m","tracer","stack","_this","errors","location","fullMsg","isInconditionalTransition","isValidGuard","areCconditionalTransitions","every","fsmContracts","injected","fsmDef","settings","statesType","initTransition","statesTransitionsMap","stateEventTransitionsMaps","eventTransitionsMaps","ancestorMap","statesPath","historyStatesMap","targetStatesMap","description","contracts","shouldThrow","events","isValidTransitions","initialExtendedState","isValidStates","isValidEvents","isFulfilled","blame","initialControlState","indexOf","declaredStates","targetStates","wrongTransitions","filter","Boolean","howMany","duplicatedStates","statesHashMap","reservedStates","eventList","declaredEventList","eventsDeclaredButNotTriggeringTransitions","declaredEvent","eventsNotDeclaredButTriggeringTransitions","triggeringEvent","ev","originStateList","targetStateList","declaredStateList","statesDeclaredButNotTriggeringTransitions","declaredState","statesNotDeclaredButTriggeringTransitions","stateInTransition","initTransitions","atomicInitTransitions","atomicState","compoundStates","compoundStatesInitTransitions","compoundState","allHaveInitTransitions","hasEntryTransitions","allHaveValidInitTransitions","targetState","entryTransitions","failingOriginControlStates","wrongSelfTransitions","statesTransitionsInfo","wrongEventConfig","eventTransitionsInfo","wrongStateConfig","ancestorState","invalidTransitions","entries","historyState","flatTransitions","wrongHistoryStates","originState","fsmContractChecker","contractsDef","contractsDescription","failingContracts","computedArgs","contractsEval","fullArgs","blameMessageHeader","makeContractHandler","alwaysTrue","normalizeTransitions","createStateMachine","userProvidedUpdateStateFn","updateState","devTool","checkContracts","throwKinglyError","machineState","cs","es","extendedState","hs","hash_states_struct","root_name","hash_states","is_group_state","State","nok","prototype","current_state_name","build_state_reducer","curr_constructor","state_name","state_config","parent_name","curr_constructor_new","build_nested_state_structure","is_init_state","is_auto_state","getCurrentControlState","send_event","event_struct","isExternalEvent","hasFailed","current_state","event_data","event_handler","stop","rawOutputs","new_current_state","auto_event","nextOutputs","received","process_event","arr_predicate","from_proto","condition_checking_fn","extendedState_","predicateName","shouldTransitionBeTaken","actionResult","leave_state","wrappedUpdateState","next_state","updatedExtendedState","state_to_name","history_type","deep","shallow","history_target","enter_next_state","condition_checked","generateStatePlantUmlHeader","optDisplayName","eventHandler","fsm","commandHandlers","effectHandlers","options","FsmComponent","split","el","eventSubject","NO_ACTION","subscribe","next","eventStruct","actions","command","params","HTMLElement","initialEvent","this","terminalEvent","complete","oldValue","newValue","constructor","connectedCallback","customElements","define","arrayOutputs","element","historyType","includes","translationMap","pathMap","translation","childrenTranslation","historyStatesObj","accTranslation","allTransitions","format_history_states","format_entry_transitions","historyTransitionTranslation","format_history_transitions","standardTransitionTranslation","format_standard_transitions","translate_transitions","stateToPlantUML","getChildrenNumber","mappedTree","translatedStates","translatedTransitions","b","arrayUpdateActions","updateAction","update","mergeOutputFn","arrayActionFactory","arrayActions","factory","arrayStateUpdates","arr","mapFn","mappedAction","formattedPredicate","formatActionName","pred","edgePath","edge","edgeInEdgePath","s","controlStateSequence","historyParentState","fnType","argsDesc","err","argDesc","notify","execInfo","actionResultOrError","postCondition","throwFn","invalidResultFn","returned","resultOrError","predName","exitActionResultOrError","key"],"mappings":"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"}