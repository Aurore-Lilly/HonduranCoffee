{"version":3,"file":"kingly.umd.js","sources":["../src/types.js","../src/properties.js","../node_modules/fp-rosetree/index.js","../src/helpers.js","../src/contracts.js","../src/synchronous_fsm.js","../src/converter.js","../src/index.js"],"sourcesContent":["/**\r\n * @typedef {Object} FSM_Def\r\n * @property {FSM_States} states Object whose every key is a control state admitted by the\r\n * specified state machine. The value associated to that key is unused in the present version of the library. The\r\n * hierarchy of the states correspond to property nesting in the `states` object\r\n * @property {Array<EventLabel>} events A list of event monikers the machine is configured to react to\r\n * @property {Array<Transition>} transitions An array of transitions the machine is allowed to take\r\n * @property {*} initialExtendedState The initial value for the machine's extended state\r\n * @property {{updateState :: Function(ExtendedState, ExtendedStateUpdate) : ExtendedState}} updateState function\r\n * which update the extended state of the state machine\r\n */\r\n/**\r\n * @typedef {Object.<ControlState, *>} FSM_States\r\n */\r\n/**\r\n * @typedef {InconditionalTransition | ConditionalTransition} Transition\r\n */\r\n/**\r\n * @typedef {{from: ControlState, to: ControlState|HistoryState, event: EventLabel, action: ActionFactory}} InconditionalTransition\r\n *   Inconditional_Transition encodes transition with no guards attached. Every time the specified event occurs, and\r\n *   the machine is in the specified state, it will transition to the target control state, and invoke the action\r\n *   returned by the action factory\r\n */\r\n/**\r\n * @typedef {{from: ControlState, event: EventLabel, guards: Array<Condition>}} ConditionalTransition Transition for the\r\n * specified state is contingent to some guards being passed. Those guards are defined as an array.\r\n */\r\n/**\r\n * @typedef {{predicate: FSM_Predicate, to: ControlState|HistoryState, action: ActionFactory}} Condition On satisfying the\r\n * specified predicate, the received event data will trigger the transition to the specified target control state\r\n * and invoke the action created by the specified action factory, leading to an update of the internal state of the\r\n * extended state machine and possibly an output to the state machine client.\r\n */\r\n/**\r\n * @typedef {function(ExtendedState, EventData, FSM_Settings) : Actions} ActionFactory\r\n */\r\n/**\r\n * @typedef {{updates: ExtendedStateUpdate, outputs: Array<MachineOutput>}} Actions The actions\r\n * to be performed by the state machine in response to a transition. `updates` represents the state update for\r\n * the variables of the extended state machine. `output` represents the output of the state machine passed to the\r\n * API caller.\r\n */\r\n/** @typedef {function (ExtendedState, EventData) : Boolean} FSM_Predicate */\r\n/** @typedef {{debug, devTool: {tracer}, displayName: String}} FSM_Settings\r\n * Miscellaneous settings including how to update the machine's state and debug\r\n * configuration\r\n * */\r\n/** @typedef {{merge: MergeObsFn, from: FromObsFn, filter: FilterObsFn, map: MapObsFn, share:ShareObsFn, ...}} FSM$_Settings */\r\n/**\r\n * @typedef {function (Array<Observable>) : Observable} MergeObsFn Similar to Rxjs v4's `Rx.Observable.merge`. Takes\r\n * an array of observables and return an observable which passes on all outputs emitted by the observables in the array.\r\n */\r\n/**\r\n * @typedef {function (value) : Observable} FromObsFn Similar to Rxjs v4's `Rx.Observable.from`. Takes\r\n * a value and lift it into an observable which completes immediately after emitting that value.\r\n */\r\n/**\r\n * @typedef {function (value) : Observable} FilterObsFn Similar to Rxjs v4's `Rx.Observable.filter`. Takes\r\n * a value and lift it into an observable which completes immediately after emitting that value.\r\n */\r\n/**\r\n * @typedef {function (value) : Observable} MapObsFn Similar to Rxjs v4's `Rx.Observable.map`. Takes\r\n * a value and lift it into an observable which completes immediately after emitting that value.\r\n */\r\n/**\r\n * @typedef {function (value) : Observable} ShareObsFn Similar to Rxjs v4's `Rx.Observable.share`. Takes\r\n * a value and lift it into an observable which completes immediately after emitting that value.\r\n */\r\n/**\r\n * @typedef {Object.<EventLabel, EventData>} LabelledEvent extended state for a given state machine\r\n */\r\n/**\r\n * @typedef {Object} FsmTraceData\r\n * @property {ControlState} controlState\r\n * @property {{EventLabel, EventData}} eventLabel\r\n * @property {ControlState} targetControlState\r\n * @property {FSM_Predicate} predicate\r\n * @property {ExtendedStateUpdate} updates\r\n * @property {ExtendedState} extendedState\r\n * @property {ActionFactory} actionFactory\r\n * @property {Number} guardIndex\r\n * @property {Number} transitionIndex\r\n */\r\n/**\r\n * @typedef {function(historyType: HistoryType, controlState: ControlState): HistoryState} HistoryStateFactory\r\n */\r\n/**\r\n * @typedef {{type:{}, [HistoryType]: ControlState}} HistoryState\r\n */\r\n/**\r\n * @typedef {Object.<HistoryType, HistoryDict>} History history object containing deeep and shallow history states\r\n * for all relevant control states\r\n */\r\n/**\r\n * @typedef {Object.<ControlState, ControlState>} HistoryDict Maps a compound control state to its history state\r\n */\r\n/**\r\n * @typedef {DEEP | SHALLOW} HistoryType\r\n */\r\n/** @typedef {String} ControlState Name of the control state */\r\n/** @typedef {String} EventLabel */\r\n/**\r\n * @typedef {*} EventData\r\n */\r\n/**\r\n * @typedef {*} ExtendedState extended state for a given state machine\r\n */\r\n/**\r\n * @typedef {*} ExtendedStateUpdate\r\n */\r\n/** @typedef {* | NO_OUTPUT} MachineOutput well it is preferrable that that be an object instead of a primitive */\r\n\r\n\r\n// Contract types\r\n/**\r\n * @typedef {Object} ContractsDef\r\n * @property {String} description name for the series of contracts\r\n * @property {function(FSM_Def):Object} injected a function of the machine definition which returns an object to be\r\n * injected to the contracts predicates\r\n * @property {Array<ContractDef>} contracts array of contract definitions\r\n */\r\n/**\r\n * @typedef {Object} ContractDef\r\n * @property {String} name name for the contract\r\n * @property {Boolean} shouldThrow whether the contract should thrown an exception or alternatively return one\r\n * @property {function(FSM_Def, injected):ContractCheck} predicate array of contract definitions\r\n */\r\n/**\r\n * @typedef {Object} ContractCheck\r\n * @property {Boolean} isFulfilled whether the contract is fulfilled\r\n * @property {{message:String, info:*}} blame information about the cause for the contract failure. The\r\n * `message` property is destined to the developer (for instnce can be printed in the console). Info aims\r\n * at providing additional data helping to track the error cause\r\n * @property {function(FSM_Def, injected):ContractCheck} predicate array of contract definitions\r\n */\r\n\r\n// Component types\r\n/**\r\n * @typedef {String} CommandName\r\n */\r\n/**\r\n * @typedef {function(SubjectEmitter, CommandParams, EffectHandlers, Element, Subject): ()} CommandHandler\r\n * A command handler performs effect, possibly relying on effects implementation included in the effect handlers\r\n * parameter. A command handler also receives parameters for its execution and two subjects, one for receiving\r\n * events, another one for emitting them. Lastly, a command handler may receive an Element which is generally used\r\n * for rendering purposes\r\n */\r\n/**\r\n * @typedef {function(): Subject} SubjectFactory\r\n */\r\n","export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INIT_STATE = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_STATE_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = [];\r\nexport const ACTION_IDENTITY = function ACTION_IDENTITY(){\r\n  return {\r\n    outputs : NO_OUTPUT,\r\n    updates : NO_STATE_UPDATE\r\n  }\r\n}\r\nexport const history_symbol = {};\r\nexport const SHALLOW = 'shallow';\r\nexport const DEEP = 'deep';\r\n\r\nexport const WRONG_EVENT_FORMAT_ERROR = `The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.`\r\nexport const FUNCTION_THREW_ERROR = (fnName, type) => `Exception thrown when executing ${type} ${fnName||\"\"}`\r\nexport const INVALID_ACTION_FACTORY_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not an action.`\r\nexport const INVALID_PREDICATE_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not a boolean.`\r\nexport const ACTION_FACTORY_DESC = `action factory`\r\nexport const ENTRY_ACTION_FACTORY_DESC = `(decorating) entry action`\r\nexport const UPDATE_STATE_FN_DESC = `update state function`\r\nexport const PREDICATE_DESC = `predicate`\r\n\r\nexport const COMMAND_RENDER = 'render'\r\n\r\nexport const CONTRACTS_EVAL = \"CONTRACTS_EVAL\";\r\n\r\nexport const OUTPUTS_MSG = \"OUTPUTS_MSG\";\r\nexport const INPUT_MSG = \"INPUT_MSG\";\r\nexport const WARN_MSG = 'WARN_MSG';\r\nexport const MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';\r\nexport const ERROR_MSG = 'ERROR_MSG';\r\nexport const INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';\r\nexport const INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';\r\nexport const DEBUG_MSG = 'DEBUG_MSG';\r\nexport const INIT_INPUT_MSG = 'INIT_INPUT_MSG';\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","// Ramda fns\r\nimport {\r\n  ACTION_FACTORY_DESC, DEEP, ENTRY_ACTION_FACTORY_DESC, FUNCTION_THREW_ERROR, HISTORY_PREFIX, HISTORY_STATE_NAME,\r\n  INIT_EVENT, INIT_STATE, INVALID_ACTION_FACTORY_EXECUTED, INVALID_PREDICATE_EXECUTED, NO_OUTPUT,\r\n  PREDICATE_DESC,\r\n  SHALLOW, WRONG_EVENT_FORMAT_ERROR\r\n} from \"./properties\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\n\r\nexport const noop = () => {\r\n};\r\nexport const emptyConsole = {log: noop, warn: noop, info: noop, debug: noop, error: noop, trace: noop};\r\nexport const emptyTracer = noop;\r\n\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\nexport function isFunction(x) {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport function isControlState(x) {\r\n  return x && typeof x === 'string' || isHistoryControlState(x)\r\n}\r\n\r\nexport function isEvent(x) {\r\n  return typeof x === 'undefined' || typeof x === 'string'\r\n}\r\n\r\nexport function isActionFactory(x) {\r\n  return x && typeof x === 'function'\r\n}\r\n\r\nexport function make_states(stateList) {\r\n  return stateList.reduce((acc, state) => {\r\n    acc[state] = \"\";\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function make_events(eventList) {\r\n  return eventList\r\n}\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) {\r\n  return ['-', str, '-'].join(\"\");\r\n}\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\nexport function always(x) {\r\n  return x\r\n}\r\n\r\nexport function keys(obj) {\r\n  return Object.keys(obj)\r\n}\r\n\r\nexport function merge(a, b) {\r\n  return Object.assign({}, a, b)\r\n}\r\n\r\n// Contracts\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({from, to}) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const {from, event, guards} = transition;\r\n\r\n  return guards\r\n    ? guards.map(({predicate, to, action}) => ({from, event, predicate, to, action}))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function getDisplayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n/**\r\n * This function MERGES extended state updates. That means that given two state updates, the resulting state update\r\n * will be the concatenation of the two, in the order in which they are passed\r\n * @param {function[]}  arrayUpdateActions\r\n * @returns {function(*=, *=, *=): {updates: *}}\r\n */\r\nexport function mergeModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    return {\r\n      updates: arrayUpdateActions.reduce((acc, updateAction) => {\r\n        const update = updateAction(extendedState, eventData, settings).updates;\r\n        if (update) {\r\n          return acc.concat(update)\r\n        }\r\n        else {\r\n          return acc\r\n        }\r\n      }, []),\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function CHAINS extended state updates, in the order in which they are passed. It is thus similar to a pipe.\r\n * The second update function receives the state updated by the first update function.\r\n * @param {function[]}  arrayUpdateActions\r\n */\r\nexport function chainModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    const {updateState} = settings;\r\n    return {\r\n      updates: arrayUpdateActions\r\n        .reduce((acc, updateAction) => {\r\n          const {extendedState, updates} = acc;\r\n          const update = updateAction(extendedState, eventData, settings).updates;\r\n          const updatedState = updateState(extendedState, updates)\r\n\r\n          return {extendedState: updatedState, updates: update}\r\n        }, {extendedState, updates: []})\r\n        .updates || [],\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {function (Array<Array<MachineOutput>>) : Array<MachineOutput>} mergeOutputFn\r\n * @param {Array<ActionFactory>} arrayActionFactory\r\n * @returns {function(*=, *=, *=): {updates: *[], outputs: *|null}}\r\n */\r\nexport function mergeActionFactories(mergeOutputFn, arrayActionFactory) {\r\n  return function (extendedState, eventData, settings) {\r\n    const arrayActions = arrayActionFactory.map(factory => factory(extendedState, eventData, settings));\r\n    const arrayStateUpdates = arrayActions.map(x => x.updates || []);\r\n    const arrayOutputs = arrayActions.map(x => x.outputs || {});\r\n\r\n    return {\r\n      updates: [].concat(...arrayStateUpdates),\r\n      // for instance, mergeFn = R.mergeAll or some variations around R.mergeDeepLeft\r\n      outputs: mergeOutputFn(arrayOutputs)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type ActionFactory*/\r\nexport function identity(extendedState, eventData, settings) {\r\n  return {\r\n    updates: [],\r\n    outputs: NO_OUTPUT\r\n  }\r\n}\r\n\r\nexport function lastOf(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction formatActionName(action, from, event, to, predicate) {\r\n  const predicateName = predicate ? predicate.name : \"\";\r\n  const formattedPredicate = predicateName ? `[${predicateName}]` : \"\";\r\n  const actionName = action ? action.name : \"identity\";\r\n  const formattedAction = actionName ? actionName : \"unnamed action\";\r\n  return `${formattedAction}:${from}-${event}->${to} ${formattedPredicate}`;\r\n}\r\n\r\nexport function getFsmStateList(states) {\r\n  const {getLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (accStateList, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      accStateList[controlState] = \"\";\r\n\r\n      return accStateList;\r\n    }\r\n  };\r\n  const stateHashMap = traverseObj(traverse, states);\r\n\r\n  return stateHashMap\r\n}\r\n\r\nexport function getStatesType(statesTree) {\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      // true iff control state is a compound state\r\n      return isLeafLabel(treeLabel)\r\n        ? (acc[controlState] = false, acc)\r\n        : (acc[controlState] = true, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesPath(statesTree) {\r\n  const {getLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const pathStr = traversalState.get(tree).path.join('.');\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      return (acc[controlState] = pathStr, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesTransitionsMap(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = transition;\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getStateEventTransitionsMaps(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getEventTransitionsMaps(transitions) {\r\n  // Map an event to the origin control states of the transitions it triggers\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[event] = acc[event] || {};\r\n      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getHistoryStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {from, event, to, action, predicate, gen} = flatTransition;\r\n      if (isHistoryControlState(from)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(from);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n      else if (isHistoryControlState(to)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(to);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getTargetStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {to} = flatTransition;\r\n      map.set(to, (map.get(to) || []).concat([flatTransition]));\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getAncestorMap(statesTree) {\r\n  const {getLabel, getChildren} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = getChildren(tree)\r\n      const childrenControlStates = children.map(tree => Object.keys(getLabel(tree))[0]);\r\n\r\n      childrenControlStates.forEach(state => {\r\n        acc[state] = acc[state] || [];\r\n        acc[state] = acc[state].concat(controlState);\r\n      });\r\n\r\n      return acc\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function computeHistoryMaps(control_states) {\r\n  if (Object.keys(control_states).length === 0) {\r\n    throw `computeHistoryMaps : passed empty control states parameter?`\r\n  }\r\n\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {stateList: [], stateAncestors: {}},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      acc.stateList = acc.stateList.concat(controlState);\r\n\r\n      // NOTE : we don't have to worry about path having only one element\r\n      // that case correspond to the root of the tree which is excluded from visiting\r\n      const {path} = traversalState.get(tree);\r\n      traversalState.set(JSON.stringify(path), controlState);\r\n      const parentPath = path.slice(0, -1);\r\n      if (parentPath.length === 1) {\r\n        // That's the root\r\n        traversalState.set(JSON.stringify(parentPath), INIT_STATE);\r\n      }\r\n      else {\r\n        const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n        acc.stateAncestors[controlState] = [parentControlState];\r\n\r\n        const {ancestors} = path.reduce((acc, _) => {\r\n          const parentPath = acc.path.slice(0, -1);\r\n          acc.path = parentPath;\r\n          if (parentPath.length > 1) {\r\n            const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n            acc.ancestors = acc.ancestors.concat(parentControlState);\r\n          }\r\n\r\n          return acc\r\n        }, {ancestors: [], path});\r\n        acc.stateAncestors[controlState] = ancestors;\r\n      }\r\n\r\n      return acc\r\n    }\r\n  };\r\n  const {stateList, stateAncestors} = traverseObj(traverse, control_states);\r\n\r\n  return {stateList, stateAncestors}\r\n}\r\n\r\nexport function mapOverTransitionsActions(mapFn, transitions) {\r\n  return reduceTransitions(function (acc, transition, guardIndex, transitionIndex) {\r\n    const {from, event, to, action, predicate} = transition;\r\n    const mappedAction = mapFn(action, transition, guardIndex, transitionIndex);\r\n    mappedAction.displayName = mappedAction.displayName || (action && (action.name || action.displayName || formatActionName(action, from, event, to, predicate)));\r\n\r\n    if (typeof(predicate) === 'undefined') {\r\n      acc.push({from, event, to, action: mappedAction})\r\n    }\r\n    else {\r\n      if (guardIndex === 0) {\r\n        acc.push({from, event, guards: [{to, predicate, action: mappedAction}]})\r\n      }\r\n      else {\r\n        acc[acc.length - 1].guards.push({to, predicate, action: mappedAction})\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, [], transitions)\r\n}\r\n\r\nexport function reduceTransitions(reduceFn, seed, transitions) {\r\n  const result = transitions.reduce((acc, transitionStruct, transitionIndex) => {\r\n    let {from, event, to, gen, action, guards} = transitionStruct;\r\n    // Edge case when no guards are defined\r\n    if (!guards) {\r\n      guards = gen ? [{to, action, gen, predicate: undefined}] : [{to, action, predicate: undefined}]\r\n    }\r\n    return guards.reduce((acc, guard, guardIndex) => {\r\n      const {to, action, gen, predicate} = guard;\r\n      return gen\r\n        ? reduceFn(acc, {from, event, to, action, predicate, gen}, guardIndex, transitionIndex)\r\n        : reduceFn(acc, {from, event, to, action, predicate}, guardIndex, transitionIndex)\r\n    }, acc);\r\n  }, seed);\r\n\r\n  return result\r\n}\r\n\r\nexport function everyTransition(pred, transition) {\r\n  return reduceTransitions((acc, flatTransition) => {\r\n    return acc && pred(flatTransition)\r\n  }, true, [transition])\r\n}\r\n\r\nexport function computeTimesCircledOn(edgePath, edge) {\r\n  return edgePath.reduce((acc, edgeInEdgePath) => edgeInEdgePath === edge ? acc + 1 : acc, 0);\r\n}\r\n\r\nexport function isInitState(s) {\r\n  return s === INIT_STATE\r\n}\r\n\r\nexport function isInitEvent(e) {\r\n  return e === INIT_EVENT\r\n}\r\n\r\nexport function isEventless(e) {\r\n  return typeof e === 'undefined'\r\n}\r\n\r\nexport function arrayizeOutput(output) {\r\n  return output === NO_OUTPUT\r\n    ? NO_OUTPUT\r\n    : Array.isArray(output)\r\n      ? output\r\n      : [output]\r\n}\r\n\r\nexport function isHistoryControlState(to) {\r\n  return typeof to === 'object' && (DEEP in to || SHALLOW in to)\r\n}\r\n\r\nexport function getHistoryParentState(to) {\r\n  return to[SHALLOW] || to[DEEP]\r\n}\r\n\r\nexport function isShallowHistory(to) {\r\n  return to[SHALLOW]\r\n}\r\n\r\nexport function isDeepHistory(to) {\r\n  return to[DEEP]\r\n}\r\n\r\nexport function getHistoryType(history) {\r\n  return history[DEEP] ? DEEP : SHALLOW\r\n}\r\n\r\nexport function getHistoryUnderlyingState(history) {\r\n  return history[getHistoryType(history)]\r\n}\r\n\r\nexport function isHistoryStateEdge(edge) {\r\n  return typeof edge.history !== 'undefined'\r\n}\r\n\r\n/**\r\n * Creates a history object from a state list. The created history object represents the history states when no\r\n * control states have been entered or exited.\r\n * @param stateList\r\n * @returns {History}\r\n */\r\nexport function initHistoryDataStructure(stateList) {\r\n  // NOTE : we update history in place, so we need two different objects here, even\r\n  // when they start with the same value\r\n  const initHistory = () => stateList.reduce((acc, state) => (acc[state] = '', acc), {});\r\n  return {[DEEP]: initHistory(), [SHALLOW]: initHistory()};\r\n}\r\n\r\nexport function isCompoundState(analyzedStates, controlState) {\r\n  const {statesAdjacencyList} = analyzedStates;\r\n  return statesAdjacencyList[controlState] && statesAdjacencyList[controlState].length !== 0\r\n}\r\n\r\nexport function isAtomicState(analyzedStates, controlState) {\r\n  return !isCompoundState(analyzedStates, controlState)\r\n}\r\n\r\n/**\r\n * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the\r\n * `stateAncestors` which are the ancestors for the exited state.\r\n * @param {History} history Contains deep history and shallow history for all\r\n * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function\r\n * `updateHistory` allows to update the history as transitions occur in the state machine.\r\n * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors\r\n * @returns {History}\r\n * @modifies history\r\n */\r\nexport function updateHistory(history, stateAncestors, state_from_name) {\r\n  // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)\r\n\r\n  if (state_from_name === INIT_STATE) {\r\n    return history\r\n  }\r\n  else {\r\n      // ancestors for the state which is exited\r\n      const ancestors = stateAncestors[state_from_name] || [];\r\n      ancestors.reduce((oldAncestor, newAncestor) => {\r\n        // set the exited state in the history of all ancestors\r\n        history[DEEP][newAncestor] = state_from_name;\r\n        history[SHALLOW][newAncestor] = oldAncestor;\r\n\r\n        return newAncestor\r\n      }, state_from_name);\r\n\r\n    return history\r\n  }\r\n}\r\n\r\n/**\r\n * for all parentState, computes history(parentState), understood as the last control state descending from the\r\n * parent state. Last can be understood two ways : DEEP and SHALLOW. Deep history state refer to the last atomic\r\n * control state which is a children of the parent state and was exited. Shallow history states refer to the last\r\n * control state which is a direct child of the parent state and was exited.\r\n * @param {FSM_States} states\r\n * @param {Array<ControlState>} controlStateSequence Sequence of control states which has been entered and exited,\r\n * and from which the history must be injected\r\n * @param {DEEP | SHALLOW} historyType\r\n * @param {ControlState} historyParentState\r\n * @returns {Object.<DEEP|SHALLOW, Object.<ControlState, ControlState>>}\r\n */\r\nexport function computeHistoryState(states, controlStateSequence, historyType, historyParentState) {\r\n  // NOTE : we compute the whole story every time. This is inefficient, but for now sufficient\r\n  const {stateList, stateAncestors} = computeHistoryMaps(states);\r\n  let history = initHistoryDataStructure(stateList);\r\n  history = controlStateSequence.reduce(\r\n    (history, controlState) => updateHistory(history, stateAncestors, controlState),\r\n    history\r\n  );\r\n\r\n  return history[historyType][historyParentState]\r\n}\r\n\r\nexport function findInitTransition(transitions) {\r\n  return transitions.find(transition => {\r\n    return transition.from === INIT_STATE && transition.event === INIT_EVENT\r\n  })\r\n}\r\n\r\nexport function tryCatch(fn, errCb) {\r\n  return function tryCatch(...args) {\r\n    try {\r\n      return fn.apply(fn, args);\r\n    }\r\n    catch (e) {\r\n      return errCb(e, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport function tryCatchMachineFn(fnType, fn, argsDesc = []) {\r\n  return tryCatch(fn, (e, args) => {\r\n    const err = new Error(e);\r\n    const fnName = getFunctionName(fn);\r\n    // NOTE : we concatenate causes but not `info`\r\n    const probableCause = FUNCTION_THREW_ERROR(fnName, fnType);\r\n    err.probableCause = e.probableCause ? [e.probableCause, probableCause].join('\\n') : probableCause;\r\n\r\n    const info = {\r\n      fnName,\r\n      params: argsDesc.reduce((acc, argDesc, index) => {\r\n        return acc[argDesc] = args[index], acc\r\n      }, {})\r\n    };\r\n    err.info = e.info ? [].concat([e.info]).concat([info]) : info;\r\n\r\n    return err\r\n  })\r\n}\r\n\r\nexport function getFunctionName(actionFactory) {\r\n  return actionFactory.name || actionFactory.displayName || 'anonymous'\r\n}\r\n\r\n/**\r\n *\r\n * @param {function: true | Error} contract Contract returns either true (fulfilled contract) or an Error with an\r\n * optional info properties to give more details about the cause of the error\r\n * @param {Array} arrayParams Parameters to be passed to the conract\r\n * @returns {undefined|{when, location, info, message, ...}} if the contract is fulfilled\r\n * @throws if the contract fails\r\n */\r\nexport function assert(contract, arrayParams) {\r\n  const contractName = contract.name ||contract.name.displayName || \"\";\r\n  const isFulfilledOrError = contract.apply(null, arrayParams);\r\n  if (isFulfilledOrError === true) return void 0\r\n  else {\r\n    return {\r\n      ...isFulfilledOrError,\r\n      when: `Checking contract`,\r\n      message: [isFulfilledOrError.message, `failed contract ${contractName}`].join(\"\\n\"),\r\n      info: isFulfilledOrError.info,\r\n    }\r\n  }\r\n}\r\n\r\nexport function notifyThrows(console, error) {\r\n  console.error(error);\r\n  error.probableCause && console.error(`Probable cause: ${error.probableCause}`);\r\n  error.info && console.error(`ERROR: additional info`, error.info);\r\n}\r\n\r\n/**\r\n * false iff no errors or invalid actions\r\n * if not throws an exception\r\n * @param {{debug, console}} notify\r\n * @param {*} execInfo Information about the call - should include the function, and the parameters for the function\r\n * call\r\n * @param {Actions | Error} actionResultOrError\r\n * @param {function} throwFn handles when the action factory throws during its execution\r\n * @param {function} invalidResultFn handles when the action factory returns invalid actions\r\n * @returns {boolean}\r\n * @param postCondition\r\n */\r\nexport function handleFnExecError(notify, execInfo, actionResultOrError, postCondition, throwFn, invalidResultFn) {\r\n  const {debug, console} = notify;\r\n\r\n  if (debug && actionResultOrError instanceof Error) {\r\n    throwFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else if (debug && !postCondition(actionResultOrError)) {\r\n    invalidResultFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else return false\r\n}\r\n\r\nexport function notifyAndRethrow({debug, console}, actionResultOrError) {\r\n  notifyThrows(console, actionResultOrError)\r\n  throw actionResultOrError\r\n}\r\n\r\nexport function throwIfInvalidActionResult({debug, console}, actionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: actionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidGuardResult({debug, console}, resultOrError, exec) {\r\n  const predName = getFunctionName(exec.predicate);\r\n  const error = new Error(INVALID_PREDICATE_EXECUTED(predName, PREDICATE_DESC));\r\n  error.info = {\r\n    predicateName: predName,\r\n    params: exec,\r\n    returned: resultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidEntryActionResult({debug, console}, exitActionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ENTRY_ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: exitActionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function isActions(obj) {\r\n  return obj && `updates` in obj && `outputs` in obj\r\n    && Array.isArray(obj.outputs)\r\n  // && Array.isArray(obj.updates)\r\n  // !! does not have to be arrays. HAs to be anything that is accepted by updateState\r\n}\r\n\r\n/**\r\n * That is a Either contract, not a Boolean contract!\r\n * @param obj\r\n * @returns {boolean|Error}\r\n */\r\nexport function isEventStruct(obj) {\r\n  let trueOrError;\r\n  if (!obj || typeof obj !== 'object') {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `not an object!`}\r\n  }\r\n  else if (Object.keys(obj).length > 1) {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `Event objects must have only one key which is the event name!`}\r\n  }\r\n  else trueOrError = true;\r\n\r\n  return trueOrError\r\n}\r\n\r\nexport function isError(obj) {\r\n  return obj instanceof Error\r\n}\r\n\r\nexport function destructureEvent(obj) {\r\n  const eventName = Object.keys(obj)[0];\r\n  const eventData = obj[eventName];\r\n\r\n  return {eventName, eventData}\r\n}\r\n\r\nexport function formatUndefinedInJSON(obj){\r\n  return JSON.stringify(obj, (key,value)=> {if (value === undefined) return \"undefined\"; else return value})\r\n}\r\n\r\nexport class KinglyError extends Error {\r\n  constructor(m, console, tracer) {\r\n    super(m && m.message || \"\");\r\n    this.name = `KinglyError`;\r\n    this.stack = m && m.stack || this.stack;\r\n    this.errors = m;\r\n    const { when, location, info, message } = m || {};\r\n    const fm = `At ${location}: ${when} => ${message}`;\r\n    const infoMsg = info ? `See extra info in console` : \"\";\r\n    const fullMsg = [fm, infoMsg].join(\"\\n\");\r\n    // this.message = fullMsg;\r\n    console && console.error(fullMsg);\r\n    info && console && console.info(info);\r\n  }\r\n}\r\n","import {\r\n    emptyConsole,\r\n    findInitTransition,\r\n    getAncestorMap,\r\n    getEventTransitionsMaps,\r\n    getHistoryStatesMap,\r\n    getHistoryUnderlyingState,\r\n    getStatesPath,\r\n    getStatesTransitionsMap,\r\n    getStateEventTransitionsMaps,\r\n    getStatesType,\r\n    getTargetStatesMap,\r\n    isActionFactory,\r\n    isControlState,\r\n    isEvent,\r\n    isFunction,\r\n    isHistoryControlState,\r\n    noop\r\n} from \"./helpers\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\nimport {CONTRACTS_EVAL, INIT_EVENT, INIT_STATE} from \"./properties\"\r\n\r\n// Contracts\r\n\r\n// S2. State names must be unique\r\nexport const noDuplicatedStates = {\r\n    name: 'noDuplicatedStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {getLabel} = objectTreeLenses;\r\n        const traverse = {\r\n            strategy: PRE_ORDER,\r\n            seed: {duplicatedStates: [], statesHashMap: {}},\r\n            visit: (acc, traversalState, tree) => {\r\n                const {duplicatedStates, statesHashMap} = acc;\r\n                const treeLabel = getLabel(tree);\r\n                const controlState = Object.keys(treeLabel)[0];\r\n                if (controlState in statesHashMap) {\r\n                    return {\r\n                        duplicatedStates: duplicatedStates.concat(controlState),\r\n                        statesHashMap\r\n                    }\r\n                }\r\n                else {\r\n                    return {\r\n                        duplicatedStates,\r\n                        statesHashMap: (statesHashMap[controlState] = \"\", statesHashMap)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const {duplicatedStates} = traverseObj(traverse, fsmDef.states);\r\n\r\n        const isFulfilled = duplicatedStates.length === 0;\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `State names must be unique! Found duplicated state names. Cf. log`,\r\n                info: {duplicatedStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S1. State name cannot be a reserved state name (for now only INIT_STATE)\r\nexport const noReservedStates = {\r\n    name: 'noReservedStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesType}) => {\r\n        return {\r\n            isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,\r\n            blame: {\r\n                message: `You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log`,\r\n                info: {reservedStates: [INIT_STATE], statesType}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S4. At least one control state (other than the initial state) muat be declared\r\nexport const atLeastOneState = {\r\n    name: 'atLeastOneState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesType}) => {\r\n        return {\r\n            isFulfilled: Object.keys(statesType).length > 0,\r\n            blame: {\r\n                message: `Machine configuration must define at least one control state! Cf. log`,\r\n                info: {statesType}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// S5. check initial control state is a defined state in states\r\nexport const isInitialControlStateDeclared = {\r\n    name: 'isInitialControlStateDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition, statesType}) => {\r\n        const {initialControlState, transitions} = fsmDef;\r\n        const stateList = Object.keys(statesType);\r\n        if (initialControlState) {\r\n            return {\r\n                isFulfilled: stateList.indexOf(initialControlState) > -1,\r\n                blame: {\r\n                    message: `Configured initial control state must be a declared state. Cf. log`,\r\n                    info: {initialControlState, declaredStates: stateList}\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n\r\n    },\r\n};\r\n\r\n// E0. `fsmDef.events` msut be an array of strings\r\nexport const eventsAreStrings = {\r\n    name: 'eventsAreStrings',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        return {\r\n            isFulfilled: fsmDef.events.every(x => typeof x === 'string'),\r\n            blame: {\r\n                message: `Events must be an array of strings!`,\r\n                info: {events: fsmDef.events}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const validInitialConfig = {\r\n    name: 'validInitialConfig',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition}) => {\r\n        const {initialControlState} = fsmDef;\r\n\r\n        if (initTransition && initialControlState) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!`,\r\n                    info: {initialControlState, initTransition}\r\n                }\r\n            }\r\n        }\r\n        else if (!initTransition && !initialControlState) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?`,\r\n                    info: {initialControlState, initTransition}\r\n                }\r\n            }\r\n        }\r\n        else return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n    },\r\n};\r\n\r\n// T1. There must be configured at least one transition away from the initial state\r\n// T2. A transition away from the initial state can only be triggered by the initial event\r\n// T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history\r\n// state as target\r\n// T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We\r\n// can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and\r\n// debugging!. So enforce ACTIONS to be identity\r\nexport const validInitialTransition = {\r\n    name: 'validInitialTransition',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {initTransition}) => {\r\n        const {initialControlState, transitions} = fsmDef;\r\n        const initTransitions = transitions.reduce((acc, transition) => {\r\n            transition.from === INIT_STATE && acc.push(transition);\r\n            return acc\r\n        }, []);\r\n        // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!\r\n        // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't\r\n        // enforce the part of the contract which require to have no actions for initial transitions...\r\n        const isFulfilled =\r\n            (initialControlState && !initTransition) ||\r\n            (!initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT\r\n                && (\r\n                    isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY\r\n                    || areCconditionalTransitions(initTransition)\r\n                    // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)\r\n                )\r\n            );\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Invalid configuration for initial transition! Cf. log`,\r\n                info: {initTransition, initTransitions, initialControlState}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound\r\n// state or A is the initial state\r\nexport const initEventOnlyInCompoundStates = {\r\n    name: 'initEventOnlyInCompoundStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const atomicStates = Object.keys(statesType).filter(controlState => !statesType[controlState]);\r\n        const atomicInitTransitions = atomicStates.map(\r\n            atomicState => ({\r\n                [atomicState]: statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]\r\n            })\r\n        ).filter(obj => Object.values(obj)[0]);\r\n\r\n        const hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0\r\n\r\n        return {\r\n            isFulfilled: hasInitEventOnlyInCompoundStates,\r\n            blame: {\r\n                message: `Found at least one atomic state with an entry transition! That is forbidden! Cf. log`,\r\n                info: {initTransitions: atomicInitTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined\r\n// T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have a history state as target\r\n// NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop\r\n// T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have the history state as target and has a target control state that is one of its substates (no\r\n// out-of-hierarchy INIT transitions)\r\nexport const validInitialTransitionForCompoundState = {\r\n    name: 'validInitialTransitionForCompoundState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const compoundStates = Object.keys(statesType).filter(controlState => statesType[controlState]);\r\n        const compoundStatesInitTransitions = compoundStates.map(\r\n            compoundState => statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT]);\r\n\r\n        const allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);\r\n\r\n        if (!allHaveInitTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state without an entry transition! Cf. log`,\r\n                    info: {\r\n                        hasEntryTransitions: compoundStates.map(\r\n                            state => ({[state]: !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT])}))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const allHaveValidInitTransitions = allHaveInitTransitions &&\r\n            compoundStatesInitTransitions.every(initTransition => {\r\n                const {guards, to} = initTransition;\r\n                if (!guards) {\r\n                    //  T7a\r\n                    return typeof to === 'string'\r\n                }\r\n                else {\r\n                    const targetStates = guards.map(guard => guard.to);\r\n                    return targetStates.every(targetState => typeof targetState === 'string')\r\n                }\r\n            });\r\n        if (!allHaveValidInitTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log`,\r\n                    info: {entryTransitions: compoundStatesInitTransitions}\r\n                }\r\n            }\r\n        }\r\n        ;\r\n\r\n        const allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions &&\r\n            compoundStatesInitTransitions.every(initTransition => {\r\n                const {from, guards, to} = initTransition;\r\n\r\n                // Don't forget to also eliminate the case when from = to\r\n                // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the\r\n                // other from declared states\r\n                if (!guards){\r\n                    return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n                }\r\n                else {\r\n                    const targetStates = guards.map(guard => guard.to);\r\n                    return targetStates.every(to => {\r\n                        return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n                    })\r\n                }\r\n            });\r\n        if (!allHaveTargetStatesWithinHierarchy) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! `,\r\n                    info: {states: fsmDef.states, statesPath, entryTransitions: compoundStatesInitTransitions}\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            isFulfilled: true,\r\n            blame: void 0\r\n        }\r\n    },\r\n};\r\n\r\n// T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X\r\n// T24. Check that we have this implicitly : Compound states must not have eventless transitions\r\n// defined on them (would introduce ambiguity with the INIT transition).\r\nexport const validEventLessTransitions = {\r\n    name: 'validEventLessTransitions',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {statesTransitionsMap, statesType, statesPath}) => {\r\n        // The compound states below does not include the initial state by construction\r\n        const stateList = Object.keys(statesType);\r\n        const failingOriginControlStates = stateList.map(state => {\r\n            return {\r\n                [state]: statesTransitionsMap[state] &&\r\n                `${void 0}` in statesTransitionsMap[state] &&\r\n                Object.keys(statesTransitionsMap[state]).length !== 1\r\n            }\r\n        }).filter(obj => Object.values(obj)[0] !== void 0 && Object.values(obj)[0]);\r\n\r\n        const isFulfilled = failingOriginControlStates.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found at least one control state without both an eventless transition and a competing transition! Cf. log`,\r\n                info: {failingOriginControlStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together\r\n// in a single array and there cannot be two transition rows showcasing A -ev-> * transitions\r\nexport const allStateTransitionsOnOneSingleRow = {\r\n    name: 'allStateTransitionsOnOneSingleRow',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const statesTransitionsInfo = originStateList.reduce((acc, state) => {\r\n            const events = Object.keys(stateEventTransitionsMaps[state]);\r\n            const wrongEventConfig = events.filter(event => stateEventTransitionsMaps[state][event].length > 1);\r\n            if (wrongEventConfig.length > 0) {\r\n                acc[state] = wrongEventConfig;\r\n            }\r\n\r\n            return acc\r\n        }, {});\r\n\r\n        const isFulfilled = Object.keys(statesTransitionsInfo).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log`,\r\n                info: {statesTransitionsInfo}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A\r\n// with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.\r\n// The event `ev` could trigger a transition towards either B or C\r\nexport const noConflictingTransitionsWithAncestorState = {\r\n    name: 'noConflictingTransitionsWithAncestorState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, eventTransitionsMaps, ancestorMap}) => {\r\n        const eventList = Object.keys(eventTransitionsMaps).filter(ev => ev !== INIT_EVENT && ev !== void 0);\r\n        const eventTransitionsInfo = eventList.reduce((acc, event) => {\r\n            const states = Object.keys(eventTransitionsMaps[event]);\r\n            // The wrongly configured states are those which have an ancestor also in the transition map for the same event\r\n            const wrongStateConfig = states\r\n                .filter(state => state !== INIT_STATE)\r\n                .map(state => ancestorMap[state] && {\r\n                    [state]: ancestorMap[state].find(\r\n                        ancestorState => states.indexOf(ancestorState) > -1\r\n                    )\r\n                })\r\n                // removing cases : undefined and {[state]: undefined}\r\n                .filter(obj => {\r\n                    return obj && Object.values(obj).filter(Boolean).length > 0\r\n                });\r\n\r\n            if (wrongStateConfig.length > 0) {\r\n                acc[event] = wrongStateConfig;\r\n            }\r\n\r\n            return acc\r\n        }, {});\r\n\r\n        const isFulfilled = Object.keys(eventTransitionsInfo).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log`,\r\n                info: {eventTransitionsInfo}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T16.a History states must be target states\r\nexport const isHistoryStatesTargetStates = {\r\n    name: 'isHistoryStatesTargetStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {}) => {\r\n        const wrongHistoryStates = fsmDef.transitions.reduce((acc, transition) => {\r\n            return isHistoryControlState(transition.from)\r\n                ? acc.concat(transition)\r\n                : acc\r\n        }, []);\r\n\r\n        const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log`,\r\n                info: {wrongHistoryStates}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T16.b History states must be compound states\r\nexport const isHistoryStatesCompoundStates = {\r\n    name: 'isHistoryStatesCompoundStates',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, statesType}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const wrongHistoryStates = originStateList.map(originState => {\r\n            if (originState === INIT_STATE) return []\r\n\r\n            const events = Object.keys(stateEventTransitionsMaps[originState]);\r\n\r\n            return events.reduce((acc, event) => {\r\n                // I should only ever have one transition, that is checked in another contract\r\n                // !! if there are several transitions, we may have a false positive, but that is ok\r\n                // When the other contract will fail and the issue will be solved, and app will be rerun,\r\n                // this will be recomputed correctly\r\n                const transition = stateEventTransitionsMaps[originState][event][0];\r\n                const {guards, to} = transition;\r\n                if (!guards) {\r\n                    // Reminder: statesType[controlState] === true iff controlState is compound state\r\n                    return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n                        ? acc.concat(transition)\r\n                        : acc\r\n                }\r\n                else {\r\n                    return guards.reduce((acc, guard) => {\r\n                        const {to} = guard;\r\n\r\n                        return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n                            ? acc.concat(transition)\r\n                            : acc\r\n                    }, acc)\r\n                }\r\n            }, [])\r\n        })\r\n            .reduce((acc, x) => acc.concat(x), []);\r\n\r\n        const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log`,\r\n                info: {wrongHistoryStates, states: fsmDef.states}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T17 An history state must refer to an existing state\r\nexport const isHistoryStatesExisting = {\r\n    name: 'isHistoryStatesExisting',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {historyStatesMap, statesType}) => {\r\n        const invalidTransitions = Array.from(historyStatesMap.entries())\r\n            .map(([historyState, flatTransitions]) => {\r\n                return !(historyState in statesType) && {historyState, flatTransitions}\r\n            })\r\n            .filter(Boolean);\r\n\r\n        const howMany = Object.keys(invalidTransitions).length;\r\n        const isFulfilled = howMany === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found ${howMany} history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition.`,\r\n                info: {invalidTransitions, states: fsmDef.states}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport function isInconditionalTransition(transition) {\r\n    const {from, event, guards, to, action} = transition;\r\n\r\n    return typeof guards === `${void 0}` && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action)\r\n}\r\n\r\nexport function isValidGuard(guard) {\r\n    const {to, predicate, action} = guard;\r\n\r\n    return to && isControlState(to) && isFunction(predicate) && isActionFactory(action)\r\n}\r\n\r\nexport function areCconditionalTransitions(transition) {\r\n    const {from, event, guards, to} = transition;\r\n\r\n    return guards && Array.isArray(guards) && guards.length > 0\r\n        && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard)\r\n}\r\n\r\nexport const isValidFsmDef = {\r\n    name: 'isValidFsmDef',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {transitions, states, events, initialExtendedState} = fsmDef;\r\n        const isValidTransitions = transitions && Array.isArray(transitions);\r\n        const isValidStates = states && typeof(states) === 'object';\r\n        const isValidEvents = events && Array.isArray(events);\r\n        if (!isValidTransitions) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The transitions property for a machine definition must be an array!`,\r\n                    info: {transitions}\r\n                }\r\n            }\r\n        }\r\n        else if (!isValidStates) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The states property for a machine definition must be an object!`,\r\n                    info: {states}\r\n                }\r\n            }\r\n        }\r\n        else if (!isValidEvents) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `The events property for a machine definition must be an array!`,\r\n                    info: {events}\r\n                }\r\n            }\r\n        }\r\n        // NOTE : we do not deal with initialExtendedState, initialControlState and settings\r\n        // this is done in other contracts\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n    },\r\n}\r\n\r\n// T18. Transitions have a valid format, and are either inconditional (no guards) or conditional\r\n// events are strings\r\n// guards are functions\r\n// action factories are functions\r\nexport const haveTransitionsValidTypes = {\r\n    name: 'haveTransitionsValidTypes',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings) => {\r\n        const {transitions} = fsmDef;\r\n        const wrongTransitions = transitions\r\n            .map((transition, transitionIndex) => {\r\n                return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {\r\n                    transition,\r\n                    index: transitionIndex\r\n                }\r\n            })\r\n            .filter(Boolean)\r\n\r\n        const howMany = Object.keys(wrongTransitions).length;\r\n        const isFulfilled = howMany === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `Found ${howMany} transitions with invalid format! Check logs for more details.`,\r\n                info: {wrongTransitions, transitions}\r\n            }\r\n        }\r\n    },\r\n}\r\n\r\nexport const areEventsDeclared = {\r\n    name: 'areEventsDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {eventTransitionsMaps}) => {\r\n        const eventList = Object.keys(eventTransitionsMaps);\r\n        const declaredEventList = fsmDef.events;\r\n        const eventsDeclaredButNotTriggeringTransitions = declaredEventList\r\n            .map(declaredEvent => eventList.indexOf(declaredEvent) === -1 && declaredEvent)\r\n            .filter(Boolean);\r\n        const eventsNotDeclaredButTriggeringTransitions = eventList\r\n            .map(triggeringEvent => declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent)\r\n            .filter(Boolean)\r\n            // Filtering out init events which must not be declared, being reserved events\r\n            // Filtering out undefined events linked to eventless transitions\r\n            .filter(ev => ev !== INIT_EVENT && ev !== 'undefined')\r\n\r\n        const isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0\r\n            && eventsNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `All declared events must be used in transitions. All events used in transition must be declared! Cf. log`,\r\n                info: {eventsDeclaredButNotTriggeringTransitions, eventsNotDeclaredButTriggeringTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const areStatesDeclared = {\r\n    name: 'areStatesDeclared',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {stateEventTransitionsMaps, targetStatesMap, statesType}) => {\r\n        const originStateList = Object.keys(stateEventTransitionsMaps);\r\n        const targetStateList = Array.from(targetStatesMap.keys()).filter(x => typeof x !== 'object');\r\n        const stateList = Object.keys([originStateList, targetStateList].reduce((acc, stateList) => {\r\n            stateList.forEach(state => acc[state] = true)\r\n            return acc\r\n        }, {}));\r\n        const declaredStateList = Object.keys(statesType);\r\n        const statesDeclaredButNotTriggeringTransitions = declaredStateList\r\n            .map(declaredState => stateList.indexOf(declaredState) === -1 && declaredState)\r\n            .filter(Boolean);\r\n        const statesNotDeclaredButTriggeringTransitions = stateList\r\n            .map(stateInTransition =>\r\n                stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition)\r\n            .filter(Boolean);\r\n\r\n        const isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0\r\n            && statesNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n        return {\r\n            isFulfilled,\r\n            blame: {\r\n                message: `All declared states must be used in transitions. All states used in transition must be declared! Cf. log`,\r\n                info: {statesDeclaredButNotTriggeringTransitions, statesNotDeclaredButTriggeringTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T25. SS1 - as of v0.13 settings is no longer mandatory\r\nexport const isValidSettings = {\r\n    name: 'isValidSettings',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef) => {\r\n        return {\r\n            isFulfilled: true,\r\n            blame: void 0\r\n        }\r\n    },\r\n};\r\n\r\n// T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not\r\nexport const isInitialStateOriginState = {\r\n    name: 'isInitialStateOriginState',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {targetStatesMap}) => {\r\n\r\n        if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {\r\n            return {\r\n                isFulfilled: false,\r\n                blame: {\r\n                    message: `Found at least one transition with the initial state as target state! CF. log`,\r\n                    info: {targetStates: Array.from(targetStatesMap.keys()), transitions: fsmDef.transitions}\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                isFulfilled: true,\r\n                blame: void 0\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\n// T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of\r\n// little practical value, though being a possible source of ambiguity or infinite loops)\r\n// A -_> A impossible on compound states because there is A -INIT-> X\r\n// so only possibility is A -_> A with A atomic state\r\nexport const isValidSelfTransition = {\r\n    name: 'isValidSelfTransition',\r\n    shouldThrow: false,\r\n    predicate: (fsmDef, settings, {targetStatesMap, statesType}) => {\r\n        const targetStates = Array.from(targetStatesMap.keys());\r\n        const wrongSelfTransitions = targetStates\r\n            .map(targetState => {\r\n                const flatTransitions = targetStatesMap.get(targetState);\r\n                return flatTransitions\r\n                    .map(flatTransition => {\r\n                        const {from, event} = flatTransition;\r\n                        if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {\r\n                            return {state: targetState, flatTransition}\r\n                        }\r\n                    })\r\n                    .filter(Boolean)\r\n            })\r\n            .filter(x => x.length > 0);\r\n\r\n        return {\r\n            isFulfilled: wrongSelfTransitions.length === 0,\r\n            blame: {\r\n                message: `Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log`,\r\n                info: {wrongSelfTransitions}\r\n            }\r\n        }\r\n    },\r\n};\r\n\r\nexport const fsmContracts = {\r\n    injected: (fsmDef, settings) => {\r\n        return {\r\n            statesType: getStatesType(fsmDef.states),\r\n            initTransition: findInitTransition(fsmDef.transitions),\r\n            statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),\r\n            stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),\r\n            eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),\r\n            ancestorMap: getAncestorMap(fsmDef.states),\r\n            statesPath: getStatesPath(fsmDef.states),\r\n            historyStatesMap: getHistoryStatesMap(fsmDef.transitions),\r\n            targetStatesMap: getTargetStatesMap(fsmDef.transitions)\r\n        }\r\n    },\r\n    description: 'FSM structure',\r\n    contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates],\r\n};\r\n\r\n/**\r\n * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may\r\n * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing\r\n * contract data structure include relevant information about the failing contract, in particular the contract name,\r\n * the associated error message and additional info expliciting the error message.\r\n * @param contractsDef\r\n * @param settings\r\n * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}\r\n */\r\nfunction makeContractHandler(contractsDef, settings) {\r\n    const console = settings && settings.debug && settings.debug.console || emptyConsole;\r\n    const trace = settings && settings.debug && settings.debug.trace || noop;\r\n    const contractsDescription = contractsDef.description;\r\n\r\n    return function checkContracts(...args) {\r\n        const failingContracts = [];\r\n        const computedArgs = contractsDef.injected.apply(null, args);\r\n        const isFulfilled = contractsDef.contracts.reduce((acc, contract) => {\r\n            const {name: contractName, predicate, shouldThrow} = contract;\r\n            const fullArgs = args.concat(computedArgs);\r\n            const {isFulfilled, blame} = predicate.apply(null, fullArgs);\r\n            const blameMessageHeader = `${contractsDescription} FAILS ${contractName}!`;\r\n            const {message, info} = blame || {};\r\n\r\n            if (isFulfilled) return acc\r\n            else {\r\n                failingContracts.push({name: contractName, message, info});\r\n                console.error(blameMessageHeader);\r\n                console.error([contractName, message].join(': '));\r\n                console.debug('Supporting error data:', info);\r\n\r\n                if (shouldThrow) throw new Error([blameMessageHeader, `check console for information!`].join('\\n'))\r\n                else {\r\n                    return false\r\n                }\r\n            }\r\n        }, true)\r\n\r\n        const contractsEval = {isFulfilled, failingContracts};\r\n        trace({[CONTRACTS_EVAL]: contractsEval})\r\n\r\n        return contractsEval\r\n    }\r\n}\r\n\r\nexport const fsmContractChecker = (fsmDef, settings, fsmContracts) => makeContractHandler(fsmContracts, settings)(fsmDef, settings);\r\n\r\n// Terminology\r\n// . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`\r\n// For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,\r\n// guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition\r\n// uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be\r\n// referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.\r\n// . We write A < B if A is a substate of B, with the implication that B is hence a compound state\r\n// . We write A !< B if A is a direct substate of B\r\n// . We write A. !< B if A is a substate of B, and A is also an atomic state\r\n// . We write A -ev-> B to denote a transition from A to B triggered by `ev`\r\n\r\n// Behaviour\r\n// B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly\r\n// returning to the same state)\r\n// ENFORCED by T13, T4, T10, necessary for generative testing\r\n// B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress\r\n// the state machine.\r\n// NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird\r\n// ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice\r\n// B8. It is possible to reach any states\r\n// NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal\r\n","import {\r\n  ACTION_IDENTITY,\r\n  AUTO_EVENT, DEBUG_MSG,\r\n  DEEP,\r\n  ERROR_MSG,\r\n  history_symbol,\r\n  INIT_EVENT, INIT_INPUT_MSG,\r\n  INIT_STATE, INPUT_MSG, INTERNAL_INPUT_MSG, INTERNAL_OUTPUTS_MSG, MACHINE_CREATION_ERROR_MSG,\r\n  OUTPUTS_MSG,\r\n  SHALLOW,\r\n  STATE_PROTOTYPE_NAME,\r\n  WARN_MSG\r\n} from \"./properties\";\r\nimport {\r\n  arrayizeOutput,\r\n  assert,\r\n  computeHistoryMaps,\r\n  destructureEvent,\r\n  emptyConsole,\r\n  emptyTracer,\r\n  findInitTransition,\r\n  get_fn_name,\r\n  getFsmStateList,\r\n  initHistoryDataStructure,\r\n  isActions,\r\n  isEventStruct,\r\n  isHistoryControlState,\r\n  keys, KinglyError,\r\n  updateHistory,\r\n  wrap\r\n} from \"./helpers\";\r\nimport {fsmContractChecker} from \"./contracts\"\r\n\r\nfunction alwaysTrue() {\r\n  return true\r\n};\r\n\r\n/**\r\n * Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state` : {Object<String,Boolean>} Hash whose properties (state names) are matched with\r\n * whether that state is a nested state\r\n * `hash_states` : Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hash_states: {}, is_group_state: {}}}\r\n */\r\nfunction build_nested_state_structure(states) {\r\n  const root_name = \"State\";\r\n  let hash_states = {};\r\n  let is_group_state = {};\r\n\r\n  // Add the starting state\r\n  states = {nok: states};\r\n\r\n  ////////\r\n  // Helper functions\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hash_states[state_name] = new curr_constructor();\r\n      hash_states[state_name].name = state_name;\r\n      const parent_name = (hash_states[state_name].parent_name = get_fn_name(\r\n        curr_constructor\r\n      ));\r\n      hash_states[state_name].root_name = root_name;\r\n\r\n      if (typeof state_config === \"object\") {\r\n        is_group_state[state_name] = true;\r\n        const curr_constructor_new = function () {\r\n        };\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hash_states[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    });\r\n  }\r\n\r\n  function State() {\r\n  }\r\n\r\n  State.prototype = {\r\n    current_state_name: INIT_STATE\r\n  };\r\n\r\n  hash_states[INIT_STATE] = new State();\r\n  hash_states[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hash_states: hash_states,\r\n    is_group_state: is_group_state\r\n  };\r\n}\r\n\r\nexport function normalizeTransitions(fsmDef) {\r\n  const {initialControlState, transitions} = fsmDef;\r\n  const initTransition = findInitTransition(transitions);\r\n\r\n  if (initialControlState) {\r\n    return transitions\r\n      .concat([{from: INIT_STATE, event: INIT_EVENT, to: initialControlState, action: ACTION_IDENTITY}])\r\n  }\r\n  else if (initTransition) {\r\n    return transitions\r\n  }\r\n}\r\n\r\n// Alias for compatibility before deprecating entirely create_state_machine\r\n// TODO: this is not used anymore apparently so remove\r\nexport function create_state_machine(fsmDef, settings) {\r\n  return createStateMachine(fsmDef, settings)\r\n}\r\n\r\n/**\r\n * Creates an instance of state machine from a set of states, transitions, and accepted events. The initial\r\n * extended state for the machine is included in the machine definition.\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @return {function(*=)}\r\n */\r\nexport function createStateMachine(fsmDef, settings) {\r\n  const {\r\n    states: control_states,\r\n    events,\r\n    // transitions ,\r\n    initialExtendedState,\r\n    updateState: userProvidedUpdateStateFn,\r\n  } = fsmDef;\r\n  const {debug, devTool, displayName} = settings || {};\r\n  const checkContracts = debug && debug.checkContracts || void 0;\r\n  let console = debug && debug.console || emptyConsole;\r\n  let tracer = devTool && devTool.tracer || emptyTracer;\r\n  const throwKinglyError = obj => {\r\n    throw new KinglyError(obj, console, tracer)\r\n  };\r\n\r\n  // Conracts must be checked before we start doing all sort of computations\r\n  if (checkContracts) {\r\n    const {failingContracts} = fsmContractChecker(fsmDef, settings, checkContracts);\r\n    try {\r\n      if (failingContracts.length > 0) throwKinglyError({\r\n        when: `Attempting to create a Kingly machine`,\r\n        location: `createStateMachine`,\r\n        info: {fsmDef, settings, failingContracts},\r\n        message: `I found that one or more Kingly contracts are violated!`\r\n      })\r\n    }\r\n    catch (e) {\r\n      // Do not break the program, errors should be passed to console and dev tool\r\n      tracer({\r\n        type: MACHINE_CREATION_ERROR_MSG,\r\n        trace: {\r\n          info: e.errors,\r\n          message: e.message,\r\n          machineState: {cs: INIT_STATE, es: extendedState, hs: history}\r\n        }\r\n      });\r\n      return e\r\n    }\r\n  }\r\n\r\n  const wrappedUpdateState = (extendedState, updates) => {\r\n    const fnName = userProvidedUpdateStateFn.name || userProvidedUpdateStateFn.displayName || \"\";\r\n\r\n    try {\r\n      return userProvidedUpdateStateFn(extendedState, updates)\r\n    }\r\n    catch (e) {\r\n      throwKinglyError({\r\n        when: `Executing updateState function ${fnName}`,\r\n        location: `createStateMachine > wrappedUpdateState`,\r\n        info: {extendedState, updates},\r\n        message: e.message,\r\n        stack: e.stack,\r\n      })\r\n    }\r\n  };\r\n  const transitions = normalizeTransitions(fsmDef);\r\n\r\n  // Create the nested hierarchy\r\n  const hash_states_struct = build_nested_state_structure(control_states);\r\n\r\n  // This will be the extended state object which will be updated by all actions and on which conditions\r\n  // will be evaluated It is safely contained in a closure so it cannot be accessed in any way\r\n  // outside the state machine.\r\n  // Note the extended state is modified by the `settings.updateState` function, which should not modify\r\n  // the extended state object. There is hence no need to do any cloning.\r\n  let extendedState = initialExtendedState;\r\n\r\n  // history maps\r\n  const {stateList, stateAncestors} = computeHistoryMaps(control_states);\r\n  let history = initHistoryDataStructure(stateList);\r\n\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has a init transition defined\r\n  let is_init_state = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined\r\n  // that would be init transitions + eventless transitions\r\n  let is_auto_state = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state is a group of state or not\r\n  const is_group_state = hash_states_struct.is_group_state;\r\n  let hash_states = hash_states_struct.hash_states;\r\n\r\n  function assertContract(contract, arrayParams) {\r\n    const hasFailed = assert(contract, arrayParams);\r\n    if (checkContracts && hasFailed) {\r\n      throwKinglyError(hasFailed)\r\n    }\r\n\r\n    return void 0\r\n  }\r\n\r\n  function getCurrentControlState() {\r\n    return hash_states[INIT_STATE].current_state_name\r\n  }\r\n\r\n  function send_event(event_struct, isExternalEvent) {\r\n    // TODO: maybe open a console.group and close it on return\r\n    assertContract(isEventStruct, [event_struct]);\r\n\r\n    const {eventName, eventData} = destructureEvent(event_struct);\r\n    const current_state = getCurrentControlState();\r\n\r\n    console.debug(\"send event\", event_struct);\r\n\r\n    // Edge case : INIT_EVENT sent and the current state is not the initial state\r\n    // We have to do this separately, as by construction the INIT_STATE is a\r\n    // super state of all states in the machine. Hence sending an INIT_EVENT\r\n    // would always execute the INIT transition by prototypal delegation\r\n    if (isExternalEvent && eventName === INIT_EVENT && current_state !== INIT_STATE) {\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: {eventName, eventData},\r\n          message: `The external event INIT_EVENT can only be sent when starting the machine!`,\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n      console.warn(`The external event INIT_EVENT can only be sent when starting the machine!`)\r\n\r\n      return null\r\n    }\r\n\r\n    const outputs = process_event(\r\n      hash_states_struct.hash_states,\r\n      eventName,\r\n\r\n      eventData,\r\n      extendedState\r\n    );\r\n\r\n    return outputs\r\n  }\r\n\r\n  function process_event(hash_states, event, event_data, extendedState) {\r\n    const current_state = hash_states[INIT_STATE].current_state_name;\r\n    const event_handler = hash_states[current_state][event];\r\n\r\n    if (event_handler) {\r\n      // CASE : There is a transition associated to that event\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event, event_data);\r\n      /* OUT : this event handler modifies the extendedState and possibly other data structures */\r\n      const {stop, outputs: rawOutputs} = event_handler(extendedState, event_data, current_state);\r\n      debug && !stop && console.warn(\"No guards have been fulfilled! We recommend to configure guards explicitly to\" +\r\n        \" cover the full state space!\")\r\n      const outputs = arrayizeOutput(rawOutputs);\r\n\r\n      // we read it anew as the execution of the event handler may have changed it\r\n      const new_current_state = hash_states[INIT_STATE].current_state_name;\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the current state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1: init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case event_data will carry on the data passed on from the last event (else we loose\r\n      // the extendedState?)\r\n      // 2. transitions with no events associated, only conditions (i.e. transient states)\r\n      // NOTE : the guard is to defend against loops occuring when an AUTO transition fails to advance and stays\r\n      // in the same control state!! But by contract that should never happen : all AUTO transitions should advance!\r\n      // TODO : test that case, what is happening? I should add a branch and throw!!\r\n      if (is_auto_state[new_current_state] && new_current_state !== current_state) {\r\n        // CASE : transient state with no triggering event, just conditions\r\n        // automatic transitions = transitions without events\r\n        const auto_event = is_init_state[new_current_state]\r\n          ? INIT_EVENT\r\n          : AUTO_EVENT;\r\n\r\n        tracer({\r\n          type: INTERNAL_INPUT_MSG,\r\n          trace: {\r\n            info: {eventName: auto_event, eventData: event_data},\r\n            event: {[auto_event]: event_data},\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        const nextOutputs = send_event({[auto_event]: event_data}, false);\r\n\r\n        tracer({\r\n          type: INTERNAL_OUTPUTS_MSG,\r\n          trace: {\r\n            outputs: nextOutputs,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        return [].concat(outputs).concat(nextOutputs);\r\n      } else return outputs;\r\n    } else {\r\n      // CASE : There is no transition associated to that event from that state\r\n      console.warn(`There is no transition associated to the event |${event}| in state |${current_state}|!`);\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: {received: {[event]: event_data}},\r\n          message: `There is no transition associated to the event |${event}| in state |${current_state}|!`,\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  function leave_state(from, extendedState, hash_states) {\r\n    // NOTE : extendedState is passed as a parameter for symetry reasons, no real use for it so far\r\n    const state_from = hash_states[from];\r\n    const state_from_name = state_from.name;\r\n\r\n    history = updateHistory(history, stateAncestors, state_from_name);\r\n\r\n    console.info(\"left state\", wrap(from));\r\n  }\r\n\r\n  function enter_next_state(to, updatedExtendedState, hash_states) {\r\n    let state_to;\r\n    let state_to_name;\r\n    // CASE : history state (H)\r\n    if (isHistoryControlState(to)) {\r\n      const history_type = to.deep ? DEEP : to.shallow ? SHALLOW : void 0;\r\n      const history_target = to[history_type];\r\n      // Edge case : history state (H) && no history (i.e. first time state is entered), target state\r\n      // is the entered state\r\n      // TODO: edge case should be init state for compound state, and check it is recursively descended,\r\n      // and error if the history target is an atomic state\r\n      // if (!is_auto_state(history_target)) throw `can't be atomic state`\r\n      // then by setting the compound state, it should evolve toward to init control state naturally\r\n      debug && console && !is_init_state[history_target] && console.error(`Configured a history state which does not relate to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration`);\r\n      state_to_name = history[history_type][history_target] || history_target;\r\n      state_to = hash_states[state_to_name];\r\n    }\r\n    else if (to) {\r\n      // CASE : normal state\r\n      state_to = hash_states[to];\r\n      state_to_name = state_to.name;\r\n    } else {\r\n      throwKinglyError (\"enter_state : unknown case! Not a state name, and not a history state to enter!\");\r\n    }\r\n    hash_states[INIT_STATE].current_state_name = state_to_name;\r\n\r\n    tracer({\r\n      type: DEBUG_MSG,\r\n      trace: {\r\n        message: isHistoryControlState(to)\r\n          ? `Entering history state for ${to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]}`\r\n          : `Entering state ${to}`,\r\n        machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n      }\r\n    });\r\n    debug && console.info(\"AND TRANSITION TO STATE\", state_to_name);\r\n    return state_to_name;\r\n  }\r\n\r\n  function start() {\r\n    tracer({\r\n      type: INIT_INPUT_MSG,\r\n      trace: {\r\n        info: {eventName: INIT_EVENT, eventData: initialExtendedState},\r\n        event: {[INIT_EVENT]: initialExtendedState},\r\n        machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n      }\r\n    });\r\n\r\n    return send_event({[INIT_EVENT]: initialExtendedState}, true);\r\n  }\r\n\r\n  transitions.forEach(function (transition) {\r\n    let {from, to, action, event, guards: arr_predicate} = transition;\r\n    // CASE : ZERO OR ONE condition set\r\n    if (!arr_predicate)\r\n      arr_predicate = [{predicate: void 0, to: to, action: action}];\r\n\r\n    // CASE : transition has a init event\r\n    // NOTE : there should ever only be one, but we don't enforce it here\r\n    if (event === INIT_EVENT) {\r\n      is_init_state[from] = true;\r\n    }\r\n\r\n    let from_proto = hash_states[from];\r\n\r\n    // CASE : automatic transitions : no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      is_auto_state[from] = true;\r\n    }\r\n    // CASE : automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (is_group_state[from] && is_init_state[from]) {\r\n      is_auto_state[from] = true;\r\n    }\r\n\r\n    // TODO : this seriously needs refactoring, that is one line in ramda\r\n    from_proto[event] = arr_predicate.reduce((acc, guard, index) => {\r\n        const action = guard.action || ACTION_IDENTITY;\r\n        const actionName = action.name || action.displayName || \"\";\r\n        const condition_checking_fn = (function (guard, settings) {\r\n          let condition_suffix = \"\";\r\n          // We add the `current_state` because the current control state might be different from\r\n          // the `from` field here This is the case for instance when we are in a substate, but\r\n          // through prototypal inheritance it is the handler of the prototype which is called\r\n          const condition_checking_fn = function (extendedState_, event_data, current_state) {\r\n            from = current_state || from;\r\n            const predicate = guard.predicate || alwaysTrue;\r\n            const predicateName = predicate.name || predicate.displayName || \"<anonymous>\";\r\n            const to = guard.to;\r\n            const shouldTransitionBeTaken = ((extendedState, event_data, settings) => {\r\n              try {\r\n                return predicate(extendedState, event_data, settings);\r\n              }\r\n              catch (e) {\r\n                throwKinglyError({\r\n                  when: `Executing predicate function ${predicateName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken`,\r\n                  info: {extendedState, event, event_data, settings, guard, from, to, index},\r\n                  message: [`Error occurred while processing event ${event} with target state ${to}`, e.message].join(\"\\n\"),\r\n                  stack: e.stack,\r\n                })\r\n              }\r\n            })(extendedState_, event_data, settings);\r\n\r\n            if (typeof shouldTransitionBeTaken !== \"boolean\") {\r\n              throwKinglyError({\r\n                when: `Executing predicate function ${predicateName}`,\r\n                location: `createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult`,\r\n                info: {event, guard, from, to, index, shouldTransitionBeTaken},\r\n                message: `Guard index ${index} with name ${predicateName} did not return a boolean!`,\r\n              })\r\n            }\r\n\r\n            if (shouldTransitionBeTaken) {\r\n              // CASE : guard for transition is fulfilled so we can execute the actions...\r\n              console.info(\"IN STATE \", from);\r\n              if (guard.predicate) {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `The guard ${predicateName} is fulfilled`,\r\n                    info: {eventData: event_data, from, action: actionName, to},\r\n                    machineState: {cs: current_state, es: extendedState_, hs: history}\r\n                  }\r\n                });\r\n                console.info(`CASE: guard ${predicate.name} for transition is fulfilled`);\r\n              }\r\n              else {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `Evaluating transition with no guards`,\r\n                    info: {eventData: event_data, from, action: actionName, to},\r\n                    machineState: {cs: current_state, es: extendedState, hs: history}\r\n                  }\r\n                });\r\n                console.info(`CASE: unguarded transition`);\r\n              }\r\n\r\n              console.info(\"THEN : we execute the action \" + actionName);\r\n              const actionResult = ((extendedState, eventData, settings) => {\r\n                try {\r\n                  return action(extendedState, eventData, settings);\r\n                }\r\n                catch (e) {\r\n                  throwKinglyError({\r\n                    when: `Executing action factory ${actionName}`,\r\n                    location: `createStateMachine > event handler > condition_checking_fn`,\r\n                    info: {extendedState, event, event_data, settings, guard, from, to, index, action},\r\n                    message: e.message,\r\n                    stack: e.stack,\r\n                  })\r\n                }\r\n              })(extendedState_, event_data, settings);\r\n\r\n              if (!isActions(actionResult)) {\r\n                throwKinglyError({\r\n                  when: `Executing action factory ${actionName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn`,\r\n                  info: {extendedState, event, event_data, settings, guard, from, to, index, action, actionResult},\r\n                  message: `Action factory returned a value that does not have the expected shape!`,\r\n                })\r\n              }\r\n\r\n              const {updates, outputs} = actionResult;\r\n\r\n              // Leave the current state\r\n              leave_state(from, extendedState_, hash_states);\r\n\r\n              // Update the extendedState before entering the next state\r\n              extendedState = wrappedUpdateState(extendedState_, updates);\r\n\r\n              // ...and enter the next state (can be different from `to` if we have nesting state group)\r\n              const next_state = enter_next_state(to, updates, hash_states);\r\n              console.info(\"ENTERING NEXT STATE: \", next_state);\r\n              console.info(\"with extended state: \", extendedState);\r\n\r\n              // allows for chaining and stop chaining guard\r\n              return {stop: true, outputs};\r\n            }\r\n            else {\r\n              // CASE : guard for transition is not fulfilled\r\n              tracer({\r\n                type: DEBUG_MSG,\r\n                trace: {\r\n                  message: guard.predicate ? `The guard ${predicateName} is not fulfilled!` : `Evaluated and skipped transition`,\r\n                  info: {eventData: event_data, settings, guard, from, to, index, action: actionName},\r\n                  machineState: {cs: current_state, es: extendedState, hs: history}\r\n                }\r\n              });\r\n              return {stop: false, outputs: null};\r\n            }\r\n          };\r\n          // TODO: remove that, I don't need that anymore\r\n          condition_checking_fn.displayName = from + condition_suffix;\r\n          return condition_checking_fn;\r\n        })(guard, settings);\r\n\r\n        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {\r\n          const condition_checked = acc(extendedState_, event_data, current_state);\r\n          return condition_checked.stop\r\n            ? condition_checked\r\n            : condition_checking_fn(extendedState_, event_data, current_state);\r\n        };\r\n      },\r\n      function dummy() {\r\n        return {stop: false, outputs: null};\r\n      }\r\n    );\r\n  });\r\n\r\n  // TODO: think if rethrow errors we are not responsible for here too\r\n  try {\r\n    start();\r\n  }\r\n  catch (e) {\r\n    // Do not break the program, errors should be passed to console and dev tool\r\n    tracer({\r\n      type: MACHINE_CREATION_ERROR_MSG,\r\n      trace: {\r\n        message: e.message,\r\n        info: {fsmDef, settings, error: e},\r\n        machineState: {cs: INIT_STATE, es: extendedState, hs: history}\r\n      }\r\n    });\r\n    return e\r\n  }\r\n\r\n  // NOTE : yield is a reserved JavaScript word so using yyield\r\n  return function yyield(x) {\r\n    try {\r\n      const {eventName, eventData} = destructureEvent(x);\r\n      const current_state = getCurrentControlState();\r\n\r\n      tracer({\r\n        type: INPUT_MSG,\r\n        trace: {\r\n          info: {eventName, eventData},\r\n          machineState: {cs: current_state, es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      const outputs = send_event(x, true);\r\n\r\n      debug && console.info(\"OUTPUTS:\", outputs);\r\n      tracer({\r\n        type: OUTPUTS_MSG,\r\n        trace: {\r\n          outputs,\r\n          machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n        }\r\n      });\r\n\r\n      return outputs\r\n    }\r\n    catch (e) {\r\n      if (e instanceof KinglyError) {\r\n        // We don't break the program, but we can't continue as nothing happened: we return the error\r\n        tracer({\r\n          type: ERROR_MSG,\r\n          trace: {\r\n            error: e,\r\n            message: `An error ocurred while running an input through the machine!`,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n\r\n        return e\r\n      }\r\n      else {\r\n        tracer({\r\n          type: ERROR_MSG,\r\n          trace: {\r\n            error: e,\r\n            message: `An unknown error ocurred while running an input through the machine!`,\r\n            machineState: {cs: getCurrentControlState(), es: extendedState, hs: history}\r\n          }\r\n        });\r\n        console.error(`yyield > unexpected error!`, e);\r\n        // We should only catch the errors we are responsible for!\r\n        throw e\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {WebComponentName} name name for the web component. Must include at least one hyphen per custom\r\n * components' specification\r\n * @param {Subject} eventHandler A factory function which returns a subject, i.e. an object which\r\n * implements the `Observer` and `Observable` interface\r\n * @param {FSM} fsm An executable machine, i.e. a function which accepts machine inputs\r\n * @param {Object.<CommandName, CommandHandler>} commandHandlers\r\n * @param {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an effect moniker to a function performing the corresponding effect.\r\n * @param {{initialEvent, terminalEvent, NO_ACTION}} options\r\n */\r\nexport function makeWebComponentFromFsm({name, eventHandler, fsm, commandHandlers, effectHandlers, options}) {\r\n  class FsmComponent extends HTMLElement {\r\n    constructor() {\r\n      if (name.split('-').length <= 1) throw `makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!`\r\n      super();\r\n      const el = this;\r\n      this.eventSubject = eventHandler;\r\n      this.options = Object.assign({}, options);\r\n      const NO_ACTION = this.options.NO_ACTION || null;\r\n\r\n      // Set up execution of commands\r\n      this.eventSubject.subscribe({\r\n        next: eventStruct => {\r\n          const actions = fsm(eventStruct);\r\n\r\n          if (actions === NO_ACTION) return;\r\n          actions.forEach(action => {\r\n            if (action === NO_ACTION) return;\r\n            const {command, params} = action;\r\n            commandHandlers[command](this.eventSubject.next, params, effectHandlers, el);\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      return [];\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);\r\n      this.eventSubject.complete();\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      // simulate a new creation every time an attribute is changed\r\n      // i.e. they are not expected to change\r\n      this.constructor();\r\n      this.connectedCallback();\r\n    }\r\n  }\r\n\r\n  return customElements.define(name, FsmComponent);\r\n}\r\n\r\n/**\r\n * This function works to merge outputs by simple concatenation and flattening\r\n * Every action return T or [T], and we want in output [T] always\r\n * mergeOutputsFn([a, [b]) = mergeOutputsFn([a,b]) = mergeOutputsFn([[a],b) = mergeOutputsFn([[a],[b]]) = [a,b]\r\n * If we wanted to pass [a] as value we would have to do mergeOutputsFn([[[a]],[b]]) to get [[a],b]\r\n * @param arrayOutputs\r\n * @returns {*}\r\n */\r\nexport function mergeOutputsFn(arrayOutputs) {\r\n  // NOTE : here, this array of outputs could be array x non-array ^n\r\n  // The algorithm is to concat all elements\r\n  return arrayOutputs.reduce((acc, element) => acc.concat(element), [])\r\n}\r\n\r\n/**\r\n * Construct history states `hs` from a list of states for a given state machine. The history states for a given control\r\n * state can then be referenced as follows :\r\n * - `hs.shallow(state)` will be the shallow history state associated to the `state`\r\n * - `hs.deep(state)` will be the deep history state associated to the `state`\r\n * @param {FSM_States} states\r\n * @return {HistoryStateFactory}\r\n */\r\nexport function makeHistoryStates(states) {\r\n  const stateList = Object.keys(getFsmStateList(states));\r\n  // used for referential equality comparison to discriminate history type\r\n\r\n  return (historyType, controlState) => {\r\n    if (!stateList.includes(controlState)) {\r\n      throw `makeHistoryStates: the state for which a history state must be constructed is not a configured state for the state machine under implementation!!`\r\n    }\r\n\r\n    return {\r\n      [historyType]: controlState,\r\n      type: history_symbol\r\n    }\r\n  }\r\n}\r\n\r\nexport function historyState(historyType, controlState) {\r\n  return {\r\n    [historyType]: controlState\r\n  }\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INIT_STATE, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  getDisplayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${getDisplayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {ControlState} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INIT_STATE) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n","// TODO : export only the three functions part of the API! might require updating tests imports\r\n// - move the converter to yed2kingly or a new single script with options (convert to knogly, to uml, etc.)\r\nexport * from './types'\r\nexport * from './synchronous_fsm'\r\nexport * from './converter'\r\nexport * from './properties'\r\nexport * from './helpers'\r\nexport {fsmContracts} from './contracts'\r\n"],"names":["CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE","SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INIT_STATE","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_STATE_UPDATE","NO_OUTPUT","ACTION_IDENTITY","outputs","updates","history_symbol","SHALLOW","DEEP","WRONG_EVENT_FORMAT_ERROR","FUNCTION_THREW_ERROR","fnName","type","INVALID_ACTION_FACTORY_EXECUTED","actionName","INVALID_PREDICATE_EXECUTED","ACTION_FACTORY_DESC","ENTRY_ACTION_FACTORY_DESC","UPDATE_STATE_FN_DESC","PREDICATE_DESC","COMMAND_RENDER","CONTRACTS_EVAL","OUTPUTS_MSG","INPUT_MSG","WARN_MSG","MACHINE_CREATION_ERROR_MSG","ERROR_MSG","INTERNAL_INPUT_MSG","INTERNAL_OUTPUTS_MSG","DEBUG_MSG","INIT_INPUT_MSG","noop","emptyConsole","log","warn","info","debug","error","trace","emptyTracer","isBoolean","x","isFunction","isControlState","isHistoryControlState","isEvent","isActionFactory","make_states","stateList","reduce","acc","state","make_events","eventList","get_fn_name","fn","tokens","exec","toString","wrap","str","join","times","n","Array","apply","length","map","Number","call","always","keys","obj","Object","merge","a","b","assign","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","from","is_to_history_control_state_of","is_history_control_state_of","substring","format_transition_label","_event","predicate","action","name","format_history_transition_state_name","get_all_transitions","guards","getDisplayName","replace","mergeModelUpdates","arrayUpdateActions","extendedState","eventData","settings","updateAction","update","concat","chainModelUpdates","updateState","updatedState","mergeActionFactories","mergeOutputFn","arrayActionFactory","arrayActions","factory","arrayStateUpdates","arrayOutputs","identity","lastOf","arr","formatActionName","predicateName","formattedPredicate","formattedAction","getFsmStateList","states","getLabel","objectTreeLenses","traverse","strategy","PRE_ORDER","seed","visit","accStateList","traversalState","tree","treeLabel","stateHashMap","traverseObj","getStatesType","statesTree","isLeafLabel","getStatesPath","pathStr","get","path","getStatesTransitionsMap","transitions","getStateEventTransitionsMaps","getEventTransitionsMaps","getHistoryStatesMap","reduceTransitions","flatTransition","guardIndex","transitionIndex","gen","underlyingControlState","getHistoryUnderlyingState","set","Map","getTargetStatesMap","getAncestorMap","getChildren","children","childrenControlStates","forEach","computeHistoryMaps","control_states","stateAncestors","JSON","stringify","parentPath","slice","parentControlState","_","ancestors","mapOverTransitionsActions","mapFn","mappedAction","displayName","push","reduceFn","result","transitionStruct","undefined","guard","everyTransition","pred","computeTimesCircledOn","edgePath","edge","edgeInEdgePath","isInitState","s","isInitEvent","e","isEventless","arrayizeOutput","output","isArray","getHistoryParentState","isShallowHistory","isDeepHistory","getHistoryType","history","isHistoryStateEdge","initHistoryDataStructure","initHistory","isCompoundState","analyzedStates","statesAdjacencyList","isAtomicState","updateHistory","state_from_name","oldAncestor","newAncestor","computeHistoryState","controlStateSequence","historyType","historyParentState","findInitTransition","find","tryCatch","errCb","args","tryCatchMachineFn","fnType","argsDesc","err","Error","getFunctionName","probableCause","params","argDesc","index","actionFactory","assert","contract","arrayParams","contractName","isFulfilledOrError","when","message","notifyThrows","console","handleFnExecError","notify","execInfo","actionResultOrError","postCondition","throwFn","invalidResultFn","notifyAndRethrow","throwIfInvalidActionResult","updatedExtendedState","returned","throwIfInvalidGuardResult","resultOrError","predName","throwIfInvalidEntryActionResult","exitActionResultOrError","isActions","isEventStruct","trueOrError","cause","isError","destructureEvent","eventName","formatUndefinedInJSON","key","value","KinglyError","m","tracer","stack","errors","location","fm","infoMsg","fullMsg","noDuplicatedStates","shouldThrow","fsmDef","duplicatedStates","statesHashMap","isFulfilled","blame","noReservedStates","statesType","indexOf","reservedStates","atLeastOneState","isInitialControlStateDeclared","initTransition","initialControlState","declaredStates","eventsAreStrings","events","every","validInitialConfig","validInitialTransition","initTransitions","isInconditionalTransition","areCconditionalTransitions","initEventOnlyInCompoundStates","statesTransitionsMap","statesPath","atomicStates","filter","atomicInitTransitions","atomicState","values","hasInitEventOnlyInCompoundStates","validInitialTransitionForCompoundState","compoundStates","compoundStatesInitTransitions","compoundState","allHaveInitTransitions","Boolean","hasEntryTransitions","allHaveValidInitTransitions","targetStates","targetState","entryTransitions","allHaveTargetStatesWithinHierarchy","validEventLessTransitions","failingOriginControlStates","allStateTransitionsOnOneSingleRow","stateEventTransitionsMaps","originStateList","statesTransitionsInfo","wrongEventConfig","noConflictingTransitionsWithAncestorState","eventTransitionsMaps","ancestorMap","ev","eventTransitionsInfo","wrongStateConfig","ancestorState","isHistoryStatesTargetStates","wrongHistoryStates","isHistoryStatesCompoundStates","originState","isHistoryStatesExisting","historyStatesMap","invalidTransitions","entries","historyState","flatTransitions","howMany","isValidGuard","isValidFsmDef","initialExtendedState","isValidTransitions","isValidStates","isValidEvents","haveTransitionsValidTypes","wrongTransitions","areEventsDeclared","declaredEventList","eventsDeclaredButNotTriggeringTransitions","declaredEvent","eventsNotDeclaredButTriggeringTransitions","triggeringEvent","areStatesDeclared","targetStatesMap","targetStateList","declaredStateList","statesDeclaredButNotTriggeringTransitions","declaredState","statesNotDeclaredButTriggeringTransitions","stateInTransition","isValidSettings","isInitialStateOriginState","isValidSelfTransition","wrongSelfTransitions","fsmContracts","injected","description","contracts","makeContractHandler","contractsDef","contractsDescription","checkContracts","failingContracts","computedArgs","fullArgs","blameMessageHeader","contractsEval","fsmContractChecker","alwaysTrue","build_nested_state_structure","root_name","hash_states","is_group_state","nok","build_state_reducer","curr_constructor","state_name","state_config","parent_name","curr_constructor_new","prototype","State","current_state_name","normalizeTransitions","create_state_machine","createStateMachine","userProvidedUpdateStateFn","devTool","throwKinglyError","machineState","cs","es","hs","wrappedUpdateState","hash_states_struct","is_init_state","is_auto_state","assertContract","hasFailed","getCurrentControlState","send_event","event_struct","isExternalEvent","current_state","process_event","event_data","event_handler","stop","rawOutputs","new_current_state","auto_event","nextOutputs","received","leave_state","state_from","enter_next_state","state_to","state_to_name","history_type","deep","shallow","history_target","start","arr_predicate","from_proto","condition_checking_fn","condition_suffix","extendedState_","shouldTransitionBeTaken","actionResult","next_state","arr_predicate_reduce_fn","condition_checked","dummy","yyield","makeWebComponentFromFsm","eventHandler","fsm","commandHandlers","effectHandlers","options","FsmComponent","split","el","eventSubject","NO_ACTION","subscribe","next","eventStruct","actions","command","initialEvent","terminalEvent","complete","oldValue","newValue","constructor","connectedCallback","HTMLElement","customElements","define","mergeOutputsFn","element","makeHistoryStates","includes","generateStatePlantUmlHeader","optDisplayName","toPlantUml","constructTree","getChildrenNumber","pathMap","childrenTranslation","translation","stateToPlantUML","translationMap","postOrderTraverseTree","mappedTree","clear","format_history_states","format_entry_transitions","translate_transitions","historyStatesObj","accTranslation","allTransitions","historyStates","historyTransitionTranslation","format_history_transitions","standardTransitionTranslation","format_standard_transitions","toDagreVisualizerFormat","arrayTreeLenses","_translatedStates","translatedStates","translatedTransitions","translatedGuards"],"mappings":"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"}